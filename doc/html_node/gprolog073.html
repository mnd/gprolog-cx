<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<LINK rel="stylesheet" type="text/css" href="gprolog.css">
<TITLE>Defining a new C main() function</TITLE>
</HEAD>
<BODY TEXT=black BGCOLOR=white>
<A HREF="gprolog072.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="gprolog066.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<HR>
<H3 CLASS="subsection"><A NAME="htoc391">10.7</A>&#XA0;&#XA0;Defining a new C <TT>main()</TT> function</H3><UL>
<LI><A HREF="gprolog073.html#toc320">Example: asking for ancestors</A>
</LI></UL>
<P>GNU Prolog allows the user to define his own <TT>main()</TT>
function. This can be useful to perform several tasks before starting
the Prolog engine. To do this simply define a classical
<TT>main(argc, argv)</TT> function. The following functions can then be used:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">int    Pl_Start_Prolog         (int argc, char *argv[])
void   Pl_Stop_Prolog          (void)
void   Pl_Reset_Prolog         (void)
PlBool Pl_Try_Execute_Top_Level(void)
</PRE></DD></DL><P>The function <TT>Pl_Start_Prolog(argc, argv)</TT> initializes the Prolog
engine (<TT>argc</TT> and <TT>argv</TT> are the command-line variables). This
function collects all linked objects (issued from the compilation of Prolog
files) and initializes them. The initialization of a Prolog object file
consists in adding to appropriate tables new atoms, new predicates and
executing its system directives. A system directive is generated by the
Prolog to WAM compiler to reflect a (user) directive executed at compile-time
such as <TT>op/3</TT> (section&#XA0;<A HREF="gprolog022.html#op/3">7.1.11</A>). Indeed, when the compiler encounters such
a directive it immediately executes it and also generates a system directive
to execute it at the start of the executable. When all system directives
have been executed the Prolog engine executes all initialization directives
defined with <TT>initialization/1</TT>
(section&#XA0;<A HREF="gprolog022.html#initialization/1">7.1.14</A>). The function returns the number of user
directives (i.e. <TT>initialization/1</TT>) executed. This function must be
called only once.</P><P>The function <TT>Pl_Stop_Prolog()</TT> stops the Prolog engine. This function
must be called only once after all Prolog treatment have been done.</P><P>The function <TT>Pl_Reset_Prolog()</TT> reinitializes the Prolog engine
(i.e. reset all Prolog stacks).</P><P>The function <TT>Pl_Try_Execute_Top_Level()</TT> executes the
top-level if linked (section&#XA0;<A HREF="gprolog009.html#Using-the-compiler">4.4.3</A>) and returns
<TT>PL_TRUE</TT>. If the top-level is not present the functions returns
<TT>PL_FALSE</TT>.</P><P>Here is the definition of the default GNU Prolog <TT>main()</TT> function:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">static int
Main_Wrapper(int argc, char *argv[])
{
  int nb_user_directive;
  PlBool top_level;

  nb_user_directive = Pl_Start_Prolog(argc, argv);

  top_level = Pl_Try_Execute_Top_Level();

  Pl_Stop_Prolog();

  if (top_level || nb_user_directive)
    return 0;

  fprintf(stderr,
          "Warning: no initial goal executed\n"
          "   use a directive :- initialization(Goal)\n"
          "   or remove the link option --no-top-level"
          " (or --min-bips or --min-size)\n");

  return 1;
}

int
main(int argc, char *argv[])
{
  return Main_Wrapper(argc, argv);
}
</PRE></DD></DL><P>Note that under some circumstances it is necessary to encapsulate the code of
<TT>main()</TT> inside an intermediate function called by
<TT>main()</TT>. Indeed, some C compilers (e.g. gcc) treats <TT>main()</TT>
particularly, producing an incompatible code w.r.t GNU Prolog. So it is a
good idea to always use a wrapper function as shown above.</P><H4 CLASS="subsubsection"><A NAME="toc320"></A><A NAME="htoc392">10.7.1</A>&#XA0;&#XA0;Example: asking for ancestors</H4><P>In this example we use the following Prolog code (in a file called
<TT>new_main.pl</TT>):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">parent(bob,   mary).
parent(jane,  mary).
parent(mary,  peter).
parent(paul,  peter).
parent(peter, john).

anc(X, Y):-
        parent(X, Y).

anc(X, Z) :-
        parent(X, Y),
        anc(Y, Z).
</PRE></DD></DL><P>The following file (called <TT>new_main_c.c</TT>) defines a <TT>main()</TT>
function read the name of a person and displaying all successors of that
person. This is equivalent to the Prolog query: <TT>anc(Result, Name)</TT>.</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">static int
Main_Wrapper(int argc, char *argv[])
{
  int func;
  PlTerm arg[10];
  char str[100];
  char *sol[100];
  int i, nb_sol = 0;
  PlBool res;

  Pl_Start_Prolog(argc, argv);

  func = Pl_Find_Atom("anc");
  for (;;)
    {
      printf("\nEnter a name (or 'end' to finish): ");
      fflush(stdout);
      scanf("%s", str);

      if (strcmp(str, "end") == 0)
 break;

      Pl_Query_Begin(PL_TRUE);

      arg[0] = Pl_Mk_Variable();
      arg[1] = Pl_Mk_String(str);
      nb_sol = 0;
      res = Pl_Query_Call(func, 2, arg);
      while (res)
 {
   sol[nb_sol++] = Pl_Rd_String(arg[0]);
   res = Pl_Query_Next_Solution();
 }
      Pl_Query_End(PL_RECOVER);

      for (i = 0; i &lt; nb_sol; i++)
 printf("  solution: %s\n", sol[i]);
      printf("%d solution(s)\n", nb_sol);
    }

  Pl_Stop_Prolog();
  return 0;
}

int
main(int argc, char *argv[])
{
  return Main_Wrapper(argc, argv);
}
</PRE></DD></DL><P>The compilation produces an executable called <TT>new_main</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>% gplc new_main.pl new_main_c.c</TT></DD></DL><P>Examples of use:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">Enter a name (or 'end' to finish): john
  solution: peter
  solution: bob
  solution: jane
  solution: mary
  solution: paul
5 solution(s)

Enter a name (or 'end' to finish): mary
  solution: bob
  solution: jane
2 solution(s)

Enter a name (or 'end' to finish): end
</PRE></DD></DL>
<HR SIZE=2>
Copyright (C) 1999-2012 Daniel Diaz
Verbatim copying and distribution of this entire article is permitted in any
medium, provided this notice is preserved. <A HREF="index.html#copyright">More about the copyright</A>
<HR>
<A HREF="gprolog072.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="gprolog066.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
</BODY>
</HTML>
