<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>GNU-Prolog Manual
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
BODY{background:white;}
.section{padding:.5ex;background:#2DE52D;}
.subsection{padding:0.3ex;background:#66FF66;}
.subsubsection{padding:0.5ex;background:#99FF99;}
.ftoc1{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #00CC00;}
.ftoc2{list-style:none;margin:1ex 1ex;padding:0ex 1ex;border-left:1ex solid #2DE52D;}
.ftoc3{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid #66FF66;}
</STYLE>
</HEAD>
<BODY TEXT=black BGCOLOR=white>
<!--HEVEA command line is: /usr/bin/hevea -O -s -exec xxdate.exe -fix custom.hva gprolog.tex -o gprolog.html -->
<!--CUT DEF section 1 --><DIV CLASS="center"><TABLE CELLPADDING=10><TR><TD BGCOLOR="#00CC00"><DIV CLASS="center">
<FONT SIZE=6><B>GNU PROLOG</B></FONT>
<HR SIZE=2><P><FONT SIZE=5>A Native Prolog Compiler with Constraint Solving over Finite Domains</FONT></P><P><FONT SIZE=5>Edition 1.31, for GNU Prolog version 1.4.1<BR>

June&#XA0;6, 2012</FONT>
</P><P><FONT SIZE=5><B>by <A HREF="http://cri-dist.univ-paris1.fr/diaz">Daniel Diaz</A></B></FONT></P><HR SIZE=2></DIV></TD></TR>
</TABLE></DIV><P><A NAME="copyright"></A>
Copyright (C) 1999-2012 Daniel Diaz
</P><P>Permission is granted to make and distribute verbatim copies of this manual
provided the copyright notice and this permission notice are preserved on all
copies.</P><P>Permission is granted to copy and distribute modified versions of this manual
under the conditions for verbatim copying, provided that the entire resulting
derived work is distributed under the terms of a permission notice identical
to this one.</P><P>Permission is granted to copy and distribute translations of this manual into
another language, under the above conditions for modified versions, except
that this permission notice may be stated in a translation approved by the
<A HREF="http://www.fsf.org/">Free Software Foundation</A>, 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA.</P><HR SIZE=2><!--TOC section Contents-->
<H2 CLASS="section"><!--SEC ANCHOR -->Contents</H2><!--SEC END --><UL CLASS="ftoc1"><LI CLASS="li-toc">
<A HREF="#htoc1">1&#XA0;&#XA0;Acknowledgements</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc2">2&#XA0;&#XA0;GNU Prolog License Conditions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc3">3&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc4">4&#XA0;&#XA0;Using GNU Prolog</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc5">4.1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc6">4.2&#XA0;&#XA0;The GNU Prolog interactive interpreter</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc7">4.2.1&#XA0;&#XA0;Starting/exiting the interactive interpreter</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc8">4.2.2&#XA0;&#XA0;The interactive interpreter read-execute-write loop</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc9">4.2.3&#XA0;&#XA0;Consulting a Prolog program</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc10">4.2.4&#XA0;&#XA0;Scripting Prolog</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc11">4.2.5&#XA0;&#XA0;Interrupting a query</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc12">4.2.6&#XA0;&#XA0;The line editor</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc13">4.3&#XA0;&#XA0;Adjusting the size of Prolog stacks</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc14">4.4&#XA0;&#XA0;The GNU Prolog compiler</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc15">4.4.1&#XA0;&#XA0;Different kinds of codes</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc16">4.4.2&#XA0;&#XA0;Compilation scheme</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc17">4.4.3&#XA0;&#XA0;Using the compiler</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc18">4.4.4&#XA0;&#XA0;Running an executable</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc19">4.4.5&#XA0;&#XA0;Generating a new interactive interpreter</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc20">4.4.6&#XA0;&#XA0;The name mangling scheme</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc21">5&#XA0;&#XA0;Debugging</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc22">5.1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc23">5.2&#XA0;&#XA0;The procedure box model</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc24">5.3&#XA0;&#XA0;Debugging predicates</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc25">5.3.1&#XA0;&#XA0;Running and stopping the debugger</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc26">5.3.2&#XA0;&#XA0;Leashing ports</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc27">5.3.3&#XA0;&#XA0;Spy-points</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc28">5.4&#XA0;&#XA0;Debugging messages</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc29">5.5&#XA0;&#XA0;Debugger commands</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc30">5.6&#XA0;&#XA0;The WAM debugger</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc31">6&#XA0;&#XA0;Format of definitions</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc32">6.1&#XA0;&#XA0;General format</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc33">6.2&#XA0;&#XA0;Types and modes</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc34">6.3&#XA0;&#XA0;Errors</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc35">6.3.1&#XA0;&#XA0;General format and error context</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc36">6.3.2&#XA0;&#XA0;Instantiation error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc37">6.3.3&#XA0;&#XA0;Uninstantiation error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc38">6.3.4&#XA0;&#XA0;Type error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc39">6.3.5&#XA0;&#XA0;Domain error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc40">6.3.6&#XA0;&#XA0;Existence error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc41">6.3.7&#XA0;&#XA0;Permission error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc42">6.3.8&#XA0;&#XA0;Representation error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc43">6.3.9&#XA0;&#XA0;Evaluation error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc44">6.3.10&#XA0;&#XA0;Resource error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc45">6.3.11&#XA0;&#XA0;Syntax error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc46">6.3.12&#XA0;&#XA0;System error</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc47">7&#XA0;&#XA0;Prolog directives and control constructs</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc48">7.1&#XA0;&#XA0;Prolog directives</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc49">7.1.1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc50">7.1.2&#XA0;&#XA0;<TT>dynamic/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc51">7.1.3&#XA0;&#XA0;<TT>public/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc52">7.1.4&#XA0;&#XA0;<TT>multifile/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc53">7.1.5&#XA0;&#XA0;<TT>discontiguous/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc54">7.1.6&#XA0;&#XA0;<TT>ensure_linked/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc55">7.1.7&#XA0;&#XA0;<TT>built_in/0</TT>,
<TT>built_in/1</TT>,
<TT>built_in_fd/0</TT>,
<TT>built_in_fd/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc56">7.1.8&#XA0;&#XA0;<TT>include/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc57">7.1.9&#XA0;&#XA0;<TT>if/1</TT>, <TT>else/0</TT>, <TT>endif/0</TT>, <TT>elif/1</TT> </A>
</LI><LI CLASS="li-toc"><A HREF="#htoc58">7.1.10&#XA0;&#XA0;<TT>ensure_loaded/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc59">7.1.11&#XA0;&#XA0;<TT>op/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc60">7.1.12&#XA0;&#XA0;<TT>char_conversion/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc61">7.1.13&#XA0;&#XA0;<TT>set_prolog_flag/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc62">7.1.14&#XA0;&#XA0;<TT>initialization/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc63">7.1.15&#XA0;&#XA0;<TT>foreign/2</TT>,
<TT>foreign/1</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc64">7.2&#XA0;&#XA0;Prolog control constructs</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc65">7.2.1&#XA0;&#XA0;<TT>true/0</TT>,
<TT>fail/0</TT>,
<TT>!/0</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc66">7.2.2&#XA0;&#XA0;<TT>(&#X2019;,&#X2019;)/2</TT> - conjunction,
<TT>(;)/2</TT> - disjunction,
<TT>(-&gt;)/2</TT> - if-then,
<TT>(*-&gt;)/2</TT> - soft-cut (soft if-then)</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc67">7.2.3&#XA0;&#XA0;<TT>call/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc68">7.2.4&#XA0;&#XA0;<TT>catch/3</TT>,
<TT>throw/1</TT></A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc69">8&#XA0;&#XA0;Prolog built-in predicates</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc70">8.1&#XA0;&#XA0;Type testing</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc71">8.1.1&#XA0;&#XA0;<TT>var/1</TT>,
<TT>nonvar/1</TT>,
<TT>atom/1</TT>,
<TT>integer/1</TT>,
<TT>float/1</TT>,
<TT>number/1</TT>,
<TT>atomic/1</TT>,<BR>
 <TT>compound/1</TT>,
<TT>callable/1</TT>,
<TT>ground/1</TT>,
<TT>is_list/1</TT>,
<TT>list/1</TT>,
<TT>partial_list/1</TT>,
<TT>list_or_partial_list/1</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc72">8.2&#XA0;&#XA0;Term unification</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc73">8.2.1&#XA0;&#XA0;<TT>(=)/2</TT> - Prolog unification</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc74">8.2.2&#XA0;&#XA0;<TT>unify_with_occurs_check/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc75">8.2.3&#XA0;&#XA0;<TT>(\=)/2</TT> - not Prolog unifiable</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc76">8.3&#XA0;&#XA0;Term comparison</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc77">8.3.1&#XA0;&#XA0;Standard total ordering of terms</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc78">8.3.2&#XA0;&#XA0;<TT>(==)/2</TT> - term identical,
<TT>(\==)/2</TT> - term not identical,<BR>
 <TT>(@&lt;)/2</TT> - term less than,
<TT>(@=&lt;)/2</TT> - term less than or equal to,<BR>
 <TT>(@&gt;)/2</TT> - term greater than,
<TT>(@&gt;=)/2</TT> - term greater than or equal to</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc79">8.3.3&#XA0;&#XA0;<TT>compare/3</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc80">8.4&#XA0;&#XA0;Term processing</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc81">8.4.1&#XA0;&#XA0;<TT>functor/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc82">8.4.2&#XA0;&#XA0;<TT>arg/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc83">8.4.3&#XA0;&#XA0;<TT>(=..)/2</TT> - univ</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc84">8.4.4&#XA0;&#XA0;<TT>copy_term/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc85">8.4.5&#XA0;&#XA0;<TT>term_variables/2</TT>,
		<TT>term_variables/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc86">8.4.6&#XA0;&#XA0;<TT>subsumes_term/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc87">8.4.7&#XA0;&#XA0;<TT>acyclic_term/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc88">8.4.8&#XA0;&#XA0;<TT>setarg/4</TT>,
<TT>setarg/3</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc89">8.5&#XA0;&#XA0;Variable naming/numbering</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc90">8.5.1&#XA0;&#XA0;<TT>name_singleton_vars/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc91">8.5.2&#XA0;&#XA0;<TT>name_query_vars/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc92">8.5.3&#XA0;&#XA0;<TT>bind_variables/2</TT>,
<TT>numbervars/3</TT>,
<TT>numbervars/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc93">8.5.4&#XA0;&#XA0;<TT>term_ref/2</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc94">8.6&#XA0;&#XA0;Arithmetic</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc95">8.6.1&#XA0;&#XA0;Evaluation of an arithmetic expression</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc96">8.6.2&#XA0;&#XA0;<TT>(is)/2</TT> - evaluate expression</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc97">8.6.3&#XA0;&#XA0;<TT>(=:=)/2</TT> - arithmetic equal,
<TT>(=\=)/2</TT> - arithmetic not equal,<BR>
 <TT>(&lt;)/2</TT> - arithmetic less than,
<TT>(=&lt;)/2</TT> - arithmetic less than or equal to,<BR>
 <TT>(&gt;)/2</TT> - arithmetic greater than,
<TT>(&gt;=)/2</TT> - arithmetic greater than or equal to</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc98">8.6.4&#XA0;&#XA0;<TT>succ/2</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc99">8.7&#XA0;&#XA0;Dynamic clause management</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc100">8.7.1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc101">8.7.2&#XA0;&#XA0;<TT>asserta/1</TT>,
<TT>assertz/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc102">8.7.3&#XA0;&#XA0;<TT>retract/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc103">8.7.4&#XA0;&#XA0;<TT>retractall/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc104">8.7.5&#XA0;&#XA0;<TT>clause/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc105">8.7.6&#XA0;&#XA0;<TT>abolish/1</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc106">8.8&#XA0;&#XA0;Predicate information</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc107">8.8.1&#XA0;&#XA0;<TT>current_predicate/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc108">8.8.2&#XA0;&#XA0;<TT>predicate_property/2</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc109">8.9&#XA0;&#XA0;All solutions</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc110">8.9.1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc111">8.9.2&#XA0;&#XA0;<TT>findall/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc112">8.9.3&#XA0;&#XA0;<TT>bagof/3</TT>,
<TT>setof/3</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc113">8.10&#XA0;&#XA0;Streams</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc114">8.10.1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc115">8.10.2&#XA0;&#XA0;<TT>current_input/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc116">8.10.3&#XA0;&#XA0;<TT>current_output/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc117">8.10.4&#XA0;&#XA0;<TT>set_input/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc118">8.10.5&#XA0;&#XA0;<TT>set_output/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc119">8.10.6&#XA0;&#XA0;<TT>open/4</TT>,
<TT>open/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc120">8.10.7&#XA0;&#XA0;<TT>close/2</TT>,
<TT>close/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc121">8.10.8&#XA0;&#XA0;<TT>flush_output/1</TT>,
<TT>flush_output/0</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc122">8.10.9&#XA0;&#XA0;<TT>current_stream/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc123">8.10.10&#XA0;&#XA0;<TT>stream_property/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc124">8.10.11&#XA0;&#XA0;<TT>at_end_of_stream/1</TT>,
<TT>at_end_of_stream/0</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc125">8.10.12&#XA0;&#XA0;<TT>stream_position/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc126">8.10.13&#XA0;&#XA0;<TT>set_stream_position/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc127">8.10.14&#XA0;&#XA0;<TT>seek/4</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc128">8.10.15&#XA0;&#XA0;<TT>character_count/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc129">8.10.16&#XA0;&#XA0;<TT>line_count/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc130">8.10.17&#XA0;&#XA0;<TT>line_position/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc131">8.10.18&#XA0;&#XA0;<TT>stream_line_column/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc132">8.10.19&#XA0;&#XA0;<TT>set_stream_line_column/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc133">8.10.20&#XA0;&#XA0;<TT>add_stream_alias/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc134">8.10.21&#XA0;&#XA0;<TT>current_alias/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc135">8.10.22&#XA0;&#XA0;<TT>add_stream_mirror/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc136">8.10.23&#XA0;&#XA0;<TT>remove_stream_mirror/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc137">8.10.24&#XA0;&#XA0;<TT>current_mirror/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc138">8.10.25&#XA0;&#XA0;<TT>set_stream_type/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc139">8.10.26&#XA0;&#XA0;<TT>set_stream_eof_action/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc140">8.10.27&#XA0;&#XA0;<TT>set_stream_buffering/2</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc141">8.11&#XA0;&#XA0;Constant term streams</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc142">8.11.1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc143">8.11.2&#XA0;&#XA0;<TT>open_input_atom_stream/2</TT>,
<TT>open_input_chars_stream/2</TT>,<BR>
 <TT>open_input_codes_stream/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc144">8.11.3&#XA0;&#XA0;<TT>close_input_atom_stream/1</TT>,
<TT>close_input_chars_stream/1</TT>,<BR>
 <TT>close_input_codes_stream/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc145">8.11.4&#XA0;&#XA0;<TT>open_output_atom_stream/1</TT>,
<TT>open_output_chars_stream/1</TT>,<BR>
 <TT>open_output_codes_stream/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc146">8.11.5&#XA0;&#XA0;<TT>close_output_atom_stream/2</TT>,
<TT>close_output_chars_stream/2</TT>,<BR>
 <TT>close_output_codes_stream/2</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc147">8.12&#XA0;&#XA0;Character input/output</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc148">8.12.1&#XA0;&#XA0;<TT>get_char/2</TT>,
<TT>get_char/1</TT>,
<TT>get_code/1</TT>,
<TT>get_code/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc149">8.12.2&#XA0;&#XA0;<TT>get_key/2</TT>,
<TT>get_key/1</TT>
	 <TT>get_key_no_echo/2</TT>,
<TT>get_key_no_echo/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc150">8.12.3&#XA0;&#XA0;<TT>peek_char/2</TT>,
<TT>peek_char/1</TT>,
<TT>peek_code/1</TT>,
<TT>peek_code/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc151">8.12.4&#XA0;&#XA0;<TT>unget_char/2</TT>,
<TT>unget_char/1</TT>,
<TT>unget_code/2</TT>,
<TT>unget_code/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc152">8.12.5&#XA0;&#XA0;<TT>put_char/2</TT>,
<TT>put_char/1</TT>,
<TT>put_code/1</TT>,
<TT>put_code/2</TT>,
<TT>nl/1</TT>,
<TT>nl/0</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc153">8.13&#XA0;&#XA0;Byte input/output</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc154">8.13.1&#XA0;&#XA0;<TT>get_byte/2</TT>,
<TT>get_byte/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc155">8.13.2&#XA0;&#XA0;<TT>peek_byte/2</TT>,
<TT>peek_byte/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc156">8.13.3&#XA0;&#XA0;<TT>unget_byte/2</TT>,
<TT>unget_byte/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc157">8.13.4&#XA0;&#XA0;<TT>put_byte/2</TT>,
<TT>put_byte/1</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc158">8.14&#XA0;&#XA0;Term input/output</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc159">8.14.1&#XA0;&#XA0;<TT>read_term/3</TT>,
<TT>read_term/2</TT>,
<TT>read/2</TT>,
<TT>read/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc160">8.14.2&#XA0;&#XA0;<TT>read_atom/2</TT>,
<TT>read_atom/1</TT>,
<TT>read_integer/2</TT>,
<TT>read_integer/1</TT>,<BR>
 <TT>read_number/2</TT>,
<TT>read_number/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc161">8.14.3&#XA0;&#XA0;<TT>read_token/2</TT>,
<TT>read_token/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc162">8.14.4&#XA0;&#XA0;<TT>syntax_error_info/4</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc163">8.14.5&#XA0;&#XA0;<TT>last_read_start_line_column/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc164">8.14.6&#XA0;&#XA0;
<TT>write_term/3</TT>,
<TT>write_term/2</TT>,
<TT>write/2</TT>,
<TT>write/1</TT>,
<TT>writeq/2</TT>,
<TT>writeq/1</TT>,<BR>
 <TT>write_canonical/2</TT>,
<TT>write_canonical/1</TT>,
<TT>display/2</TT>,
<TT>display/1</TT>,
<TT>print/2</TT>,<BR>
 <TT>print/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc165">8.14.7&#XA0;&#XA0;<TT>format/3</TT>,
<TT>format/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc166">8.14.8&#XA0;&#XA0;<TT>portray_clause/2</TT>,
<TT>portray_clause/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc167">8.14.9&#XA0;&#XA0;<TT>get_print_stream/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc168">8.14.10&#XA0;&#XA0;<TT>op/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc169">8.14.11&#XA0;&#XA0;<TT>current_op/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc170">8.14.12&#XA0;&#XA0;<TT>char_conversion/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc171">8.14.13&#XA0;&#XA0;<TT>current_char_conversion/2</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc172">8.15&#XA0;&#XA0;Input/output from/to constant terms</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc173">8.15.1&#XA0;&#XA0;<TT>read_term_from_atom/3</TT>,
<TT>read_from_atom/2</TT>,
<TT>read_token_from_atom/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc174">8.15.2&#XA0;&#XA0;<TT>read_term_from_chars/3</TT>,
<TT>read_from_chars/2</TT>,
<TT>read_token_from_chars/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc175">8.15.3&#XA0;&#XA0;<TT>read_term_from_codes/3</TT>,
<TT>read_from_codes/2</TT>,
<TT>read_token_from_codes/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc176">8.15.4&#XA0;&#XA0;<TT>write_term_to_atom/3</TT>,
<TT>write_to_atom/2</TT>,
<TT>writeq_to_atom/2</TT>,<BR>
 <TT>write_canonical_to_atom/2</TT>,
<TT>display_to_atom/2</TT>,
<TT>print_to_atom/2</TT>,<BR>
 <TT>format_to_atom/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc177">8.15.5&#XA0;&#XA0;<TT>write_term_to_chars/3</TT>,
<TT>write_to_chars/2</TT>,
<TT>writeq_to_chars/2</TT>,<BR>
 <TT>write_canonical_to_chars/2</TT>,
<TT>display_to_chars/2</TT>,
<TT>print_to_chars/2</TT>,<BR>
 <TT>format_to_chars/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc178">8.15.6&#XA0;&#XA0;<TT>write_term_to_codes/3</TT>,
<TT>write_to_codes/2</TT>,
<TT>writeq_to_codes/2</TT>,<BR>
 <TT>write_canonical_to_codes/2</TT>,
<TT>display_to_codes/2</TT>,
<TT>print_to_codes/2</TT>,<BR>
 <TT>format_to_codes/3</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc179">8.16&#XA0;&#XA0;DEC-10 compatibility input/output</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc180">8.16.1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc181">8.16.2&#XA0;&#XA0;<TT>see/1</TT>,
<TT>tell/1</TT>,
<TT>append/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc182">8.16.3&#XA0;&#XA0;<TT>seeing/1</TT>,
<TT>telling/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc183">8.16.4&#XA0;&#XA0;<TT>seen/0</TT>,
<TT>told/0</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc184">8.16.5&#XA0;&#XA0;<TT>get0/1</TT>,
<TT>get/1</TT>,
<TT>skip/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc185">8.16.6&#XA0;&#XA0;<TT>put/1</TT>,
<TT>tab/1</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc186">8.17&#XA0;&#XA0;Term expansion</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc187">8.17.1&#XA0;&#XA0;Definite clause grammars</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc188">8.17.2&#XA0;&#XA0;<TT>expand_term/2</TT>,
<TT>term_expansion/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc189">8.17.3&#XA0;&#XA0;<TT>phrase/3</TT>,
<TT>phrase/2</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc190">8.18&#XA0;&#XA0;Logic, control and exceptions</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc191">8.18.1&#XA0;&#XA0;<TT>abort/0</TT>,
<TT>stop/0</TT>,
<TT>top_level/0</TT>,
<TT>break/0</TT>,
<TT>halt/1</TT>,
<TT>halt/0</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc192">8.18.2&#XA0;&#XA0;<TT>false/0</TT>, <TT>once/1</TT>, <TT>(\+)/1</TT> - not provable,
<TT>call/2-11</TT>,
	 <TT>call_with_args/1-11</TT>, <TT>call_det/2</TT>, <TT>forall/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc193">8.18.3&#XA0;&#XA0;<TT>repeat/0</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc194">8.18.4&#XA0;&#XA0;<TT>between/3</TT>, <TT>for/3</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc195">8.19&#XA0;&#XA0;Atomic term processing</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc196">8.19.1&#XA0;&#XA0;<TT>atom_length/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc197">8.19.2&#XA0;&#XA0;<TT>atom_concat/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc198">8.19.3&#XA0;&#XA0;<TT>sub_atom/5</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc199">8.19.4&#XA0;&#XA0;<TT>char_code/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc200">8.19.5&#XA0;&#XA0;<TT>lower_upper/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc201">8.19.6&#XA0;&#XA0;<TT>atom_chars/2</TT>,
<TT>atom_codes/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc202">8.19.7&#XA0;&#XA0;<TT>number_atom/2</TT>,
<TT>number_chars/2</TT>,
<TT>number_codes/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc203">8.19.8&#XA0;&#XA0;<TT>name/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc204">8.19.9&#XA0;&#XA0;<TT>atom_hash/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc205">8.19.10&#XA0;&#XA0;<TT>new_atom/3</TT>,
<TT>new_atom/2</TT>,
<TT>new_atom/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc206">8.19.11&#XA0;&#XA0;<TT>current_atom/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc207">8.19.12&#XA0;&#XA0;<TT>atom_property/2</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc208">8.20&#XA0;&#XA0;List processing</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc209">8.20.1&#XA0;&#XA0;<TT>append/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc210">8.20.2&#XA0;&#XA0;<TT>member/2</TT>,
<TT>memberchk/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc211">8.20.3&#XA0;&#XA0;<TT>reverse/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc212">8.20.4&#XA0;&#XA0;<TT>delete/3</TT>,
<TT>select/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc213">8.20.5&#XA0;&#XA0;<TT>permutation/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc214">8.20.6&#XA0;&#XA0;<TT>prefix/2</TT>,
<TT>suffix/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc215">8.20.7&#XA0;&#XA0;<TT>sublist/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc216">8.20.8&#XA0;&#XA0;<TT>last/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc217">8.20.9&#XA0;&#XA0;<TT>length/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc218">8.20.10&#XA0;&#XA0;<TT>nth/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc219">8.20.11&#XA0;&#XA0;<TT>max_list/2</TT>,
<TT>min_list/2</TT>,
<TT>sum_list/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc220">8.20.12&#XA0;&#XA0;<TT>maplist/2-8</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc221">8.20.13&#XA0;&#XA0;<TT>sort/2</TT>,
<TT>msort/2</TT>,
<TT>keysort/2</TT>
<TT>sort/1</TT>,
<TT>msort/1</TT>,
<TT>keysort/1</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc222">8.21&#XA0;&#XA0;Global variables</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc223">8.21.1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc224">8.21.2&#XA0;&#XA0;<TT>g_assign/2</TT>,
<TT>g_assignb/2</TT>,
<TT>g_link/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc225">8.21.3&#XA0;&#XA0;<TT>g_read/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc226">8.21.4&#XA0;&#XA0;<TT>g_array_size/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc227">8.21.5&#XA0;&#XA0;<TT>g_inc/3</TT>,
<TT>g_inc/2</TT>,
<TT>g_inco/2</TT>,
<TT>g_inc/1</TT>,
<TT>g_dec/3</TT>,
<TT>g_dec/2</TT>,
<TT>g_deco/2</TT>,
<TT>g_dec/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc228">8.21.6&#XA0;&#XA0;<TT>g_set_bit/2</TT>,
<TT>g_reset_bit/2</TT>,
<TT>g_test_set_bit/2</TT>,
<TT>g_test_reset_bit/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc229">8.21.7&#XA0;&#XA0;Examples</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc230">8.22&#XA0;&#XA0;Prolog state</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc231">8.22.1&#XA0;&#XA0;<TT>set_prolog_flag/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc232">8.22.2&#XA0;&#XA0;<TT>current_prolog_flag/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc233">8.22.3&#XA0;&#XA0;<TT>set_bip_name/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc234">8.22.4&#XA0;&#XA0;<TT>current_bip_name/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc235">8.22.5&#XA0;&#XA0;<TT>write_pl_state_file/1</TT>,
<TT>read_pl_state_file/1</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc236">8.23&#XA0;&#XA0;Program state</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc237">8.23.1&#XA0;&#XA0;<TT>consult/1</TT>,
<TT>&#X2019;.&#X2019;/2</TT> - program consult</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc238">8.23.2&#XA0;&#XA0;<TT>load/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc239">8.23.3&#XA0;&#XA0;<TT>listing/1</TT>,
<TT>listing/0</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc240">8.24&#XA0;&#XA0;System statistics</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc241">8.24.1&#XA0;&#XA0;<TT>statistics/0</TT>,
<TT>statistics/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc242">8.24.2&#XA0;&#XA0;<TT>user_time/1</TT>,
<TT>system_time/1</TT>,
<TT>cpu_time/1</TT>,
<TT>real_time/1</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc243">8.25&#XA0;&#XA0;Random number generator</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc244">8.25.1&#XA0;&#XA0;<TT>set_seed/1</TT>,
<TT>randomize/0</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc245">8.25.2&#XA0;&#XA0;<TT>get_seed/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc246">8.25.3&#XA0;&#XA0;<TT>random/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc247">8.25.4&#XA0;&#XA0;<TT>random/3</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc248">8.26&#XA0;&#XA0;File name processing</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc249">8.26.1&#XA0;&#XA0;<TT>absolute_file_name/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc250">8.26.2&#XA0;&#XA0;<TT>decompose_file_name/4</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc251">8.26.3&#XA0;&#XA0;<TT>prolog_file_name/2</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc252">8.27&#XA0;&#XA0;Operating system interface</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc253">8.27.1&#XA0;&#XA0;<TT>argument_counter/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc254">8.27.2&#XA0;&#XA0;<TT>argument_value/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc255">8.27.3&#XA0;&#XA0;<TT>argument_list/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc256">8.27.4&#XA0;&#XA0;<TT>environ/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc257">8.27.5&#XA0;&#XA0;<TT>make_directory/1</TT>,
<TT>delete_directory/1</TT>,
<TT>change_directory/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc258">8.27.6&#XA0;&#XA0;<TT>working_directory/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc259">8.27.7&#XA0;&#XA0;<TT>directory_files/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc260">8.27.8&#XA0;&#XA0;<TT>rename_file/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc261">8.27.9&#XA0;&#XA0;<TT>delete_file/1</TT>,
<TT>unlink/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc262">8.27.10&#XA0;&#XA0;<TT>file_permission/2</TT>,
<TT>file_exists/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc263">8.27.11&#XA0;&#XA0;<TT>file_property/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc264">8.27.12&#XA0;&#XA0;<TT>temporary_name/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc265">8.27.13&#XA0;&#XA0;<TT>temporary_file/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc266">8.27.14&#XA0;&#XA0;<TT>date_time/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc267">8.27.15&#XA0;&#XA0;<TT>host_name/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc268">8.27.16&#XA0;&#XA0;<TT>os_version/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc269">8.27.17&#XA0;&#XA0;<TT>architecture/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc270">8.27.18&#XA0;&#XA0;<TT>shell/2</TT>,
<TT>shell/1</TT>,
<TT>shell/0</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc271">8.27.19&#XA0;&#XA0;<TT>system/2</TT>,
<TT>system/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc272">8.27.20&#XA0;&#XA0;<TT>spawn/3</TT>,
<TT>spawn/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc273">8.27.21&#XA0;&#XA0;<TT>popen/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc274">8.27.22&#XA0;&#XA0;<TT>exec/5</TT>,
<TT>exec/4</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc275">8.27.23&#XA0;&#XA0;<TT>fork_prolog/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc276">8.27.24&#XA0;&#XA0;<TT>create_pipe/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc277">8.27.25&#XA0;&#XA0;<TT>wait/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc278">8.27.26&#XA0;&#XA0;<TT>prolog_pid/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc279">8.27.27&#XA0;&#XA0;<TT>send_signal/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc280">8.27.28&#XA0;&#XA0;<TT>sleep/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc281">8.27.29&#XA0;&#XA0;<TT>select/5</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc282">8.28&#XA0;&#XA0;Sockets input/output</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc283">8.28.1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc284">8.28.2&#XA0;&#XA0;<TT>socket/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc285">8.28.3&#XA0;&#XA0;<TT>socket_close/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc286">8.28.4&#XA0;&#XA0;<TT>socket_bind/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc287">8.28.5&#XA0;&#XA0;<TT>socket_connect/4</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc288">8.28.6&#XA0;&#XA0;<TT>socket_listen/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc289">8.28.7&#XA0;&#XA0;<TT>socket_accept/4</TT>,
<TT>socket_accept/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc290">8.28.8&#XA0;&#XA0;<TT>hostname_address/2</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc291">8.29&#XA0;&#XA0;Linedit management</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc292">8.29.1&#XA0;&#XA0;<TT>get_linedit_prompt/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc293">8.29.2&#XA0;&#XA0;<TT>set_linedit_prompt/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc294">8.29.3&#XA0;&#XA0;<TT>add_linedit_completion/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc295">8.29.4&#XA0;&#XA0;<TT>find_linedit_completion/2</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc296">8.30&#XA0;&#XA0;Source reader facility</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc297">8.30.1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc298">8.30.2&#XA0;&#XA0;<TT>sr_open/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc299">8.30.3&#XA0;&#XA0;<TT>sr_change_options/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc300">8.30.4&#XA0;&#XA0;<TT>sr_close/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc301">8.30.5&#XA0;&#XA0;<TT>sr_read_term/4</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc302">8.30.6&#XA0;&#XA0;<TT>sr_current_descriptor/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc303">8.30.7&#XA0;&#XA0;<TT>sr_get_stream/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc304">8.30.8&#XA0;&#XA0;<TT>sr_get_module/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc305">8.30.9&#XA0;&#XA0;<TT>sr_get_file_name/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc306">8.30.10&#XA0;&#XA0;<TT>sr_get_position/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc307">8.30.11&#XA0;&#XA0;<TT>sr_get_include_list/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc308">8.30.12&#XA0;&#XA0;<TT>sr_get_include_stream_list/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc309">8.30.13&#XA0;&#XA0;<TT>sr_get_size_counters/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc310">8.30.14&#XA0;&#XA0;<TT>sr_get_error_counters/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc311">8.30.15&#XA0;&#XA0;<TT>sr_set_error_counters/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc312">8.30.16&#XA0;&#XA0;<TT>sr_error_from_exception/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc313">8.30.17&#XA0;&#XA0;<TT>sr_write_message/8</TT>,
<TT>sr_write_message/6</TT>,
<TT>sr_write_message/4</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc314">8.30.18&#XA0;&#XA0;<TT>sr_write_error/6</TT>,
<TT>sr_write_error/4</TT>,
<TT>sr_write_error/2</TT></A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc315">9&#XA0;&#XA0;Finite domain solver and built-in predicates</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc316">9.1&#XA0;&#XA0;Introduction</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc317">9.1.1&#XA0;&#XA0;Finite Domain variables</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc318">9.2&#XA0;&#XA0;FD variable parameters</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc319">9.2.1&#XA0;&#XA0;<TT>fd_max_integer/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc320">9.2.2&#XA0;&#XA0;<TT>fd_vector_max/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc321">9.2.3&#XA0;&#XA0;<TT>fd_set_vector_max/1</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc322">9.3&#XA0;&#XA0;Initial value constraints</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc323">9.3.1&#XA0;&#XA0;<TT>fd_domain/3</TT>,
<TT>fd_domain_bool/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc324">9.3.2&#XA0;&#XA0;<TT>fd_domain/2</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc325">9.4&#XA0;&#XA0;Type testing</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc326">9.4.1&#XA0;&#XA0;<TT>fd_var/1</TT>, <TT>non_fd_var/1</TT>,
<TT>generic_var/1</TT>,
<TT>non_generic_var/1</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc327">9.5&#XA0;&#XA0;FD variable information</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc328">9.5.1&#XA0;&#XA0;<TT>fd_min/2</TT>,
<TT>fd_max/2</TT>,
<TT>fd_size/2</TT>,
<TT>fd_dom/2</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc329">9.5.2&#XA0;&#XA0;<TT>fd_has_extra_cstr/1</TT>,
<TT>fd_has_vector/1</TT>,
<TT>fd_use_vector/1</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc330">9.6&#XA0;&#XA0;Arithmetic constraints</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc331">9.6.1&#XA0;&#XA0;FD arithmetic expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc332">9.6.2&#XA0;&#XA0;Partial AC: <TT>(#=)/2</TT> - constraint equal,
<TT>(#\=)/2</TT> - constraint not equal,<BR>
 <TT>(#&lt;)/2</TT> - constraint less than,
<TT>(#=&lt;)/2</TT> - constraint less than or equal,<BR>
 <TT>(#&gt;)/2</TT> - constraint greater than,
<TT>(#&gt;=)/2</TT> - constraint greater than or equal</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc333">9.6.3&#XA0;&#XA0;Full AC: <TT>(#=#)/2</TT> - constraint equal,
<TT>(#\=#)/2</TT> - constraint not equal,<BR>
 <TT>(#&lt;#)/2</TT> - constraint less than,
<TT>(#=&lt;#)/2</TT> - constraint less than or equal,<BR>
 <TT>(#&gt;#)/2</TT> - constraint greater than,
<TT>(#&gt;=#)/2</TT> - constraint greater than or equal</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc334">9.6.4&#XA0;&#XA0;<TT>fd_prime/1</TT>,
<TT>fd_not_prime/1</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc335">9.7&#XA0;&#XA0;Boolean and reified constraints</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc336">9.7.1&#XA0;&#XA0;Boolean FD expressions</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc337">9.7.2&#XA0;&#XA0;<TT>fd_reified_in/4</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc338">9.7.3&#XA0;&#XA0;<TT>(#\)/1</TT> - constraint NOT,
<TT>(#&lt;=&gt;)/2</TT> - constraint equivalent,<BR>
 <TT>(#\&lt;=&gt;)/2</TT> - constraint different,
<TT>(##)/2</TT> - constraint XOR,<BR>
 <TT>(#==&gt;)/2</TT> - constraint imply,
<TT>(#\==&gt;)/2</TT> - constraint not imply,<BR>
 <TT>(#/\)/2</TT> - constraint AND,
<TT>(#\/\)/2</TT> - constraint NAND,<BR>
 <TT>(#\/)/2</TT> - constraint OR,
<TT>(#\\/)/2</TT> - constraint NOR</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc339">9.7.4&#XA0;&#XA0;<TT>fd_cardinality/2</TT>,
<TT>fd_cardinality/3</TT>,
<TT>fd_at_least_one/1</TT>,
<TT>fd_at_most_one/1</TT>,<BR>
 <TT>fd_only_one/1</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc340">9.8&#XA0;&#XA0;Symbolic constraints</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc341">9.8.1&#XA0;&#XA0;<TT>fd_all_different/1</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc342">9.8.2&#XA0;&#XA0;<TT>fd_element/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc343">9.8.3&#XA0;&#XA0;<TT>fd_element_var/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc344">9.8.4&#XA0;&#XA0;<TT>fd_atmost/3</TT>,
<TT>fd_atleast/3</TT>,
<TT>fd_exactly/3</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc345">9.8.5&#XA0;&#XA0;<TT>fd_relation/2</TT>,
<TT>fd_relationc/2</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc346">9.9&#XA0;&#XA0;Labeling constraints</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc347">9.9.1&#XA0;&#XA0;<TT>fd_labeling/2</TT>,
<TT>fd_labeling/1</TT>,
<TT>fd_labelingff/1</TT></A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc348">9.10&#XA0;&#XA0;Optimization constraints</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc349">9.10.1&#XA0;&#XA0;<TT>fd_minimize/2</TT>,
<TT>fd_maximize/2</TT></A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc350">10&#XA0;&#XA0;Interfacing Prolog and C</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc351">10.1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc352">10.2&#XA0;&#XA0;Including and using <TT>gprolog.h</TT></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc353">10.3&#XA0;&#XA0;Calling C from Prolog</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc354">10.3.1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc355">10.3.2&#XA0;&#XA0;<TT>foreign/2</TT> directive</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc356">10.3.3&#XA0;&#XA0;The C function</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc357">10.3.4&#XA0;&#XA0;Input arguments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc358">10.3.5&#XA0;&#XA0;Output arguments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc359">10.3.6&#XA0;&#XA0;Input/output arguments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc360">10.3.7&#XA0;&#XA0;Writing non-deterministic C code</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc361">10.3.8&#XA0;&#XA0;Example: input and output arguments</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc362">10.3.9&#XA0;&#XA0;Example: non-deterministic code</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc363">10.3.10&#XA0;&#XA0;Example: input/output arguments</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc364">10.4&#XA0;&#XA0;Manipulating Prolog terms</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc365">10.4.1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc366">10.4.2&#XA0;&#XA0;Managing Prolog atoms</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc367">10.4.3&#XA0;&#XA0;Reading Prolog terms</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc368">10.4.4&#XA0;&#XA0;Unifying Prolog terms</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc369">10.4.5&#XA0;&#XA0;Creating Prolog terms</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc370">10.4.6&#XA0;&#XA0;Testing the type of Prolog terms</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc371">10.4.7&#XA0;&#XA0;Comparing Prolog terms</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc372">10.4.8&#XA0;&#XA0;Term processing</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc373">10.4.9&#XA0;&#XA0;Comparing and evaluating arithmetic expressions</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc374">10.5&#XA0;&#XA0;Raising Prolog errors</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc375">10.5.1&#XA0;&#XA0;Managing the error context</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc376">10.5.2&#XA0;&#XA0;Instantiation error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc377">10.5.3&#XA0;&#XA0;Uninstantiation error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc378">10.5.4&#XA0;&#XA0;Type error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc379">10.5.5&#XA0;&#XA0;Domain error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc380">10.5.6&#XA0;&#XA0;Existence error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc381">10.5.7&#XA0;&#XA0;Permission error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc382">10.5.8&#XA0;&#XA0;Representation error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc383">10.5.9&#XA0;&#XA0;Evaluation error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc384">10.5.10&#XA0;&#XA0;Resource error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc385">10.5.11&#XA0;&#XA0;Syntax error</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc386">10.5.12&#XA0;&#XA0;System error</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc387">10.6&#XA0;&#XA0;Calling Prolog from C</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc388">10.6.1&#XA0;&#XA0;Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc389">10.6.2&#XA0;&#XA0;Example: <TT>my_call/1</TT> - a <TT>call/1</TT> clone</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc390">10.6.3&#XA0;&#XA0;Example: recovering the list of all operators</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc391">10.7&#XA0;&#XA0;Defining a new C <TT>main()</TT> function</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc392">10.7.1&#XA0;&#XA0;Example: asking for ancestors</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#@biblio">References</A>
</LI><LI CLASS="li-toc"><A HREF="#@index">Index</A>
</LI></UL><!--TOC section Acknowledgements-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc1">1</A>&#XA0;&#XA0;Acknowledgements</H2><!--SEC END --><P>I would like to thank the <A HREF="http://panoramix.univ-paris1.fr/CRINFO/">department of computing science</A> at the university of Paris 1 for allowing
me the time and freedom necessary to achieve this project.</P><P>I am grateful to the members of the <A HREF="http://loco.inria.fr/">Loco
project</A> at <A HREF="http://www.inria.fr/Unites/ROCQUENCOURT-eng.html">INRIA Rocquencourt</A> for their encouragement. Their involvement in this work
led to useful feedback and exchange.</P><P>I would particularly like to thank
<A HREF="http://www.sju.edu/~jhodgson">Jonathan Hodgson</A> for the time and
effort he put into the proofreading of this manual. His suggestions, both
regarding ISO technical aspects as well as the language in which it was
expressed, proved invaluable.</P><P>The on-line HTML version of this document was created using
<A HREF="http://pauillac.inria.fr/~maranget/hevea/">H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</A> developed by
Luc Maranget who kindly devoted so much
of his time extending the capabilities of H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A in order to handle such a
sizeable manual.</P><P>Jean-Christophe Aude kindly improved the visual aspect of both the
illustrations and the GNU Prolog web pages.</P><P>Thanks to Richard A. O&#X2019;Keefe for his advice regarding the implementation of
some Prolog built-in predicates and for suggesting me the in-place
installation feature.</P><P>Many thanks to the following contributors:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><A HREF="mailto:ax@apax.net">Alexander Diemand</A> for his initial port to
alpha/linux.</LI><LI CLASS="li-itemize"><A HREF="mailto:clive@laluna.demon.co.uk">Clive Cox</A> and
<A HREF="http://www.rano.org/">Edmund Grimley Evans</A> for their port to
ix86/SCO.</LI><LI CLASS="li-itemize"><A HREF="mailto:nollinge@ens-lyon.fr">Nicolas Ollinger</A> to for his port to
ix86/FreeBSD.</LI><LI CLASS="li-itemize"><A HREF="mailto:brook@nmsu.edu">Brook Milligan</A> for his port to
ix86/NetBSD and for general configuration improvements.</LI><LI CLASS="li-itemize"><A HREF="http://www.speech.sri.com/people/stolcke/">Andreas Stolcke</A> for
his port to ix86/Solaris.</LI><LI CLASS="li-itemize"><A HREF="mailto:spratt@alum.mit.edu">Lindsey Spratt</A> for his port to
powerpc/Darwin (MacOS X).</LI><LI CLASS="li-itemize"><A HREF="mailto:gbeauchesne@mandrakesoft.com">Gwenol&#XE9; Beauchesne</A> for his port to
x86_64/Linux.</LI><LI CLASS="li-itemize"><A HREF="mailto:jtb@netbsd.org">Jason Beegan</A> for his port to
sparc/NetBSD and to powerpc/NetBSD.</LI><LI CLASS="li-itemize"><A HREF="mailto:csrabak@ig.com.br">Cesar Rabak</A> for his initial port to
ix86/MinGW.</LI><LI CLASS="li-itemize"><A HREF="mailto:Scott@coral8.com">Scott L. Burson</A> for his port to x86_64/Solaris.</LI><LI CLASS="li-itemize"><A HREF="mailto:dholland@netbsd.org">David Holland</A> for his port to x86_64/BSD systems.</LI><LI CLASS="li-itemize"><A HREF="mailto:jasper@simulistics.com">Jasper Taylor</A> for his port to x86_64/MinGW64.</LI><LI CLASS="li-itemize"><A HREF="mailto:gclient.gaap@gmail.com">Ozaki Kiichi</A> for his port to x86_64/Darwin (Mac OS X).</LI></UL><P>Many thanks to Paulo Moura for his continuous help (in particular about
Darwin ports) and for including GNU Prolog in his
<A HREF="http://logtalk.org">logtalk</A> system.</P><P>Many thanks to all those people at <A HREF="http://www.gnu.org">GNU</A> who helped
me to finalize the GNU Prolog project.</P><P>Finally, I would like to thank everybody who tested preliminary releases and
helped me to put the finishing touches to this system.</P><!--TOC section GNU Prolog License Conditions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">2</A>&#XA0;&#XA0;GNU Prolog License Conditions</H2><!--SEC END --><P>GNU Prolog is free software. Since version 1.4.0, GNU Prolog distributed under
a dual license: LGPL <I>or</I> GPL. So, you can redistribute it and/or
modify it under the terms of either:</P><DL CLASS="description"><DT CLASS="dt-description"></DT><DD CLASS="dd-description"> &#X2013; the GNU Lesser General Public License (LGPL) as published by the Free
Software Foundation; either version 3 of the License, or (at your
option) any later version. </DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"> <B>or</B> </DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"> &#X2013; the GNU General Public License (GPL) as published by the Free
Software Foundation; either version 2 of the License, or (at your option)
any later version.</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"> <B>or</B> both in parallel (as here). 
</DD></DL><P>GNU Prolog is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.</P><P>You should have received copies of the GNU General Public License and
the GNU Lesser General Public License along with this program. If
not, see <A HREF="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</A>.</P><P>Remark: versions of GNU Prolog prior to 1.4.0 were entirely released under
the GNU General Public License (GPL).</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc3">3</A>&#XA0;&#XA0;Introduction</H2><!--SEC END --><P>GNU Prolog [<A HREF="#gnu-prolog">5</A>] is a free Prolog compiler with constraint
solving over finite domains developed by
<A HREF="http://cri-dist.univ-paris1.fr/diaz/">Daniel Diaz</A>. For recent
information about GNU Prolog please consult
<A HREF="http://www.gprolog.org">the GNU Prolog page</A>.</P><P> GNU Prolog is a Prolog compiler
based on the Warren Abstract Machine (WAM) [<A HREF="#Warren83">9</A>, <A HREF="#Ait-Kaci91">1</A>].
It first compiles a Prolog program to a WAM file which is then translated to
a low-level machine independent language called mini-assembly
specifically designed for GNU Prolog. The resulting file is then translated
to the assembly language of the target machine (from which an object is
obtained). This allows GNU Prolog to produce a native stand alone executable
from a Prolog source (similarly to what does a C compiler from a C program).
The main advantage of this compilation scheme is to produce native code and
to be fast. Another interesting feature is that executables are small.
Indeed, the code of most unused built-in predicates is not included in the
executables at link-time.</P><P>A lot of work has been devoted to the ISO compatibility. Indeed, GNU Prolog
is very close to the ISO standard for Prolog&#XA0;[<A HREF="#iso-part1">6</A>].</P><P>GNU Prolog also offers various extensions very useful in practice (global
variables, OS interface, sockets,...). In particular, GNU Prolog contains an
efficient constraint solver over Finite Domains (FD). This opens constraint
logic programming to the user combining the power of constraint programming to
the declarativity of logic programming. The key feature of the GNU Prolog
solver is the use of a single (low-level) primitive to define all
(high-level) FD constraints. There are many advantages of this approach:
constraints can be compiled, the user can define his own constraints (in
terms of the primitive), the solver is open and extensible (as opposed to
black-box solvers like CHIP),&#X2026;Moreover, the GNU Prolog solver is rather
efficient, often more than commercial solvers.</P><P>GNU Prolog is inspired from two systems developed by the same author:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>wamcc</TT>: a Prolog to C compiler [<A HREF="#wamcc">3</A>]. the key point of <TT>wamcc</TT> was its
ability to produce stand alone executables using an original compilation
scheme: the translation of Prolog to C via the WAM. Its drawback was the time
needed by <TT>gcc</TT> to compile the produced sources. GNU Prolog can also
produce stand alone executables but using a faster compilation scheme.</LI><LI CLASS="li-itemize"><TT>clp(FD)</TT>: a constraint programming language over FD
[<A HREF="#long-clp-fd">4</A>]. Its key feature was the use of a
single primitive to define FD constraints. GNU Prolog is based on the same
idea but offers an extended constraint definition language. In comparison to
<TT>clp(FD)</TT>, GNU Prolog offers new predefined constraints, new
predefined heuristics, reified constraints,&#X2026;</LI></UL><P>Here are some features of GNU Prolog:</P><UL CLASS="itemize"><LI CLASS="li-itemize">Prolog system:<UL CLASS="itemize"><LI CLASS="li-itemize">conforms to the ISO standard for Prolog (floating point numbers,
streams, dynamic code,&#X2026;).</LI><LI CLASS="li-itemize">a lot of extensions: global variables, definite clause grammars (DCG),
sockets interface, operating system interface,&#X2026;</LI><LI CLASS="li-itemize">more than 300 Prolog built-in predicates.</LI><LI CLASS="li-itemize">Prolog debugger and a low-level WAM debugger.</LI><LI CLASS="li-itemize">line editing facility under the interactive interpreter with
completion on atoms.</LI><LI CLASS="li-itemize">powerful bidirectional interface between Prolog and C.</LI></UL></LI><LI CLASS="li-itemize">Compiler:<UL CLASS="itemize"><LI CLASS="li-itemize">native-code compiler producing stand alone executables.</LI><LI CLASS="li-itemize">simple command-line compiler accepting a wide variety of files:
Prolog files, C files, WAM files,&#X2026;</LI><LI CLASS="li-itemize">direct generation of assembly code 15 times faster than
<TT>wamcc</TT> + <TT>gcc</TT>.</LI><LI CLASS="li-itemize">most of unused built-in predicates are not linked (to reduce the size
of the executables).</LI><LI CLASS="li-itemize">compiled predicates (native-code) as fast as <TT>wamcc</TT> on average.</LI><LI CLASS="li-itemize">consulted predicates (byte-code) 5 times faster than <TT>wamcc</TT>.</LI></UL></LI><LI CLASS="li-itemize">Constraint solver:<UL CLASS="itemize"><LI CLASS="li-itemize">FD variables well integrated into the Prolog environment (full
compatibility with Prolog variables and integers). No need for
explicit FD declarations.</LI><LI CLASS="li-itemize">very efficient FD solver (comparable to commercial solvers).</LI><LI CLASS="li-itemize">high-level constraints can be described in terms of simple primitives.</LI><LI CLASS="li-itemize">a lot of predefined constraints: arithmetic constraints, boolean
constraints, symbolic constraints, reified constraints,&#X2026;</LI><LI CLASS="li-itemize">several predefined enumeration heuristics.</LI><LI CLASS="li-itemize">the user can define his own new constraints.</LI><LI CLASS="li-itemize">more than 50 FD built-in constraints/predicates.</LI></UL></LI></UL><!--TOC section Using GNU Prolog-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc4">4</A>&#XA0;&#XA0;Using GNU Prolog</H2><!--SEC END --><!--CUT DEF subsection 1 --><!--TOC subsection Introduction-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc5">4.1</A>&#XA0;&#XA0;Introduction</H3><!--SEC END --><P>
<A NAME="Introduction:(Using-GNU-Prolog)"></A>
GNU Prolog offers two ways to execute a Prolog program:</P><UL CLASS="itemize"><LI CLASS="li-itemize">interpreting it using the GNU Prolog interactive interpreter.</LI><LI CLASS="li-itemize">compiling it to a (machine-dependent) executable using the GNU Prolog
native-code compiler.</LI></UL><P>Running a program under the interactive interpreter allows the user to
list it and to make full use of the debugger on it (section&#XA0;<A HREF="#Debugging">5</A>).
Compiling a program to native code makes it possible to obtain a stand alone
executable, with a reduced size and optimized for speed. Running a Prolog
program compiled to native-code is around 3-5 times faster than running it
under the interpreter. However, it is not possible to make full use of
the debugger on a program compiled to native-code. Nor is it possible to list
the program. In general, it is preferable to run a program under the
interpreter for debugging and then use the native-code compiler to produce an
autonomous executable. It is also possible to combine these two modes by
producing an executable that contains some parts of the program (e.g.
already debugged predicates whose execution-time speed is crucial) and
interpreting the other parts under this executable. In that case, the
executable has the same facilities as the GNU Prolog interpreter but also
integrates the native-code predicates. This way to define a new enriched
interpreter is detailed later (section&#XA0;<A HREF="#Generating-a-new-interactive-interpreter">4.4.5</A>).</P><!--TOC subsection The GNU Prolog interactive interpreter-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc6">4.2</A>&#XA0;&#XA0;The GNU Prolog interactive interpreter</H3><!--SEC END --><P>
<A NAME="The-GNU-Prolog-interactive-interpreter"></A></P><!--TOC subsubsection Starting/exiting the interactive interpreter-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc7">4.2.1</A>&#XA0;&#XA0;Starting/exiting the interactive interpreter</H4><!--SEC END --><P>

GNU Prolog offers a classical Prolog interactive interpreter also called
<EM>top-level</EM>. It allows the user to execute queries, to consult Prolog
programs, to list them, to execute them and to debug them. The
top-level can be invoked using the following command:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><TT>% gprolog </TT>[<I><TT>OPTION</TT></I>]&#X2026;</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(the <TT>%</TT> symbol is the operating system shell prompt)</TD></TR>
</TABLE></DD></DL><P><B>Options</B>:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>--init-goal</TT> <I><TT>GOAL</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>execute <I><TT>GOAL</TT></I> before entering the top-level</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>--consult-file</TT> <I><TT>FILE</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>consult <I><TT>FILE</TT></I> inside the top-level</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>--entry-goal</TT> <I><TT>GOAL</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>execute <I><TT>GOAL</TT></I> inside the top-level</TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>--query-goal</TT> <I><TT>GOAL</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>execute <I><TT>GOAL</TT></I> as a query for the top-level</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--help</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>print a help and exit</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--version</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>print version number and exit</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>do not parse the rest of the command-line</TD></TR>
</TABLE><P>The main role of the <TT>gprolog</TT> command is to execute the top-level
itself, i.e. to execute the built-in predicate
<TT>top_level/0</TT> (section&#XA0;<A HREF="#abort/0">8.18.1</A>) which will produce something like:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
</TT><PRE CLASS="verbatim"><TT>GNU Prolog 1.4.0
By Daniel Diaz
Copyright (C) 1999-2012 Daniel Diaz
| ?-
</TT></PRE></DD></DL><P>The top-level is ready to execute your queries as explained in the next
section.</P><P>To quit the top-level type the end-of-file key sequence (<TT>Ctl-D</TT>) or
its term representation: <TT>end_of_file.</TT> It is also possible to use
the built-in predicate <TT>halt/0</TT> (section&#XA0;<A HREF="#abort/0">8.18.1</A>).</P><P>However, before entering the top-level itself, the command-line is processed
to treat all known options (those listed above). All unrecognized arguments
are collected together to form the argument list which will be available
using
<TT>argument_value/2</TT> (section&#XA0;<A HREF="#argument-value/2">8.27.2</A>) or
<TT>argument_list/1</TT> (section&#XA0;<A HREF="#argument-list/1">8.27.3</A>).
The <TT>--</TT> option stops the parsing of the command-line, all remainding
options are collected into the argument list.</P><P>Several options are provided to execute a goal before entering the
interaction with the user:</P><UL CLASS="itemize"><LI CLASS="li-itemize">The <TT>--init-goal</TT> option executes the <I><TT>GOAL</TT></I> as soon as
it is encountered (while the command-line is processed). <I><TT>GOAL</TT></I> is thus
executed before entering <TT>top_level/0</TT>.</LI><LI CLASS="li-itemize">The <TT>--consult-file</TT> option consults the <I><TT>FILE</TT></I> at the
entry of <TT>top_level/0</TT> just after the banner is displayed. 
<TT>--consult-file</TT> options are handled before <TT>--consult-file</TT> options.</LI><LI CLASS="li-itemize">The <TT>--entry-goal</TT> option executes the <I><TT>GOAL</TT></I> at the
entry of <TT>top_level/0</TT> just after the banner is displayed.</LI><LI CLASS="li-itemize">The <TT>--query-goal</TT> option executes the <I><TT>GOAL</TT></I> as if the
user has typed in (under the top-level).</LI></UL><P>The above order is thus the order in which each kind of goal (init, entry,
query) is executed. If there are several goals of a same kind they are
executed in the order of appearance. Thus, all init goals are executed (in the
order of appearance) before all entry goals and all entry goals are executed
before all query goals.</P><P>Each <I><TT>GOAL</TT></I> is passed as a shell argument (i.e. one shell string) and
should not contain a terminal dot. Example:
<TT>--init-goal &#X2019;write(hello), nl&#X2019;</TT> under a sh-like.
To be executed, a <I><TT>GOAL</TT></I> is transformed into a term using
<TT>read_term_from_atom(Goal, Term, [end_of_term(eof)])</TT>. Respecting both
the syntax of shell strings and of Prolog can be heavy. For
instance, passing a backslash character <TT>\</TT> can be difficult
since it introduces an escape sequence both in sh and inside Prolog
quoted atoms. The use of back quotes can then be useful since, by default, no
escape sequence is processed inside back quotes (this behavior can be
controlled using the <TT>back_quotes</TT> Prolog flag (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)).</P><P>Since the Prolog argument list is created when the whole command-line is
parsed, if a <TT>--init-goal</TT> option uses <TT>argument_value/2</TT> or
<TT>argument_list/1</TT> it will obtained the original command-line
arguments (i.e. including all recognized arguments).</P><P>Here is an example of using execution goal options:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
% gprolog --init-goal &#X2019;write(before), nl&#X2019; --entry-goal &#X2019;write(inside), nl&#X2019;<BR>
--query-goal &#X2019;append([a,b],[c,d],X)&#X2019;
</TT></DD></DL><P>will produce the following:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
</TT><PRE CLASS="verbatim"><TT>before
GNU Prolog 1.4.0
By Daniel Diaz
Copyright (C) 1999-2012 Daniel Diaz
inside
| ?- append([a,b],[c,d],X).

X = [a,b,c,d]

yes
| ?-
</TT></PRE></DD></DL><P>NB: depending on the used shell it may be necessary to use other string
delimiters (e.g. use <TT>"</TT> under Windows <TT>cmd.exe</TT>).</P><!--TOC subsubsection The interactive interpreter read-execute-write loop-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc8">4.2.2</A>&#XA0;&#XA0;The interactive interpreter read-execute-write loop</H4><!--SEC END --><P>
The GNU Prolog top-level is built on a classical read-execute-write loop that
also allows for re-executions (when the query is not deterministic) as
follows:</P><UL CLASS="itemize"><LI CLASS="li-itemize">display the prompt, i.e. &#X2019;<TT>| ?-</TT>&#X2019;.</LI><LI CLASS="li-itemize">read a query (i.e. a goal).</LI><LI CLASS="li-itemize">execute the query.</LI><LI CLASS="li-itemize">in case of success display the values of the variables of the query.</LI><LI CLASS="li-itemize">if there are remaining alternatives (i.e. the query is not
deterministic), display a <TT>?</TT> and ask the user who can use one of the
following commands: <TT>RETURN</TT> to stop the execution, <TT>;</TT> to
compute the next solution or <TT>a</TT> to compute all remaining solution.</LI></UL><P>Here is an example of execution of a query (&#X201C;find the lists <TT>X</TT> and
<TT>Y</TT> such that the concatenation of <TT>X</TT> and <TT>Y</TT> is
<TT>[a,b]</TT>&#X201D;):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- append(X,Y,[a,b,c]).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>X = []</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>Y = [a,b,c] ? ;</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user presses <TT>;</TT> to compute another
solution)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>X = [a]</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>Y = [b,c] ? a</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user presses <TT>a</TT> to compute all remaining
solutions)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>X = [a,b]</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>Y = [c]</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user is not asked and the next solution is
computed)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>X = [a,b,c]</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>Y = []</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user is not asked and the next solution is
computed)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>no</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(no more solution)</TD></TR>
</TABLE></DD></DL><P>In some cases the top-level can detect that the current solution is the last
one (no more alternatives remaining). In such a case it does not display the
<TT>?</TT> symbol (and does not ask the user). Example:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- (X=1 ; X=2).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>X = 1 ? ;</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user presses <TT>;</TT> to compute another solution)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>X = 2</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user is not prompted since there are no more
alternatives)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>yes</TT></TD></TR>
</TABLE></DD></DL><P>The user can stop the execution even if there are more alternatives by
typing <TT>RETURN</TT>.</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- (X=1 ; X=2).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>X = 1 ?</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user presses <TT>RETURN</TT> to stop the execution)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>yes</TT></TD></TR>
</TABLE></DD></DL><P>The top-level tries to display the values of the variables of the query in a
readable manner. For instance, when a variable is bound to a query variable,
the name of this variable appears. When a variable is a singleton an
underscore symbol <TT>_</TT> is displayed (<TT>_</TT> is a generic name
for a singleton variable, it is also called an anonymous variable). Other
variables are bound to new brand variable names. When a query variable name
<TT>X</TT> appears as the value of another query variable <TT>Y</TT> it is
because <TT>X</TT> is itself not instantiated otherwise the value of
<TT>X</TT> is displayed. In such a case, nothing is output for <TT>X</TT>
itself (since it is a variable). Example:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- X=f(A,B,_,A), A=k.</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>A = k</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(the value of <TT>A</TT> is displayed also in <TT>f/3</TT> for
<TT>X</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>X = f(k,B,_,k)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(since <TT>B</TT> is a variable which is also a part
of <TT>X</TT>, <TT>B</TT> is not displayed)</TD></TR>
</TABLE></DD></DL><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- functor(T,f,3), arg(1,T,X), arg(3,T,X).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>T = f(X,_,X)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(the 1<I><SUP>st</SUP></I> and 3<I><SUP>rd</SUP></I> args are equal to <TT>X</TT>,
the 2<I><SUP>nd</SUP></I> is an anonymous variable)</TD></TR>
</TABLE></DD></DL><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- read_from_atom(&#X2019;k(X,Y,X).&#X2019;,T).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>T = k(A,_,A)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(the 1<I><SUP>st</SUP></I> and 3<I><SUP>rd</SUP></I> args are unified, a new
variable name <TT>A</TT> is introduced)</TD></TR>
</TABLE></DD></DL><P>The top-level uses variable binding predicates (section&#XA0;<A HREF="#Variable-naming/numbering">8.5</A>). To display the value of a variable, the top-level calls
<TT>write_term/3</TT> with the following option list:
<TT>[quoted(true),numbervars(false),
namevars(true)]</TT> (section&#XA0;<A HREF="#write-term/3">8.14.6</A>). A term of the
form <TT>&#X2019;$VARNAME&#X2019;(Name)</TT> where <TT>Name</TT> is an atom is displayed
as a variable name while a term of the form <TT>&#X2019;$VAR&#X2019;(N)</TT> where
<TT>N</TT> is an integer is displayed as a normal compound term (such a term
could be output as a variable name by <TT>write_term/3</TT>). Example:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- X=&#X2019;$VARNAME&#X2019;(&#X2019;Y&#X2019;), Y=&#X2019;$VAR&#X2019;(1).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>X = Y</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(the term <TT>&#X2019;$VARNAME&#X2019;(&#X2019;Y&#X2019;)</TT> is displayed as <TT>Y</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>Y = &#X2019;$VAR&#X2019;(1)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(the term <TT>&#X2019;$VAR&#X2019;(1)</TT> is displayed as is)</TD></TR>
</TABLE></DD></DL><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- X=Y, Y=&#X2019;$VAR&#X2019;(1).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>X = &#X2019;$VAR&#X2019;(1)</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>Y = &#X2019;$VAR&#X2019;(1)</TT></TD></TR>
</TABLE></DD></DL><P>In the first example, <TT>X</TT> is explicitly bound to
<TT>&#X2019;$VARNAME&#X2019;(&#X2019;Y&#X2019;)</TT> by the query so the top-level displays <TT>Y</TT>
as the value of <TT>X</TT>. <TT>Y</TT> is unified with <TT>&#X2019;$VAR&#X2019;(1)</TT> so
the top-level displays it as a normal compound term. It should be clear that
<TT>X</TT> is not bound to <TT>Y</TT> (whereas it is in the second
query). This behavior should be kept in mind when doing variable binding
operations.</P><P>Finally, the top-level computes the user-time (section&#XA0;<A HREF="#user-time/1">8.24.2</A>) taken
by a query and displays it when it is significant. Example:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- retractall(p(_)), assertz(p(0)),</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;repeat,</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;retract(p(X)),</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;Y is X + 1,</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;assertz(p(Y)),</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;X = 1000, !.</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>X = 1000</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>Y = 1001</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>(180 ms) yes</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(the query took 180ms of user time)</TD></TR>
</TABLE></DD></DL><!--TOC subsubsection Consulting a Prolog program-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc9">4.2.3</A>&#XA0;&#XA0;Consulting a Prolog program</H4><!--SEC END --><P>
<A NAME="Consulting-a-Prolog-program"></A>
The top-level allows the user to consult Prolog source files. Consulted
predicates can be listed, executed and debugged (while predicates compiled
to native-code cannot). For more information about the difference between a
native-code predicate and a consulted predicate refer to the introduction of
this section (section&#XA0;<A HREF="#Introduction:(Using-GNU-Prolog)">4.1</A>) and to the part devoted
to the compiler (section&#XA0;<A HREF="#Different-kinds-of-codes">4.4.1</A>).</P><P>To consult a program use the built-in predicate <TT>consult/1</TT>
(section&#XA0;<A HREF="#consult/1">8.23.1</A>). The argument of this predicate is a Prolog file name or
<TT>user</TT> to specify the terminal. This allows the user to directly input
the predicates from the terminal. In that case the input shall be terminated
by the end-of-file key sequence (<TT>Ctl-D</TT>) or its term representation:
<TT>end_of_file.</TT> A shorthand for
<TT>consult(<I>FILE</I>)</TT> is
<TT>[<I>FILE</I>]</TT>. Example:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- [user].</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>{compiling user for byte code...}</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>even(0).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>even(s(s(X))):-</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;even(X).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user presses <TT>Ctl-D</TT> to end the input)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>{user compiled, 3 lines read - 350 bytes written, 1180 ms}</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- even(X).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>X = 0 ? ;</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user presses <TT>;</TT> to compute another solution)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>X = s(s(0)) ? ;</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user presses <TT>;</TT> to compute another
solution)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>X = s(s(s(s(0)))) ?</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user presses <TT>RETURN</TT> to stop the
execution)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>yes</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- listing.</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>even(0).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>even(s(s(A))) :-</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;even(A).</TT></TD></TR>
</TABLE></DD></DL><P>When <TT>consult/1</TT> (section&#XA0;<A HREF="#consult/1">8.23.1</A>) is invoked on a Prolog file it
first runs the GNU Prolog compiler (section&#XA0;<A HREF="#The-GNU-Prolog-compiler">4.4</A>) as a child
process to generate a temporary WAM file for byte-code. If the compilation
fails a message is displayed and nothing is loaded. If the compilation
succeeds, the produced file is loaded into memory using <TT>load/1</TT>
(section&#XA0;<A HREF="#load/1">8.23.2</A>). Namely, the byte-code of each predicate is loaded. When a
predicate <I><TT>P</TT></I> is loaded if there is a previous definition
for <I><TT>P</TT></I> it is removed (i.e. all clauses defining
<I><TT>P</TT></I> are erased). We say that <I><TT>P</TT></I> is
redefined. Note that only consulted predicates can be redefined. If
<I><TT>P</TT></I> is a native-code predicate, trying to redefine it will
produce an error at load-time: the predicate redefinition will be ignored
and the following message displayed:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>native code procedure <I>P</I> cannot be redefined</TT></DD></DL><P>Finally, an existing predicate will not be removed if it is not re-loaded.
This means that if a predicate <I><TT>P</TT></I> is loaded when consulting
the file <I><TT>F</TT></I>, and if later the definition of
<I><TT>P</TT></I> is removed from the file <I><TT>F</TT></I>, consulting
<I><TT>F</TT></I> again will not remove the previously loaded definition
of <I><TT>P</TT></I> from the memory.</P><P>Consulted predicates can be debugged using the Prolog debugger. Use the
debugger predicate <TT>trace/0</TT> or <TT>debug/0</TT> (section&#XA0;<A HREF="#Running-and-stopping-the-debugger">5.3.1</A>) to activate the debugger.</P><!--TOC subsubsection Scripting Prolog-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc10">4.2.4</A>&#XA0;&#XA0;Scripting Prolog</H4><!--SEC END --><P>
<A NAME="Scripting-Prolog"></A>
Since version 1.4.0 it is possible to use a Prolog source file as a Unix
script-file (shebang support). A PrologScript file should begin as follows:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
</TT><PRE CLASS="verbatim"><TT>#!/usr/bin/gprolog --consult-file
</TT></PRE></DD></DL><P>GNU Prolog will be invoked as</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
</TT><PRE CLASS="verbatim"><TT>/usr/bin/gprolog --consult-file FILE
</TT></PRE></DD></DL><P>Then <TT>FILE</TT> will be consulted. In order to correctly deal with the
<TT>#!</TT> first line, <TT>consult/1</TT> treats as a comment a first line
of a file which begins with <TT>#</TT> (if you want to use a predicate name
starting with a <TT>#</TT>, simply skip a line before its definition).</P><P>Remark: it is almost never possible to pass additionnal parameters
(e.g. <TT>query-goal</TT>) this way since in most systems 
the shebang implementation deliver all arguments (following
<TT>#!/usr/bin/gprolog</TT>) as a single string (which cannot then correctly
be recognized by <TT>gprolog</TT>).</P><!--TOC subsubsection Interrupting a query-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc11">4.2.5</A>&#XA0;&#XA0;Interrupting a query</H4><!--SEC END --><P>
<A NAME="Interrupting-a-query"></A>
Under the top-level it is possible to interrupt the execution of a query by
typing the interruption key (<TT>Ctl-C</TT>). This can be used to abort a
query, to stop an infinite loop, to activate the debugger,&#X2026;When an
interruption occurs the top-level displays the following message:
<TT>Prolog interruption (h for help)&#XA0;?</TT> The user can then type one of
the following commands:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP>
Command</TD><TD ALIGN=center NOWRAP>Name</TD><TD ALIGN=left NOWRAP>Description</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>a</TT></TD><TD ALIGN=center NOWRAP>abort</TD><TD ALIGN=left NOWRAP>abort the current execution. Same as <TT>abort/0</TT>
(section&#XA0;<A HREF="#abort/0">8.18.1</A>)</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>e</TT></TD><TD ALIGN=center NOWRAP>exit</TD><TD ALIGN=left NOWRAP>quit the current Prolog process.
Same as <TT>halt/0</TT> (section&#XA0;<A HREF="#abort/0">8.18.1</A>)</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>b</TT></TD><TD ALIGN=center NOWRAP>break</TD><TD ALIGN=left NOWRAP>invoke a recursive top-level. Same as <TT>break/0</TT>
(section&#XA0;<A HREF="#abort/0">8.18.1</A>)</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>c</TT></TD><TD ALIGN=center NOWRAP>continue</TD><TD ALIGN=left NOWRAP>resume the execution</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>t</TT></TD><TD ALIGN=center NOWRAP>trace</TD><TD ALIGN=left NOWRAP>start the debugger using <TT>trace/0</TT>
(section&#XA0;<A HREF="#Running-and-stopping-the-debugger">5.3.1</A>)</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>d</TT></TD><TD ALIGN=center NOWRAP>debug</TD><TD ALIGN=left NOWRAP>start the debugger using <TT>debug/0</TT>
(section&#XA0;<A HREF="#Running-and-stopping-the-debugger">5.3.1</A>)</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>h</TT> or <TT>?</TT></TD><TD ALIGN=center NOWRAP>help</TD><TD ALIGN=left NOWRAP>display a summary of available commands</TD></TR>
</TABLE><!--TOC subsubsection The line editor-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc12">4.2.6</A>&#XA0;&#XA0;The line editor</H4><!--SEC END --><P>
<A NAME="The-line-editor"></A>
The line editor (<TT>linedit</TT>) allows the user to build/update the current
input line using a variety of commands. This facility is available if the
<TT>linedit</TT> part of GNU Prolog has been installed. <TT>linedit</TT> is
implicitly called by any built-in predicate reading from a terminal (e.g.
<TT>get_char/1</TT>, <TT>read/1</TT>,&#X2026;). This is the case when the
top-level reads a query.</P><P><B>Bindings</B>: each command of <TT>linedit</TT> is activated using a
key. For some commands another key is also available to invoke the command
(on some terminals this other key may not work properly while the primary
key always works). Here is the list of available commands:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP>
Key</TD><TD ALIGN=center NOWRAP>Alternate key</TD><TD ALIGN=left NOWRAP>Description</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-B</TT></TD><TD ALIGN=center NOWRAP><TT>&#X2190;</TT></TD><TD ALIGN=left NOWRAP>go to the previous character</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-F</TT></TD><TD ALIGN=center NOWRAP><TT>&#X2192;</TT></TD><TD ALIGN=left NOWRAP>go to the next character</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Esc-B</TT></TD><TD ALIGN=center NOWRAP><TT>Ctl-&#X2190;</TT></TD><TD ALIGN=left NOWRAP>go to the previous word</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Esc-F</TT></TD><TD ALIGN=center NOWRAP><TT>Ctl-&#X2192;</TT></TD><TD ALIGN=left NOWRAP>go to the next word</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-A</TT></TD><TD ALIGN=center NOWRAP><TT>Home</TT></TD><TD ALIGN=left NOWRAP>go to the beginning of the line</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-E</TT></TD><TD ALIGN=center NOWRAP><TT>End</TT></TD><TD ALIGN=left NOWRAP>go to the end of the line</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-H</TT></TD><TD ALIGN=center NOWRAP><TT>Backspace</TT></TD><TD ALIGN=left NOWRAP>delete the previous character</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-D</TT></TD><TD ALIGN=center NOWRAP><TT>Delete</TT></TD><TD ALIGN=left NOWRAP>delete the current character</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-U</TT></TD><TD ALIGN=center NOWRAP><TT>Ctl-Home</TT></TD><TD ALIGN=left NOWRAP>delete from beginning of the line to the current character</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-K</TT></TD><TD ALIGN=center NOWRAP><TT>Ctl-End</TT></TD><TD ALIGN=left NOWRAP>delete from the current character to the end of the line</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Esc-L</TT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>lower case the next word</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Esc-U</TT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>upper case the next word</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Esc-C</TT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>capitalize the next word</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-T</TT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>exchange last two characters</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-V</TT></TD><TD ALIGN=center NOWRAP><TT>Insert</TT></TD><TD ALIGN=left NOWRAP>switch on/off the insert/replace mode</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-I</TT></TD><TD ALIGN=center NOWRAP><TT>Tab</TT></TD><TD ALIGN=left NOWRAP>complete word (twice displays all possible
completions)</TD></TR>
<TR><TD ALIGN=center NOWRAP><TT>Esc-Ctl-I</TT></TD><TD ALIGN=center NOWRAP><TT>Esc-Tab</TT></TD><TD ALIGN=left NOWRAP>insert spaces to emulate a tabulation</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-space</TT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>mark beginning of the selection</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Esc-W</TT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>copy (from the begin selection mark to the current
character)</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-W</TT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>cut (from the begin selection mark to the current
character)</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-Y</TT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>paste</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-P</TT></TD><TD ALIGN=center NOWRAP><TT>&#X2191;</TT></TD><TD ALIGN=left NOWRAP>recall previous history line</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-N</TT></TD><TD ALIGN=center NOWRAP><TT>&#X2193;</TT></TD><TD ALIGN=left NOWRAP>recall next history line</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Esc-P</TT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>recall previous history line beginning with the current
prefix</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Esc-N</TT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>recall next history line beginning with the current
prefix</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Esc-&lt;</TT></TD><TD ALIGN=center NOWRAP><TT>Page Up</TT></TD><TD ALIGN=left NOWRAP>recall first history line</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Esc-&gt;</TT></TD><TD ALIGN=center NOWRAP><TT>Page Down</TT></TD><TD ALIGN=left NOWRAP>recall last history line</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-C</TT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>generate an interrupt signal (section&#XA0;<A HREF="#Interrupting-a-query">4.2.5</A>)</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Ctl-D</TT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>generate an end-of-file character (at the begin of the
line)</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>RETURN</TT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>validate a line</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>Esc-?</TT></TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>display a summary of available commands</TD></TR>
</TABLE><P><B>History</B>: when a line is entered (i.e. terminated by <TT>RETURN</TT>),
<TT>linedit</TT> records it in an internal list called
history. It is later possible to recall history lines using appropriate
commands (e.g. <TT>Ctl-P</TT> recall the last entered line) and to modify
them as needed. It is also possible to recall a history line beginning with
a given prefix. For instance to recall the previous line beginning with
<TT>write</TT> simply type <TT>write</TT> followed by <TT>Esc-P</TT>.
Another <TT>Esc-P</TT> will recall an earlier line beginning with
<TT>write</TT>,&#X2026;</P><P><B>Completion</B>: another important feature of <TT>linedit</TT> is its
completion facility. Indeed, <TT>linedit</TT> maintains a list of
known words and uses it to complete the prefix of a word. Initially this list
contains all predefined atoms and the atoms corresponding to available
predicates. This list is dynamically updated when a new atom appears in the
system (whether read at the top-level, created with a built-in predicate,
associated with a new consulted predicate,&#X2026;). When the completion key
(<TT>Tab</TT>) is pressed <TT>linedit</TT> acts as follows:</P><UL CLASS="itemize"><LI CLASS="li-itemize">use the current word as a prefix.</LI><LI CLASS="li-itemize">collect all words of the list that begin with this prefix.</LI><LI CLASS="li-itemize">complete the current word with the longest common part of all matching
words.</LI><LI CLASS="li-itemize">if more than one word matches emit a beep (a second <TT>Tab</TT> will
display all possibilities).</LI></UL><P>Example:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><TT>| ?- argu</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user presses <TT>Tab</TT> to complete the word)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>| ?- argument_</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(<TT>linedit</TT> completes <TT>argu</TT> with
<TT>argument_</TT> and emits a beep)</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(the user presses again <TT>Tab</TT> to see all possible completions)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>argument_counter</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(<TT>linedit</TT> shows 3 possible completions)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>argument_list</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>argument_value</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>| ?- argument_</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(<TT>linedit</TT> redisplays the input line)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>| ?- argument_c</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(to select <TT>argument_counter</TT> the user presses
<TT>c</TT> and <TT>Tab</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>| ?- argument_counter</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(<TT>linedit</TT> completes with
<TT>argument_counter</TT>)</TD></TR>
</TABLE></DD></DL><P><B>Balancing</B>: <TT>linedit</TT> allows the user to check that (square/curly)
brackets are well balanced. For this, when a close bracket symbol, i.e.
<TT>)</TT>, <TT>]</TT> or <TT>}</TT>, is typed, <TT>linedit</TT> determines
the associated open bracket, i.e. <TT>(</TT>, <TT>[</TT> or <TT>{</TT>, and
temporarily repositions the cursor on it to show the match.</P><P><B>Customization</B>: the behavior of <TT>linedit</TT> can be controlled via an environment variable called <TT>LINEDIT</TT>. This variable can contain the following substrings:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP>
<TT>ansi=no</TT></TD><TD ALIGN=left NOWRAP>do not use ANSI escape sequence (unix only)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>out=</TT><I>N</I></TD><TD ALIGN=left NOWRAP>use the file descriptor <I>N</I> for the output (unix only)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>gui=no</TT></TD><TD ALIGN=left NOWRAP>even if compiled with the GUI console run in text mode (windows)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>cp=</TT><I>N</I></TD><TD ALIGN=left NOWRAP>use code page <I>N</I> (windows text console)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>oem_put=no</TT></TD><TD ALIGN=left NOWRAP>do not use Char&#X2192;Oem conversion when emitting a char (windows text console)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>oem_get=no</TT></TD><TD ALIGN=left NOWRAP>do not use Oem&#X2192;Char conversion when reading a char (windows text console)</TD></TR>
</TABLE><!--TOC subsection Adjusting the size of Prolog stacks-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc13">4.3</A>&#XA0;&#XA0;Adjusting the size of Prolog stacks</H3><!--SEC END --><P>
<A NAME="Adjusting-the-size-of-Prolog-stacks"></A>
GNU Prolog uses several stacks to execute a Prolog program. Each stack has a
static size and cannot be dynamically increased during the execution. For
each stack there is a default size but the user can define a new size by
setting an environment variable. When a GNU Prolog program is run it first
consults these variables and if they are not defined uses the default sizes.
The following table presents each stack of GNU Prolog with its default size
and the name of its associated environment variable:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP>
Stack</TD><TD ALIGN=center NOWRAP>Default</TD><TD ALIGN=center NOWRAP>Environment</TD><TD ALIGN=left NOWRAP>Description</TD></TR>
<TR><TD ALIGN=center NOWRAP>name</TD><TD ALIGN=center NOWRAP>size (Kb)</TD><TD ALIGN=center NOWRAP>variable</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>local</TT></TD><TD ALIGN=center NOWRAP>16384</TD><TD ALIGN=center NOWRAP><TT>LOCALSZ</TT></TD><TD ALIGN=left NOWRAP>control stack (environments
and choice-points)</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>global</TT></TD><TD ALIGN=center NOWRAP>32768</TD><TD ALIGN=center NOWRAP><TT>GLOBALSZ</TT></TD><TD ALIGN=left NOWRAP>heap (compound terms)</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>trail</TT></TD><TD ALIGN=center NOWRAP>16384</TD><TD ALIGN=center NOWRAP><TT>TRAILSZ</TT></TD><TD ALIGN=left NOWRAP>conditional bindings (bindings
to undo at backtracking)</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>cstr</TT></TD><TD ALIGN=center NOWRAP>16384</TD><TD ALIGN=center NOWRAP><TT>CSTRSZ</TT></TD><TD ALIGN=left NOWRAP>finite domain constraint stack
(FD variables and constraints)</TD></TR>
</TABLE><P>In addition, under Windows (since version 1.4.0), registry keys are consulted
(key names are the same as environment names). The keys are stored in
<TT>HKEY_CURRENT_USER\Software\GnuProlog\</TT>.</P><P>If the size of a stack is too small an overflow will occur during the
execution. In that case GNU Prolog emits the following error message before
stopping:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT><I>S</I> stack overflow (size:&#XA0;<I>N</I> Kb, environment variable used:&#XA0;<I>E</I>)</TT></DD></DL><P>where <I><TT>S</TT></I> is the name of the stack, <I><TT>N</TT></I> is
the current stack size in Kb and <I><TT>E</TT></I> the name of the
associated environment variable. When such a message occurs it is possible
to (re)define the variable <I><TT>E</TT></I> with the new size. For
instance to allocate Kb to the local stack under a Unix shell use:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><TT>LOCALSZ=32768; export LOCALSZ</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(under <TT>sh</TT> or <TT>bash</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>setenv LOCALSZ 32768</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(under <TT>csh</TT> or <TT>tcsh</TT>)</TD></TR>
</TABLE></DD></DL><P>This method allows the user to adjust the size of Prolog stacks. However, in
some cases it is preferable not to allow the user to modify these sizes. For
instance, when providing a stand alone executable whose behavior should be
independent of the environment in which it is run. In that case the program
should not consult environment variables and the programmer should be able
to define new default stack sizes. The GNU Prolog compiler offers this
facilities via several command-line options such as <TT>--local-size</TT> or
<TT>--fixed-sizes</TT> (section&#XA0;<A HREF="#Using-the-compiler">4.4.3</A>).</P><P>Finally note that GNU Prolog stacks are virtually allocated (i.e. use virtual
memory). This means that a physical memory page is allocated only when needed
(i.e. when an attempt to read/write it occurs). Thus it is possible to define
very large stacks. At the execution, only the needed amount of space will be
physically allocated.</P><!--TOC subsection The GNU Prolog compiler-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc14">4.4</A>&#XA0;&#XA0;The GNU Prolog compiler</H3><!--SEC END --><P>
<A NAME="The-GNU-Prolog-compiler"></A></P><!--TOC subsubsection Different kinds of codes-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc15">4.4.1</A>&#XA0;&#XA0;Different kinds of codes</H4><!--SEC END --><P>
<A NAME="Different-kinds-of-codes"></A>
One of the main advantages of GNU Prolog is its ability to produce stand
alone executables. A Prolog program can be compiled to native code to give
rise to a machine-dependent executable using the GNU Prolog compiler. However
native-code predicates cannot be listed nor fully debugged. So there is an
alternative to native-code compilation: byte-code compilation. By default the
GNU Prolog compiler produces native-code but via a command-line option it can
produce a file ready for byte-code loading. This is exactly what
<TT>consult/1</TT> does as was explained above (section&#XA0;<A HREF="#Consulting-a-Prolog-program">4.2.3</A>). GNU Prolog also manages interpreted code using a Prolog interpreter
written in Prolog. Obviously interpreted code is slower than byte-code but
does not require the invocation of the GNU Prolog compiler. This interpreter is
used each time a meta-call is needed as by <TT>call/1</TT> (section&#XA0;<A HREF="#call/1">7.2.3</A>).
This also the case of dynamically asserted clauses. The following table
summarizes these three kinds of codes:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP>
Type</TD><TD ALIGN=left NOWRAP>Speed</TD><TD ALIGN=center NOWRAP>Debug ?</TD><TD ALIGN=left NOWRAP>For what</TD></TR>
<TR><TD ALIGN=left NOWRAP>
interpreted-code</TD><TD ALIGN=left NOWRAP>slow</TD><TD ALIGN=center NOWRAP>yes</TD><TD ALIGN=left NOWRAP>meta-call and dynamically asserted clauses</TD></TR>
<TR><TD ALIGN=left NOWRAP>
byte-code</TD><TD ALIGN=left NOWRAP>medium</TD><TD ALIGN=center NOWRAP>yes</TD><TD ALIGN=left NOWRAP>consulted predicates</TD></TR>
<TR><TD ALIGN=left NOWRAP>
native-code</TD><TD ALIGN=left NOWRAP>fast</TD><TD ALIGN=center NOWRAP>no</TD><TD ALIGN=left NOWRAP>compiled predicates</TD></TR>
</TABLE><!--TOC subsubsection Compilation scheme-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc16">4.4.2</A>&#XA0;&#XA0;Compilation scheme</H4><!--SEC END --><P>
<A NAME="Compilation-scheme"></A>
<B>Native-code compilation</B>: a Prolog source is compiled in several
stages to produce an object file that is linked to the GNU Prolog libraries
to produce an executable. The Prolog source is first compiled to obtain a
WAM [<A HREF="#Warren83">9</A>] file. For a detailed study of the WAM the
interested reader can refer to
<A HREF="http://www.isg.sfu.ca/~hak/documents/wam.html">&#X201C;Warren&#X2019;s Abstract
Machine: A Tutorial Reconstruction&#X201D;</A> [<A HREF="#Ait-Kaci91">1</A>]. The WAM file is
translated to a machine-independent language specifically designed for GNU
Prolog. This language is close to a (universal) assembly language and is
based on a very reduced instruction set. For this reason this language is
called mini-assembly (MA). The mini-assembly file is then
mapped to the assembly language of the target machine. This assembly file is
assembled to give rise to an object file which is then linked with the GNU
Prolog libraries to provide an executable. The compiler also takes into
account Finite Domain constraint definition files. It translates them to C
and invoke the C compiler to obtain object files. The following figure
presents this compilation scheme:</P><DIV CLASS="center"><IMG SRC="compil-scheme.gif"></DIV><P>Obviously all intermediate stages are hidden to the user who simply invokes
the compiler on his Prolog file(s) (plus other files: C,&#X2026;) and
obtains an executable. However, it is also possible to stop the compiler at
any given stage. This can be useful, for instance, to see the WAM code
produced (perhaps when learning the WAM). Finally it is possible to give any
kind of file to the compiler which will insert it in the compilation chain
at the stage corresponding to its type. The type of a file is determined
using the suffix of its file name. The following table presents all
recognized types/suffixes:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP>
Suffix of the file</TD><TD ALIGN=left NOWRAP>Type of the file</TD><TD ALIGN=left NOWRAP>Handled by:</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>.pl</TT>, <TT>.pro</TT></TD><TD ALIGN=left NOWRAP>Prolog source file</TD><TD ALIGN=left NOWRAP><TT>pl2wam</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>.wam</TT></TD><TD ALIGN=left NOWRAP>WAM source file</TD><TD ALIGN=left NOWRAP><TT>wam2ma</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>.ma</TT></TD><TD ALIGN=left NOWRAP>Mini-assembly source file</TD><TD ALIGN=left NOWRAP><TT>ma2asm</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>.s</TT></TD><TD ALIGN=left NOWRAP>Assembly source file</TD><TD ALIGN=left NOWRAP>the assembler</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>.c</TT>, <TT>.C</TT>, <TT>.CC</TT>, <TT>.cc</TT>, <TT>.cxx</TT>,
<TT>.c++</TT>, <TT>.cpp</TT></TD><TD ALIGN=left NOWRAP>C or C++ source file</TD><TD ALIGN=left NOWRAP>the C compiler</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>.fd</TT></TD><TD ALIGN=left NOWRAP>Finite Domain constraint source file</TD><TD ALIGN=left NOWRAP><TT>fd2c</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
any other suffix (<TT>.o</TT>, <TT>.a</TT>,&#X2026;)</TD><TD ALIGN=left NOWRAP>any other type
(object, library,&#X2026;)</TD><TD ALIGN=left NOWRAP>the linker (C linker)</TD></TR>
</TABLE><P><B>Byte-code compilation</B>: the same compiler can be used to compile a
source Prolog file for byte-code. In that case the Prolog to WAM compiler is
invoked using a specific option and produces a WAM for byte-code source file
(suffixed <TT>.wbc</TT>) that can be later loaded using <TT>load/1</TT>
(section&#XA0;<A HREF="#load/1">8.23.2</A>). Note that this is exactly what <TT>consult/1</TT>
(section&#XA0;<A HREF="#consult/1">8.23.1</A>) does as explained above (section&#XA0;<A HREF="#Consulting-a-Prolog-program">4.2.3</A>).</P><!--TOC subsubsection Using the compiler-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc17">4.4.3</A>&#XA0;&#XA0;Using the compiler</H4><!--SEC END --><P>
<A NAME="Using-the-compiler"></A>
The GNU Prolog compiler is a command-line compiler similar in spirit to a Unix
C compiler like <TT>gcc</TT>. To invoke the compiler use the <TT>gplc</TT>
command as follows:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><TT>% gplc </TT>[<I><TT>OPTION</TT></I>]&#X2026;<TT>&#XA0;<I>FILE</I></TT>&#X2026;</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(the <TT>%</TT> symbol is the operating system shell prompt)</TD></TR>
</TABLE></DD></DL><P>The arguments of <TT>gplc</TT> are file names that are dispatched in the
compilation scheme depending on the type determined from their suffix as was
explained previously (section&#XA0;<A HREF="#Compilation-scheme">4.4.2</A>). All object files are then
linked to produce an executable. Note however that GNU Prolog has no module
facility (since there is not yet an ISO reference for Prolog modules) thus a
predicate defined in a Prolog file is visible from any other predicate
defined in any other file. GNU Prolog allows the user to split a big Prolog
source into several files but does not offer any way to hide a predicate
from others.</P><P>The simplest way to obtain an executable from a Prolog source file
<TT>prog.pl</TT> is to use:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>% gplc prog.pl</TT></DD></DL><P>This will produce an native executable called <TT>prog</TT> which can be
executed as follows:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>% prog</TT></DD></DL><P>However, there are several options that can be used to control the
compilation:</P><P><B>General options</B>:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>-o</TT> <I><TT>FILE</TT></I>, <TT>--output</TT> <I><TT>FILE</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>use
<I><TT>FILE</TT></I> as the name of the output file</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>-W</TT>, <TT>--wam-for-native</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>stop after producing WAM files(s)</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>-w</TT>, <TT>--wam-for-byte-code</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>stop after producing WAM for
byte-code file(s) (force <TT>--no-call-c</TT>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>-M</TT>, <TT>--mini-assembly</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>stop after producing mini-assembly
files(s)</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>-S</TT>, <TT>--assembly</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>stop after producing assembly files (s)</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>-F</TT>, <TT>--fd-to-c</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>stop after producing C files(s) from FD
constraint definition file(s)</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>-c</TT>, <TT>--object</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>stop after producing object files(s)</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--temp-dir</TT> <I><TT>PATH</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>use <I><TT>PATH</TT></I> as directory
for temporary files</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--no-del-temp</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>do not delete temporary files</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--no-demangling</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>do not decode predicate names (name demangling)</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>-v</TT>, <TT>--verbose</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>print executed commands</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>-h</TT>, <TT>--help</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>print a help and exit</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--version</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>print version number and exit</TD></TR>
</TABLE><P><B>Prolog to WAM compiler options</B>:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>--pl-state</TT> <I><TT>FILE</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>read <I><TT>FILE</TT></I> to set the initial Prolog state</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--wam-comment</TT> <I><TT>COMMENT</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>emit <I><TT>COMMENT</TT></I> as a comment in the WAM file</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--no-susp-warn</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>do not show warnings for suspicious predicates</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--no-singl-warn</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>do not show warnings for named singleton
variables</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--no-redef-error</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>do not show errors for built-in predicate
redefinitions</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--foreign-only</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>only compile <TT>foreign/1-2</TT> directives</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--no-call-c</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>do not allow the use of <TT>fd_tell</TT>,
<TT>&#X2019;$call_c</TT>&#X2019;,&#X2026;</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--no-inline</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>do not inline predicates</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--no-reorder</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>do not reorder predicate arguments</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--no-reg-opt</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>do not optimize registers</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--min-reg-opt</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>minimally optimize registers</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--no-opt-last-subterm</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>do not optimize last subterm
compilation</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--fast-math</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>use fast mathematical mode (assume integer
arithmetics)</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--keep-void-inst</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>keep void WAM instructions in the output file</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--compile-msg</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>print a compile message</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--statistics</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>print statistics information</TD></TR>
</TABLE><P><B>WAM to mini-assembly translator options</B>:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>--comment</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>include comments in the output file</TD></TR>
</TABLE><P><B>Mini-assembly to assembly translator options</B>:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>--comment</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>include comments in the output file</TD></TR>
</TABLE><P><B>C compiler options</B>:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>--c-compiler</TT> <I><TT>FILE</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>use <I><TT>FILE</TT></I> as C compiler/linker</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>-C</TT> <I><TT>OPTION</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>pass <I><TT>OPTION</TT></I> to the C compiler</TD></TR>
</TABLE><P><B>Assembler options</B>:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>-A</TT> <I><TT>OPTION</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>pass <I><TT>OPTION</TT></I> to the assembler</TD></TR>
</TABLE><P><B>Linker options</B>:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>--linker</TT> <I><TT>FILE</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>use <I><TT>FILE</TT></I> as linker</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--local-size</TT> <I><TT>N</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>set default local stack size to
<I><TT>N</TT></I> Kb</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--global-size</TT> <I><TT>N</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>set default global stack size to
<I><TT>N</TT></I> Kb</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--trail-size</TT> <I><TT>N</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>set default trail stack size to
<I><TT>N</TT></I> Kb</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--cstr-size</TT> <I><TT>N</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>set default constraint stack size to
<I><TT>N</TT></I> Kb</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--fixed-sizes</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>do not consult environment variables at run-time
(use default sizes)</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--gui-console</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>link with the GUI console (windows only)</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--no-top-level</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>do not link the top-level (force
<TT>--no-debugger</TT>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--no-debugger</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>do not link the Prolog/WAM debugger</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--min-pl-bips</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>link only used Prolog built-in predicates</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--min-fd-bips</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>link only used FD solver built-in predicates</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--min-bips</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>shorthand for: <TT>--no-top-level</TT>
<TT>--min-pl-bips</TT> <TT>--min-fd-bips</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--min-size</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>shorthand for: <TT>--min-bips</TT> <TT>--strip</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--no-fd-lib</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>do not look for the FD library (maintenance only)</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>-s</TT>, <TT>--strip</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>strip the executable</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>-L</TT> <I><TT>OPTION</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>Pass <I><TT>OPTION</TT></I> to the linker</TD></TR>
</TABLE><P>It is possible to only give the prefix of an option if there is no ambiguity.</P><P>The name of the output file is controlled via the <TT>-o</TT>
<I><TT>FILE</TT></I> option. If present the output file produced will be
named <I><TT>FILE</TT></I>. If not specified, the output file name depends on the
last stage reached by the compiler. If the link is not done the output file
name(s) is the input file name(s) with the suffix associated with the last
stage. If the link is done, the name of the executable is the name (without
suffix) of the first file name encountered in the command-line. Note that if
the link is not done <TT>-o</TT> has no sense in the presence of multiple
input file names. For this reason, several meta characters are available for substitution in <I><TT>FILE</TT></I>:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>%f</TT> is substitued by the whole input file name.
</LI><LI CLASS="li-itemize"><TT>%F</TT> is similar to <TT>%f</TT> but the directory part is omitted.
</LI><LI CLASS="li-itemize"><TT>%p</TT> is substitued by the whole prefix file name (omitting the suffix).
</LI><LI CLASS="li-itemize"><TT>%P</TT> is similar to <TT>%p</TT> but the directory part is omitted.
</LI><LI CLASS="li-itemize"><TT>%s</TT> is substitued by the file suffix (including the dot).
</LI><LI CLASS="li-itemize"><TT>%d</TT> is substitued by the directory part (empty if no directory is specified).
</LI><LI CLASS="li-itemize"><TT>%c</TT> is substitued by the value of an internal counter starting from 1 and auto-incremented.
</LI></UL><P>By default the compiler runs in the native-code compilation scheme. To
generate a WAM file for byte-code use the <TT>--wam-for-byte-code</TT>
option. The resulting file can then be loaded using <TT>load/1</TT>
(section&#XA0;<A HREF="#load/1">8.23.2</A>).</P><P>To execute the Prolog to WAM compiler in a given <EM>read environment</EM>
(operator definitions, character conversion table,&#X2026;) use
<TT>--pl-state</TT> <I><TT>FILE</TT></I>. The state file should be
produced by <TT>write_pl_state_file/1</TT>
(section&#XA0;<A HREF="#write-pl-state-file/1">8.22.5</A>).</P><P>By default the Prolog to WAM compiler inlines calls to some deterministic
built-in predicates (e.g. <TT>arg/3</TT> and <TT>functor/3</TT>). Namely a
call to such a predicate will not yield a classical predicate call but a
simple C function call (which is obviously faster). It is possible to avoid
this using <TT>--no-inline</TT>.</P><P>Another optimization performed by the Prolog to WAM compiler is unification
reordering. The arguments of a predicate are reordered to optimize
unification. This can be deactivated using <TT>--no-reorder</TT>. The
compiler also optimizes the unification/loading of nested compound terms.
More precisely, the compiler emits optimized instructions when the last
subterm of a compound term is itself a compound term (e.g. lists). This can
be deactivated using <TT>--no-opt-last-subterm</TT>.</P><P>By default the Prolog to WAM compiler fully optimizes the allocation of
registers to decrease both the number of instruction produced and the number
of used registers. A good allocation will generate many <EM>void
instructions</EM> that are removed from the produced file except if
<TT>--keep-void-inst</TT> is specified. To prevent any optimization use
<TT>--no-reg-opt</TT> while <TT>--min-reg-opt</TT> forces the compiler to
only perform simple register optimizations.</P><P>The Prolog to WAM compiler emits an error when a control construct or a
built-in predicate is redefined. This can be avoided using
<TT>--no-redef-error</TT>. The compiler also emits warnings for suspicious
predicate definitions like <TT>-/2</TT> since this often corresponds to an
earlier syntax error (e.g. <TT>-</TT> instead of <TT>_</TT>. This can be
deactivated by specifying <TT>--no-susp-warn</TT>. Finally, the compiler
warns when a singleton variable has a name (i.e. not the generic anonymous
name <TT>_</TT>). This can be deactivated specifying
<TT>--no-singl-warn</TT>.</P><P>Internally, predicate names are encoded to fit the syntax of (assembly)
identifiers. For this GNU Prolog uses it own name mangling scheme. This
is explained in more detail later (section&#XA0;<A HREF="#Name-mangling-scheme">4.4.6</A>). By default
the error messages from the linker (e.g. multiple definitions for a given
predicate, reference to an undefined predicate,&#X2026;) are filtered to
replace an internal name representation by the real predicate name
(demangling). Specifying the <TT>--no-demangling</TT> prevents
<TT>gplc</TT> from filtering linker output messages (internal identifiers are
then shown).</P><P>When producing an executable it is possible to specify default stack sizes
(using <TT>--<I>STACK_NAME</I>-size</TT>) and to prevent it from consulting
environment variables (using <TT>--fixed-sizes</TT>) as was explained above
(section&#XA0;<A HREF="#Adjusting-the-size-of-Prolog-stacks">4.3</A>). By default the produced
executable will include the top-level, the Prolog/WAM debugger
and all Prolog and FD built-in predicates. It is possible to avoid linking
the top-level (section&#XA0;<A HREF="#The-GNU-Prolog-interactive-interpreter">4.2</A>) by specifying
<TT>--no-top-level</TT>. In this case, at least one
<TT>initialization/1</TT> directive (section&#XA0;<A HREF="#initialization/1">7.1.14</A>) should be
defined. The option <TT>--no-debugger</TT> does not link the debugger. To
include only used built-in predicates that are actually used the options
<TT>--no-pl-bips</TT> and/or <TT>--no-fd-bips</TT> can be specified. For the
smallest executable all these options should be specified. This can be
abbreviated by using the shorthand option <TT>--min-bips</TT>. By default,
executables are not <EM>stripped</EM>, i.e. their symbol table is not
removed. This table is only useful for the C debugger (e.g. when interfacing
Prolog and C). To remove the symbol table (and then to reduce the size of
the final executable) use <TT>--strip</TT>. Finally <TT>--min-size</TT> is a
shortcut for <TT>--min-bips</TT> and <TT>--strip</TT>, i.e. the produced
executable is as small as possible.</P><P>Example: compile and link two Prolog sources <TT>prog1.pl</TT> and
<TT>prog2.pl</TT>. The resulting executable will be named <TT>prog1</TT>
(since <TT>-o</TT> is not specified):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>% gplc prog1.pl prog2.pl</TT></DD></DL><P>Example: compile the Prolog file <TT>prog.pl</TT> to study basic WAM code.
The resulting file will be named <TT>prog.wam</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>% gplc -W --no-inline --no-reorder --keep-void-inst prog.pl</TT></DD></DL><P>Example: compile the Prolog file <TT>prog.pl</TT> and its C interface file
<TT>utils.c</TT> to provide an autonomous executable called
<TT>mycommand</TT>. The executable is not stripped to allow the use of the C
debugger:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>% gplc -o mycommand prog.pl utils.c</TT></DD></DL><P>Example: detail all steps to compile the Prolog file <TT>prog.pl</TT> (the
resulting executable is stripped). All intermediate files are produced
(<TT>prog.wam</TT>, <TT>prog.ma</TT>, <TT>prog.s</TT>, <TT>prog.o</TT> and
the executable <TT>prog</TT>):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">% gplc -W prog.pl
% gplc -M --comment prog.wam
% gplc -S --comment prog.ma
% gplc -c prog.s
% gplc -o prog -s prog.o
</PRE></DD></DL><!--TOC subsubsection Running an executable-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc18">4.4.4</A>&#XA0;&#XA0;Running an executable</H4><!--SEC END --><P>
<A NAME="Running-an-executable"></A>
In this section we explain what happens when running an executable produced
by the GNU Prolog native-code compiler. The default main function first starts
the Prolog engine. This function collects all linked objects (issued from the
compilation of Prolog files) and initializes them. The initialization of a
Prolog object file consists in adding to appropriate tables new atoms, new
predicates and executing its system directives. A system directive is
generated by the Prolog to WAM compiler to reflect a (user) directive
executed at compile-time such as <TT>op/3</TT> (section&#XA0;<A HREF="#op/3">7.1.11</A>). Indeed, when the
compiler encounters such a directive it immediately executes it and also
generates a system directive to execute it at the start of the executable.
When all system directives have been executed the Prolog engine executes all
initialization directives defined with <TT>initialization/1</TT>
(section&#XA0;<A HREF="#initialization/1">7.1.14</A>). If several initialization directives appear in the
same file they are executed in the order of appearance. If several
initialization directives appear in different files the order in which they
are executed is machine-dependant. However, on most machines the order will
be the reverse order in which the associated files have been linked (this is
not true under native win32). When all initialization directives have been
executed the default main function looks for the GNU Prolog
top-level. If present (i.e. it has been linked) it is called otherwise
the program simply ends. Note that if the top-level is not linked and if
there is no initialization directive the program is useless since it simply
ends without doing any work. The default main function detects such a
behavior and emits a warning message.</P><P>Example: compile an empty file <TT>prog.pl</TT> without linking the
top-level and execute it:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">% gplc --no-top-level prog.pl
% prog
Warning: no initial goal executed
   use a directive :- initialization(Goal)
   or remove the link option --no-top-level (or --min-bips or --min-size)
</PRE></DD></DL><!--TOC subsubsection Generating a new interactive interpreter-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc19">4.4.5</A>&#XA0;&#XA0;Generating a new interactive interpreter</H4><!--SEC END --><P>
<A NAME="Generating-a-new-interactive-interpreter"></A>
In this section we show how to define a new top-level extending the
GNU Prolog interactive interpreter with new predicate definitions. The
obtained top-level can then be considered as an enriched version of the basic
GNU Prolog top-level (section&#XA0;<A HREF="#The-GNU-Prolog-interactive-interpreter">4.2</A>). Indeed, each
added predicate can be viewed as a predefined predicate just like any other
built-in predicate. This can be achieved by compiling these predicates and
including the top-level at link-time.</P><P>The real question is: why would we include some predicates in a new
top-level instead of simply consulting them under the GNU Prolog top-level ?
There are two reasons for this:</P><UL CLASS="itemize"><LI CLASS="li-itemize">the predicate cannot be consulted. This is the case of a predicate
calling foreign code, like a predicate interfacing with C (section&#XA0;<A HREF="#Interfacing-Prolog-and-C">10</A>) or a predicate defining a new FD constraint.</LI><LI CLASS="li-itemize">the performance of the predicate is crucial. Since it is compiled to
native-code such a predicate will be executed very quickly. Consulting will
load it as byte-code. The gain is much more noticeable if the program is run
under the debugger. The included version will not be affected by the
debugger while the consulted version will be several times slower.
Obviously, a predicate should be included in a new top-level only when it is
itself debugged since it is difficult to debug native-code.</LI></UL><P>To define a new top-level simply compile the set of desired predicates and
linking them with the GNU Prolog top-level (this is the default) using
<TT>gplc</TT> (section&#XA0;<A HREF="#Using-the-compiler">4.4.3</A>).</P><P>Example: let us define a new top-level called <TT>my_top_level</TT>
including all predicates defined in <TT>prog.pl</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>% gplc -o my_top_level prog.pl</TT></DD></DL><P>By the way, note that if <TT>prog.pl</TT> is an empty Prolog file the
previous command will simply create a new interactive interpreter similar to
the GNU Prolog top-level.</P><P>Example: as before where some predicates of <TT>prog.pl</TT> call C functions
defined in <TT>utils.c</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>% gplc -o my_top_level prog.pl utils.c</TT></DD></DL><P>In conclusion, defining a particular top-level is nothing else but a
particular case of the native-code compilation. It is simple to do and very
useful in practice.</P><!--TOC subsubsection The name mangling scheme-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc20">4.4.6</A>&#XA0;&#XA0;The name mangling scheme</H4><!--SEC END --><P>
<A NAME="Name-mangling-scheme"></A></P><P>When the GNU Prolog compiler compiles a Prolog source to an object file it
has to associate a symbol to each predicate name. However, the syntax of
symbols is restricted to identifiers: string containing only letters, digits
or underscore characters. On the other hand, predicate names (i.e. atoms) can
contain any character with quotes if necessary (e.g. <TT>&#X2019;x+y=z&#X2019;</TT> is a
valid predicate name). The compiler may thus have to encode predicate names
respecting the syntax of identifiers. In addition, Prolog allows the user to
define several predicates with the same name and different arities, for this
GNU Prolog encodes predicate indicators (predicate name followed by the
arity). Finally, to support modules in the future, the module name is also
encoded.</P><P>Since version 1.4.0, GNU Prolog adopts the following name mangling
scheme. A predicate indicator of the form
[<TT><I>MODULE</I>:</TT>]<TT><I>PRED</I>/<I>N</I></TT> (where
the <I><TT>MODULE</TT></I> can be omitted) will give rise to an identifier of the
following form:
<TT>X<I>K</I>_</TT>[<I>E(<TT>MODULE</TT>)</I><TT>__</TT>]<I>E(<TT>PRED</TT>)</I><TT>__a<I>N</I></TT>
where:</P><DL CLASS="description"><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><I><TT>K</TT></I> is a digit in <TT>0</TT>..<TT>5</TT> storing coding information about <I><TT>MODULE</TT></I> and <I><TT>PRED</TT></I>. Possible values are:<UL CLASS="itemize"><LI CLASS="li-itemize"><TT>0</TT>: no module present, <I><TT>PRED</TT></I> is not encoded
</LI><LI CLASS="li-itemize"><TT>1</TT>: no module present, <I><TT>PRED</TT></I> is encoded
</LI><LI CLASS="li-itemize"><TT>2</TT>: <I><TT>MODULE</TT></I> is not encoded, <I><TT>PRED</TT></I> is not encoded
</LI><LI CLASS="li-itemize"><TT>3</TT>: <I><TT>MODULE</TT></I> is not encoded, <I><TT>PRED</TT></I> is encoded
</LI><LI CLASS="li-itemize"><TT>4</TT>: <I><TT>MODULE</TT></I> is encoded, <I><TT>PRED</TT></I> is not encoded
</LI><LI CLASS="li-itemize"><TT>5</TT>: <I><TT>MODULE</TT></I> is encoded, <I><TT>PRED</TT></I> is encoded</LI></UL></DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><I>E(<TT>STR</TT>)</I> is a function to encode a string <I><TT>STR</TT></I> which returns:<UL CLASS="itemize"><LI CLASS="li-itemize"><I><TT>STR</TT></I> itself (not encoded) if <I><TT>STR</TT></I> only contains letters, digits or <TT>_</TT> but does not contain the substring <TT>__</TT> and does not begin nor end with <TT>_</TT> (i.e. regexp: <TT>[a-zA-Z0-9]([-]?[a-zA-Z0-9])*</TT>).</LI><LI CLASS="li-itemize">an hexadecimal representation of each character of the string otherwise. For example: <I>E(</I><TT>x+y=z</TT><I>)</I> returns <TT>782B793D7A</TT> since
<TT>78</TT> is the hexadecimal representation of the ASCII code of <TT>x</TT>,
<TT>2B</TT> of the code of <TT>+</TT>, etc.</LI></UL></DD></DL><P>Examples: </P><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP>
Predicate indicator</TD><TD ALIGN=left NOWRAP>internal identifier</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>father/2</TT></TD><TD ALIGN=left NOWRAP><TT>X0_father__a2</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&#X2019;x+y=z&#X2019;/3</TT></TD><TD ALIGN=left NOWRAP><TT>X1_782B793D7A__a3</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>util:same/2</TT></TD><TD ALIGN=left NOWRAP><TT>X2_util__same__a2</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>util:same__1/3</TT></TD><TD ALIGN=left NOWRAP><TT>X3_util__73616D655F5F31__a3</TT></TD></TR>
</TABLE>
</DIV><P>&#XA0;</P><P>So, from the mini-assembly stage, each predicate indicator is handled
via its name mangling identifier. The knowledge of this scheme is normally
not of interest for the user, i.e. the Prolog programmer. For this reason the
GNU Prolog compiler hides this mangling. When an error occurs on a predicate
(undefined predicate, predicate with multiple definitions,&#X2026;) the
compiler has to decode the symbol associated with the predicate indicator
(name demangling). For this <TT>gplc</TT> filters each message emitted
by the linker to locate and decode eventual predicate indicators. This
filtering can be deactivated specifying <TT>--no-demangling</TT> when
invoking <TT>gplc</TT> (section&#XA0;<A HREF="#Using-the-compiler">4.4.3</A>).</P><P>This filter is provided as an utility that can be invoked using the
<TT>hexgplc</TT> command as follows:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><TT>% hexgplc </TT>[<I><TT>OPTION</TT></I>]&#X2026;<TT>&#XA0;<I>FILE</I></TT>&#X2026;</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(the <TT>%</TT> symbol is the operating system shell prompt)</TD></TR>
</TABLE></DD></DL><P><B>Options</B>:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>--decode</TT> or <TT>--demangling</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>decoding mode (this is the default mode)</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--encode</TT> or <TT>--mangling</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>encoding mode</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--relax</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>decode also predicate names (not only predicate
indicators)</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--printf</TT> <I><TT>FORMAT</TT></I></TD><TD VALIGN=top ALIGN=left NOWRAP>pass encoded/decoded string to C
<TT>printf(3)</TT> with <I><TT>FORMAT</TT></I></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--aux-father</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>decode an auxiliary predicate as its father</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--aux-father2</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>decode an auxiliary predicate as its father +
auxiliary number</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--cmd-line</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>encode/decode each argument of the command-line</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>-E</TT> or <TT>-M</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>same as: <TT>--cmd-line --encode --relax</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>-P</TT> or <TT>-D</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>same as: <TT>--cmd-line --decode --relax --quote</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--help</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>print a help and exit</TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>--version</TT></TD><TD VALIGN=top ALIGN=left NOWRAP>print version number and exit</TD></TR>
</TABLE><P>It is possible to give a prefix of an option if there is no ambiguity.</P><P>Without arguments <TT>hexgplc</TT> runs in decoding mode reading its
standard input and decoding (demangling) each symbol corresponding to a predicate
indicator. To use <TT>hexgplc</TT> in the encoding (mangling) mode the
<TT>--encode</TT> option must be specified. By default <TT>hexgplc</TT> only
decodes predicate indicators, this can be relaxed using <TT>--relax</TT> to
also take into account simple predicate names (the arity can be omitted). It
is possible to format the output of an encoded/decoded string using
<TT>--printf <I>FORMAT</I></TT> in that case each string
<I><TT>S</TT></I> is passed to the C <TT>printf(3)</TT> function as
<TT>printf(<I>FORMAT</I>,<I>S</I>)</TT>.</P><P>Auxiliary predicates are generated by the Prolog to WAM compiler when
simplifying some control constructs like <TT>&#X2019;;&#X2019;/2</TT> present in the body
of a clause. They are of the form
<TT>&#X2019;$<I>NAME</I>/<I>ARITY</I>_$aux<I>N</I>&#X2019;</TT> where
<TT><I>NAME</I>/<I>ARITY</I></TT> is the predicate indicator of the
simplified (i.e. father) predicate and <I><TT>N</TT></I> is a sequential
number (a predicate can give rise to several auxiliary predicates). It is
possible to force <TT>hexgplc</TT> to decode an auxiliary predicate as its
father predicate indicator using <TT>--aux-father</TT> or as its father
predicate indicator followed by the sequential number using
<TT>--aux-father2</TT>.</P><P>If no file is specified, <TT>hexgplc</TT> processes its standard input
otherwise each file is treated sequentially. Specifying the
<TT>--cmd-line</TT> option informs <TT>hexgplc</TT> that each argument is not
a file name but a string that must be encoded (or decoded). This is useful to
encode/decode a particular string. For this reason the option <TT>-E</TT>
(encode) and <TT>-D</TT> (decode) are provided as
shorthand. Then, to obtain the mangling representation of a predicate
<I><TT>PRED</TT></I> use:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>% hexgplc -E <I>PRED</I></TT></DD></DL><P>NB: if <I><TT>PRED</TT></I> is a complex atom it is necessary to quote it 
(the quotes must be passed to <TT>hexgplc</TT>). Here is an example under bash:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">% hexgplc -E \'x+y=z\'/3
X1_782B793D7A__a3
</PRE></DD></DL><P>Or even more safely (using bash quotes to prevent bash from interpreting special characters):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">% hexgplc -E \''x+y=z'\'/3
X1_782B793D7A__a3
</PRE></DD></DL><!--CUT END -->
<!--TOC section Debugging-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc21">5</A>&#XA0;&#XA0;Debugging</H2><!--SEC END --><P>
<A NAME="Debugging"></A>
</P><!--CUT DEF subsection 1 --><!--TOC subsection Introduction-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc22">5.1</A>&#XA0;&#XA0;Introduction</H3><!--SEC END --><P>
The GNU Prolog debugger provides information concerning the control flow of
the program. The debugger can be fully used on consulted predicates (i.e.
byte-code). For native compiled code only the calls/exits are traced, no
internal behavior is shown. Under the debugger it is possible to exhaustively
trace the execution or to set spy-points to only debug a specific part of the
program. Spy-points allow the user to indicate on which predicates the
debugger has to stop to allow the user to interact with it. The debugger uses
the &#X201C;procedure box control flow model&#X201D;, also called the Byrd Box model
since it is due to Lawrence Byrd.</P><!--TOC subsection The procedure box model-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc23">5.2</A>&#XA0;&#XA0;The procedure box model</H3><!--SEC END --><P>
The procedure box model of Prolog execution provides a simple way to show
the control flow. This model is very popular and has been adopted in many
Prolog systems (e.g. SICStus Prolog, Quintus Prolog,&#X2026;). A good
introduction is the chapter 8 of &#X201C;Programming in Prolog&#X201D; of Clocksin &amp;
Mellish&#XA0;[<A HREF="#Clock">2</A>]. The debugger executes a program step by step tracing an
invocation to a predicate (<TT>call</TT>) and the return from this predicate
due to either a success (<TT>exit</TT>) or a failure (<TT>fail</TT>). When a
failure occurs the execution backtracks to the last predicate with an
alternative clause. The predicate is then re-invoked (<TT>redo</TT>).
Another source of change of the control flow is due to exceptions. When an
exception is raised from a predicate (<TT>exception</TT>) by
<TT>throw/1</TT> (section&#XA0;<A HREF="#catch/3">7.2.4</A>) the control is given back to the most
recent predicate that has defined a handler to recover this exception using
<TT>catch/3</TT> (section&#XA0;<A HREF="#catch/3">7.2.4</A>). The procedure box model shows these
different changes in the control flow, as illustrated here:</P><DIV CLASS="center"><IMG SRC="debug-box.gif"></DIV><P>Each arrow corresponds to a <EM>port</EM>. An arrow to the box indicates
that the control is given to this predicate while an arrow from the box
indicates that the control is given back from the procedure. This model
visualizes the control flow through these five ports and the connections
between the boxes associated with subgoals. Finally, it should be clear that a
box is associated with one invocation of a given predicate. In particular, a
recursive predicate will give raise to a box for each invocation of the
predicate with different entries/exits in the control flow. Since this might
get confusing for the user, the debugger associates with each box a unique
identifier (i.e. the invocation number).</P><!--TOC subsection Debugging predicates-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc24">5.3</A>&#XA0;&#XA0;Debugging predicates</H3><!--SEC END --><!--TOC subsubsection Running and stopping the debugger-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc25">5.3.1</A>&#XA0;&#XA0;Running and stopping the debugger</H4><!--SEC END --><P>
<A NAME="Running-and-stopping-the-debugger"></A>





</P><P><TT>trace/0</TT> activates the debugger. The next invocation of a predicate
will be traced.</P><P><TT>debug/0</TT> activates the debugger. The next invocation of a predicate
on which a spy-point has been set will be traced.</P><P>It is important to understand that the information associated with the control
flow is only available when the debugger is on. For efficiency reasons, when
the debugger is off the information concerning the control flow (i.e. the
boxes) is not retained. So, if the debugger is activated in the middle of a
computation (by a call to <TT>debug/0</TT> or <TT>trace/0</TT> in the
program or after the interrupt key sequence (<TT>Ctl-C</TT>) by choosing
<TT>trace</TT> or <TT>debug</TT>), information prior to this point is not
available.</P><P><TT>debugging/0</TT>: prints onto the terminal information about the current
debugging state (whether the debugger is switched on, what are the leashed
ports, spy-points defined,&#X2026;).</P><P><TT>notrace/0</TT> or <TT>nodebug/0</TT> switches the debugger off.</P><P><TT>wam_debug/0</TT> invokes the sub-debugger devoted to the WAM data
structures (section&#XA0;<A HREF="#The-WAM-debugger">5.6</A>). It can be also invoked using the
<TT>W</TT> debugger command (section&#XA0;<A HREF="#Debugger-commands">5.5</A>).</P><!--TOC subsubsection Leashing ports-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc26">5.3.2</A>&#XA0;&#XA0;Leashing ports</H4><!--SEC END --><P>
<A NAME="Leashing-ports"></A>
</P><P><TT>leash(Ports)</TT> requests the debugger to prompt the user, as
he creeps through the program, for every port defined in the <TT>Ports</TT>
list. Each element of <TT>Ports</TT> is an atom in <TT>call</TT>,
<TT>exit</TT>, <TT>redo</TT>, <TT>fail</TT>, <TT>exception</TT>.
<TT>Ports</TT> can also be an atom defining a shorthand:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>full</TT>: equivalent to <TT>[call, exit, redo, fail,
exception]</TT></LI><LI CLASS="li-itemize"><TT>half</TT>: equivalent to <TT>[call, redo]</TT></LI><LI CLASS="li-itemize"><TT>loose</TT>: equivalent to <TT>[call]</TT></LI><LI CLASS="li-itemize"><TT>none</TT>: equivalent to <TT>[]</TT></LI><LI CLASS="li-itemize"><TT>tight</TT>: equivalent to <TT>[call, redo, fail,
exception]</TT></LI></UL><P>When an unleashed port is encountered the debugger continues to show the
associated goal but does not stop the execution to prompt the user.</P><!--TOC subsubsection Spy-points-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc27">5.3.3</A>&#XA0;&#XA0;Spy-points</H4><!--SEC END --><P>
<A NAME="Spy-points"></A>



</P><P>When dealing with big sources it is not very practical to creep through the
entire program. It is preferable to define a set of spy-points on
interesting predicates to be prompted when the debugger reaches one of these
predicates. Spy-points can be added either using <TT>spy/1</TT> (or
<TT>spypoint_condition/3</TT>) or dynamically when prompted by the debugger
using the <TT>+</TT> (or <TT>*</TT>) debugger command
(section&#XA0;<A HREF="#Debugger-commands">5.5</A>). The current mode of leashing does not
affect spy-points in the sense that user interaction is requested on
every port.</P><P><TT>spy(PredSpec)</TT> sets a spy-point on all the predicates given by
<TT>PredSpec</TT>. <TT>PredSpec</TT> defines one or several predicates and
has one of the following forms:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>[PredSpec1, PredSpec2,&#X2026;]</TT>: set a spy-point for each
element of the list.</LI><LI CLASS="li-itemize"><TT>Name</TT>: set a spy-point for any predicate whose name is
<TT>Name</TT> (whatever the arity).</LI><LI CLASS="li-itemize"><TT>Name/Arity</TT>: set a spy-point for the predicate whose name is
<TT>Name</TT> and arity is <TT>Arity</TT>.</LI><LI CLASS="li-itemize"><TT>Name/A1-A2</TT>: set a spy-point for the each predicate whose name
is <TT>Name</TT> and arity is between <TT>A1</TT> and <TT>A2</TT>.</LI></UL><P>It is not possible to set a spy-point on an undefined predicate.</P><P>The following predicate is used to remove one or several spy-points:</P><P><TT>nospy(PredSpec)</TT> removes the spy-points from the specified
predicates.</P><P><TT>nospyall/0</TT> removes all spy-points:</P><P>It is also possible to define conditional spy-points.</P><P><TT>spypoint_condition(Goal, Port, Test)</TT> sets a
conditional spy-point on the predicate for <TT>Goal</TT>. When the debugger
reaches a conditional spy-point it only shows the associated goal if the
following conditions are verified:</P><UL CLASS="itemize"><LI CLASS="li-itemize">the actual goal unifies with <TT>Goal</TT>.</LI><LI CLASS="li-itemize">the actual port unifies with <TT>Port</TT>.</LI><LI CLASS="li-itemize">the Prolog goal <TT>Test</TT> succeeds.</LI></UL><!--TOC subsection Debugging messages-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc28">5.4</A>&#XA0;&#XA0;Debugging messages</H3><!--SEC END --><P>
We here described which information is displayed by the debugger when it
shows a goal. The basic format is as follows:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT><I>S N M Port</I>:&#XA0;<I>Goal</I> ?</TT></DD></DL><P><I><TT>S</TT></I> is a spy-point indicator: if there is a spy-point on the
current goal the <TT>+</TT> symbol is displayed else a space is displayed.
<I><TT>N</TT></I> is the invocation number. This unique number can be used
to correlate the trace messages for the various ports, since it is unique
for every invocation. <I><TT>M</TT></I> is an index number which
represents the number of direct ancestors of the goal (i.e. the current
depth of the goal). <I><TT>Port</TT></I> specifies the particular port
(<TT>call</TT>, <TT>exit</TT>, <TT>fail</TT>, <TT>redo</TT>,
<TT>exception</TT>). <I><TT>Goal</TT></I> is the current goal (it is then
possible to inspect its current instantiation) which is displayed using
<TT>write_term/3</TT> with <TT>quoted(true)</TT> and
<TT>max_depth(<I>D</I>)</TT> options (section&#XA0;<A HREF="#write-term/3">8.14.6</A>). Initially
<I><TT>D</TT></I> (the print depth) is set to 10 but can be redefined
using the <TT>&lt;</TT> debugger command (section&#XA0;<A HREF="#Debugger-commands">5.5</A>). The
<TT>?</TT> symbol is displayed when the debugger is waiting a command from
the user. (i.e. <TT>Port</TT> is a leashed port). If the port is unleashed,
this symbol is not displayed and the debugger continues the execution
displaying the next goal.</P><!--TOC subsection Debugger commands-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc29">5.5</A>&#XA0;&#XA0;Debugger commands</H3><!--SEC END --><P>
<A NAME="Debugger-commands"></A>
When the debugger reaches a leashed port it shows the current goal followed
by the <TT>?</TT> symbol. At this point there are many commands available.
Typing <TT>RETURN</TT> will creep into the program. Continuing to creep will
show all the control flow. The debugger shows every port for every predicate
encountered during the execution. It is possible to select the ports at
which the debugger will prompt the user using the built-in predicate
<TT>leash/1</TT> (section&#XA0;<A HREF="#Leashing-ports">5.3.2</A>). Each command is only one
character long:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=center NOWRAP>
Command</TD><TD VALIGN=top ALIGN=center NOWRAP>Name</TD><TD VALIGN=top ALIGN=left>Description</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>RET</TT> or <TT>c</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>creep</TD><TD VALIGN=top ALIGN=left>single-step to the next port</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>l</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>leap</TD><TD VALIGN=top ALIGN=left>continue the execution only stopping when a goal with a
spy-point is reached</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>s</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>skip</TD><TD VALIGN=top ALIGN=left>skip over the entire execution of the current goal. No
message will be shown until control returns</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>G</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>go to</TD><TD VALIGN=top ALIGN=left>ask for an invocation number and continue the execution
until a port is reached for that invocation number</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>r</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>retry</TD><TD VALIGN=top ALIGN=left>try to restart the invocation of the current goal by
failing until reaching the invocation of the goal. The state of
execution is the same as when the goal was initially invoked (except when
using side-effect predicates)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>f</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>fail</TD><TD VALIGN=top ALIGN=left>force the current goal to fail immediately</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>w</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>write</TD><TD VALIGN=top ALIGN=left>show the current goal using <TT>write/2</TT>
(section&#XA0;<A HREF="#write-term/3">8.14.6</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>d</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>display</TD><TD VALIGN=top ALIGN=left>show the current goal using <TT>display/2</TT>
(section&#XA0;<A HREF="#write-term/3">8.14.6</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>p</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>print</TD><TD VALIGN=top ALIGN=left>show the current goal using <TT>print/2</TT>
(section&#XA0;<A HREF="#write-term/3">8.14.6</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>e</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>exception</TD><TD VALIGN=top ALIGN=left>show the pending exception. Only applicable to an
<TT>exception</TT> port</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>g</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>ancestors</TD><TD VALIGN=top ALIGN=left>show the list of ancestors of the current goal</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>A</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>alternatives</TD><TD VALIGN=top ALIGN=left>show the list of ancestors of the current goal
combined with choice-points</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>u</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>unify</TD><TD VALIGN=top ALIGN=left>ask for a term and unify the current goal with this
term. This is convenient for getting a specific solution. Only available at
a <TT>call</TT> port</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>.</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>father file</TD><TD VALIGN=top ALIGN=left>show the Prolog file name and the line number
where the current predicate is defined</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>n</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>no debug</TD><TD VALIGN=top ALIGN=left>switch the debugger off. Same as <TT>nodebug/0</TT>
(section&#XA0;<A HREF="#Running-and-stopping-the-debugger">5.3.1</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>=</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>debugging</TD><TD VALIGN=top ALIGN=left>show debugger information. Same as
<TT>debugging/0</TT> (section&#XA0;<A HREF="#Running-and-stopping-the-debugger">5.3.1</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>+</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>spy this</TD><TD VALIGN=top ALIGN=left>set a spy-point on the current goal. Uses
<TT>spy/1</TT> (section&#XA0;<A HREF="#Spy-points">5.3.3</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>-</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>nospy this</TD><TD VALIGN=top ALIGN=left>remove a spy-point on the current goal. Uses
<TT>nospy/1</TT> (section&#XA0;<A HREF="#Spy-points">5.3.3</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>*</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>spy conditionally</TD><TD VALIGN=top ALIGN=left>ask for a term <TT>Goal, Port, Test</TT>
(terminated by a dot) and set a conditional spy-point on the current
predicate. <TT>Goal</TT> and the current goal must have the same predicate
indicator. Uses <TT>spypoint_condition/3</TT> (section&#XA0;<A HREF="#Spy-points">5.3.3</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>L</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>listing</TD><TD VALIGN=top ALIGN=left>list all the clauses associated with the current
predicate. Uses <TT>listing/1</TT> (section&#XA0;<A HREF="#listing/1">8.23.3</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>a</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>abort</TD><TD VALIGN=top ALIGN=left>abort the current execution. Same as <TT>abort/0</TT>
(section&#XA0;<A HREF="#abort/0">8.18.1</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>b</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>break</TD><TD VALIGN=top ALIGN=left>invoke a recursive top-level. Same as <TT>break/0</TT>
(section&#XA0;<A HREF="#abort/0">8.18.1</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>@</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>execute goal</TD><TD VALIGN=top ALIGN=left>ask for a goal and execute it</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>&lt;</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>set print depth</TD><TD VALIGN=top ALIGN=left>ask for an integer and set the print
depth to this value (<TT>-1</TT> for no depth limit)</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>h</TT> or <TT>?</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>help</TD><TD VALIGN=top ALIGN=left>display a summary of available commands</TD></TR>
<TR><TD VALIGN=top ALIGN=center NOWRAP>
<TT>W</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>WAM debugger</TD><TD VALIGN=top ALIGN=left>invoke the low-level WAM debugger
(section&#XA0;<A HREF="#The-WAM-debugger">5.6</A>)</TD></TR>
</TABLE><!--TOC subsection The WAM debugger-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc30">5.6</A>&#XA0;&#XA0;The WAM debugger</H3><!--SEC END --><P>
<A NAME="The-WAM-debugger"></A>
In some cases it is interesting to have access to the WAM data
structures. This sub-debugger allows the user to inspect/modify the contents
of any stack or register of the WAM. The WAM debugger is invoked
using the built-in predicate <TT>wam_debug/0</TT> (section&#XA0;<A HREF="#Running-and-stopping-the-debugger">5.3.1</A>) or the <TT>W</TT> debugger command (section&#XA0;<A HREF="#Debugger-commands">5.5</A>). The following table presents the specific commands of the WAM
debugger:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP>
Command</TD><TD ALIGN=left NOWRAP>Description</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>write</TT> <I><TT>A</TT></I> [<I><TT>N</TT></I>]</TD><TD ALIGN=left NOWRAP>write
<I><TT>N</TT></I> terms starting at the address <I><TT>A</TT></I> using <TT>write/1</TT>
(section&#XA0;<A HREF="#write-term/3">8.14.6</A>)</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>data</TT> <I><TT>A</TT></I> [<I><TT>N</TT></I>]</TD><TD ALIGN=left NOWRAP>display <I><TT>N</TT></I> words starting at
the address <I><TT>A</TT></I></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>modify</TT> <I><TT>A</TT></I> [<I><TT>N</TT></I>]</TD><TD ALIGN=left NOWRAP>display and modify <I><TT>N</TT></I> words
starting at the address <I><TT>A</TT></I></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>where</TT> <I><TT>A</TT></I></TD><TD ALIGN=left NOWRAP>display the real address corresponding to
<I><TT>A</TT></I></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>what</TT> <I><TT>RA</TT></I></TD><TD ALIGN=left NOWRAP>display what corresponds to the real address
<I><TT>RA</TT></I></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>deref</TT> <I><TT>A</TT></I></TD><TD ALIGN=left NOWRAP>display the dereferenced word starting at the
address <I><TT>A</TT></I></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>envir</TT> [<I><TT>SA</TT></I>]</TD><TD ALIGN=left NOWRAP>display the contents of the environment
located at <I><TT>SA</TT></I> (or the current one)</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>backtrack</TT> [<I><TT>SA</TT></I>]</TD><TD ALIGN=left NOWRAP>display the contents of the choice-point
located at <I><TT>SA</TT></I> (or the current one)</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>backtrack all</TT></TD><TD ALIGN=left NOWRAP>display all choice-points</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>quit</TT></TD><TD ALIGN=left NOWRAP>quit the WAM debugger</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>help</TT></TD><TD ALIGN=left NOWRAP>display a summary of available commands</TD></TR>
</TABLE><P>In the above table the following conventions apply:</P><UL CLASS="itemize"><LI CLASS="li-itemize">elements between [ and ] are optional.</LI><LI CLASS="li-itemize"><I><TT>N</TT></I> is an optional integer (defaults to 1).</LI><LI CLASS="li-itemize"><I><TT>A</TT></I> is a WAM address, its syntax is:
<I><TT>BANK_NAME</TT></I> [ <TT>[ <I>N</I> ]</TT> ], i.e. a bank name
possibly followed by an index (defaults to 0). <I><TT>BANK_NAME</TT></I>
is either:<UL CLASS="itemize"><LI CLASS="li-itemize"><TT>reg</TT>: WAM general register (stack pointers, continuation,
...).</LI><LI CLASS="li-itemize"><TT>x</TT>: WAM X register (temporary variables, i.e. arguments).</LI><LI CLASS="li-itemize"><TT>y</TT>: WAM Y register (permanent variables).</LI><LI CLASS="li-itemize"><TT>ab</TT>: WAM X register saved in the current choice-point.</LI><LI CLASS="li-itemize"><I><TT>STACK_NAME</TT></I>: WAM stack
(<I><TT>STACK_NAME</TT></I> in <TT>local</TT>, <TT>global</TT>, <TT>trail</TT>,
<TT>cstr</TT>).</LI></UL></LI><LI CLASS="li-itemize"><I><TT>SA</TT></I> is a WAM stack address, i.e.
<I><TT>STACK_NAME</TT></I> [ <TT>[ <I>N</I> ]</TT> ] (special case of
WAM addresses).</LI><LI CLASS="li-itemize"><I><TT>RA</TT></I> is a real address, its syntax is the syntax of C
integers (in particular the notation <TT>0x&#X2026;</TT> is recognized).</LI></UL><P>It is possible to only use the first letters of a commands and bank names
when there is no ambiguity. Also the square brackets <TT>[</TT> <TT>]</TT>
enclosing the index of a bank name can be omitted. For instance the
following command (showing the contents of 25 consecutive words of the
global stack from the index 3): <TT>data global[3] 25</TT> can be
abbreviated as: <TT>d g 3 25</TT>.</P><!--CUT END -->
<!--TOC section Format of definitions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc31">6</A>&#XA0;&#XA0;Format of definitions</H2><!--SEC END --><!--CUT DEF subsection 1 --><!--TOC subsection General format-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc32">6.1</A>&#XA0;&#XA0;General format</H3><!--SEC END --><P>
The definition of control constructs, directives and built-in predicates is
presented as follows:</P><P><B>Templates</B></P><P>Specifies the types of the arguments and which of them shall be instantiated
(mode). Types and modes are described later (section&#XA0;<A HREF="#Types-and-modes">6.2</A>).</P><P><B>Description</B></P><P>Describes the behavior (in the absence of any error conditions). It is
explicitly mentioned when a built-in predicate is re-executable on
backtracking. Predefined operators involved in the definition are also
mentioned.</P><P><B>Errors</B></P><P>Details the error conditions. Possible errors are detailed later
(section&#XA0;<A HREF="#Errors">6.3</A>). For directives, this part is omitted.</P><P><B>Portability</B></P><P>Specifies whether the definition conforms to the ISO standard or is a GNU Prolog
extension.</P><!--TOC subsection Types and modes-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc33">6.2</A>&#XA0;&#XA0;Types and modes</H3><!--SEC END --><P>
<A NAME="Types-and-modes"></A>
The templates part defines, for each argument of the concerned built-in
predicate, its mode and type. The mode specifies whether or not the argument
must be instantiated when the built-in predicate is called. The mode is
encoded with a symbol just before the type. Possible modes are:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>+</TT>: the argument must be instantiated.</LI><LI CLASS="li-itemize"><TT>-</TT>: the argument must be a variable (will be instantiated if
the built-in predicate succeeds).</LI><LI CLASS="li-itemize"><TT>?</TT>: the argument can be instantiated or a variable.</LI></UL><P>The type of an argument is defined by the following table:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left NOWRAP>
Type</TD><TD VALIGN=top ALIGN=left>Description</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT><I>TYPE</I>_list</TT></TD><TD VALIGN=top ALIGN=left>a list whose the type of each element is
<I><TT>TYPE</TT></I></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT><I>TYPE1</I>_or_<I>TYPE2</I></TT></TD><TD VALIGN=top ALIGN=left>a term whose type is either
<I><TT>TYPE1</TT></I> or <I><TT>TYPE2</TT></I></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>atom</TT></TD><TD VALIGN=top ALIGN=left>an atom</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>atom_property</TT></TD><TD VALIGN=top ALIGN=left>an atom property (section&#XA0;<A HREF="#atom-property/2">8.19.12</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>boolean</TT></TD><TD VALIGN=top ALIGN=left>the atom <TT>true</TT> or <TT>false</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>byte</TT></TD><TD VALIGN=top ALIGN=left>an integer &#X2265; 0 and &#X2264; 255</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>callable_term</TT></TD><TD VALIGN=top ALIGN=left>an atom or a compound term</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>character</TT></TD><TD VALIGN=top ALIGN=left>a single character atom</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>character_code</TT></TD><TD VALIGN=top ALIGN=left>an integer &#X2265; 1 and &#X2264; 255</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>clause</TT></TD><TD VALIGN=top ALIGN=left>a clause (fact or rule)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>close_option</TT></TD><TD VALIGN=top ALIGN=left>a close option (section&#XA0;<A HREF="#close/2">8.10.7</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>compound_term</TT></TD><TD VALIGN=top ALIGN=left>a compound term</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>evaluable</TT></TD><TD VALIGN=top ALIGN=left>an arithmetic expression (section&#XA0;<A HREF="#Evaluation-of-an-arithmetic-expression">8.6.1</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>fd_bool_evaluable</TT></TD><TD VALIGN=top ALIGN=left>a boolean FD expression (section&#XA0;<A HREF="#Boolean-FD-expressions">9.7.1</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>fd_labeling_option</TT></TD><TD VALIGN=top ALIGN=left>an FD labeling option (section&#XA0;<A HREF="#fd-labeling/2">9.9.1</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>fd_evaluable</TT></TD><TD VALIGN=top ALIGN=left>an arithmetic FD expression (section&#XA0;<A HREF="#FD-arithmetic-expressions">9.6.1</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>fd_variable</TT></TD><TD VALIGN=top ALIGN=left>an FD variable</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>flag</TT></TD><TD VALIGN=top ALIGN=left>a Prolog flag (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>float</TT></TD><TD VALIGN=top ALIGN=left>a floating point number</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>head</TT></TD><TD VALIGN=top ALIGN=left>a head of a clause (atom or compound term)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>integer</TT></TD><TD VALIGN=top ALIGN=left>an integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>in_byte</TT></TD><TD VALIGN=top ALIGN=left>an integer &#X2265; 0 and &#X2264; 255 or <TT>-1</TT> (for
the end-of-file)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>in_character</TT></TD><TD VALIGN=top ALIGN=left>a single character atom or the atom
<TT>end_of_file</TT> (for the end-of-file)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>in_character_code</TT></TD><TD VALIGN=top ALIGN=left>an integer &#X2265; 1 and &#X2264; 255 or
<TT>-1</TT> (for the end-of-file)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>io_mode</TT></TD><TD VALIGN=top ALIGN=left>an atom in: <TT>read</TT>, <TT>write</TT> or
<TT>append</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>list</TT></TD><TD VALIGN=top ALIGN=left>the empty list <TT>[]</TT> or a non-empty list
<TT>[_|_]</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>nonvar</TT></TD><TD VALIGN=top ALIGN=left>any term that is not a variable</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>number</TT></TD><TD VALIGN=top ALIGN=left>an integer or a floating point number</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>operator_specifier</TT></TD><TD VALIGN=top ALIGN=left>an operator specifier (section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>os_file_property</TT></TD><TD VALIGN=top ALIGN=left>an operating system file property (section&#XA0;<A HREF="#file-property/2">8.27.11</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>predicate_indicator</TT></TD><TD VALIGN=top ALIGN=left>a term <TT>Name/Arity</TT> where
<TT>Name</TT> is an atom and <TT>Arity</TT> an integer &#X2265; 0. A callable
term can be given if the <TT>strict_iso</TT> Prolog flag is switched
off (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>predicate_property</TT></TD><TD VALIGN=top ALIGN=left>a predicate property
(section&#XA0;<A HREF="#predicate-property/2">8.8.2</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>read_option</TT></TD><TD VALIGN=top ALIGN=left>a read option (section&#XA0;<A HREF="#read-term/3">8.14.1</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>socket_address</TT></TD><TD VALIGN=top ALIGN=left>a term of the form <TT>&#X2019;AF_UNIX&#X2019;(A)</TT> or
<TT>&#X2019;AF_INET&#X2019;(A,N)</TT> where <TT>A</TT> is an atom and <TT>N</TT> an
integer</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>socket_domain</TT></TD><TD VALIGN=top ALIGN=left>an atom in: <TT>&#X2019;AF_UNIX&#X2019;</TT> or
<TT>&#X2019;AF_INET&#X2019;</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>source_sink</TT></TD><TD VALIGN=top ALIGN=left>an atom identifying a source or a sink</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>stream</TT></TD><TD VALIGN=top ALIGN=left>a stream-term: a term of the form <TT>&#X2019;$stream&#X2019;(N)</TT>
where <TT>N</TT> is an integer &#X2265; 0</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>stream_option</TT></TD><TD VALIGN=top ALIGN=left>a stream option (section&#XA0;<A HREF="#open/4">8.10.6</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>stream_or_alias</TT></TD><TD VALIGN=top ALIGN=left>a stream-term or an alias (atom)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>stream_position</TT></TD><TD VALIGN=top ALIGN=left>a stream position: a term
<TT>&#X2019;$stream_position&#X2019;(I1, I2, I3, I4)</TT> where
<TT>I1</TT>, <TT>I2</TT>, <TT>I3</TT> and <TT>I4</TT> are integers</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>stream_property</TT></TD><TD VALIGN=top ALIGN=left>a stream property (section&#XA0;<A HREF="#stream-property/2">8.10.10</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>stream_seek_method</TT></TD><TD VALIGN=top ALIGN=left>an atom in: <TT>bof</TT>, <TT>current</TT>
or <TT>eof</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>term</TT></TD><TD VALIGN=top ALIGN=left>any term</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>var_binding_option</TT></TD><TD VALIGN=top ALIGN=left>a variable binding option
(section&#XA0;<A HREF="#bind-variables/2">8.5.3</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>write_option</TT></TD><TD VALIGN=top ALIGN=left>a write option (section&#XA0;<A HREF="#write-term/3">8.14.6</A>)</TD></TR>
</TABLE><!--TOC subsection Errors-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc34">6.3</A>&#XA0;&#XA0;Errors</H3><!--SEC END --><P>
<A NAME="Errors"></A></P><!--TOC subsubsection General format and error context-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc35">6.3.1</A>&#XA0;&#XA0;General format and error context</H4><!--SEC END --><P>
<A NAME="General-format-and-error-context"></A>
When an error occurs an exception of the form:
<TT>error(<I>ErrorTerm</I>, <I>Caller</I>)</TT> is raised.
<I><TT>ErrorTerm</TT></I> is a term specifying the error (detailed in next
sections) and <I><TT>Caller</TT></I> is a term specifying the context of
the error. The context is either the predicate indicator of the last invoked
built-in predicate or an atom giving general context information.</P><P>Using exceptions allows the user both to recover an error using
<TT>catch/3</TT> (section&#XA0;<A HREF="#catch/3">7.2.4</A>) and to raise an error using
<TT>throw/1</TT> (section&#XA0;<A HREF="#catch/3">7.2.4</A>).</P><P>To illustrate how to write error cases, let us write a predicate
<TT>my_pred(X)</TT> where <TT>X</TT> must be an integer:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">my_pred(X) :-
        (   nonvar(X) -&gt;
            true
        ;   throw(error(instantiation_error, my_pred/1)),
        ),
        (   integer(X) -&gt;
            true
        ;   throw(error(type_error(integer, X), my_pred/1))
        ),
        ...
</PRE></DD></DL><P>To help the user to write these error cases, a set of system predicates is
provided to raise errors. These predicates are of the form
<TT>&#X2019;$pl_err_...&#X2019;</TT> and they all refer to the implicit error context.
The predicates <TT>set_bip_name/2</TT> (section&#XA0;<A HREF="#set-bip-name/2">8.22.3</A>) and
<TT>current_bip_name/2</TT> (section&#XA0;<A HREF="#current-bip-name/2">8.22.4</A>) are provided to
set and recover the name and the arity associated with this context (an arity
&lt; 0 means that only the atom corresponding to the functor is significant).
Using these system predicates the user could define the above predicate as
follow:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">my_pred(X) :-
        set_bip_name(my_pred,1),
        (   nonvar(X) -&gt;
            true
        ;   '$pl_err_instantiation'
        ),
        (   integer(X) -&gt;
            true
        ;   '$pl_err_type'(integer, X)
        ),
        ...
</PRE></DD></DL><P>The following sections detail each kind of errors (and associated system
predicates).</P><!--TOC subsubsection Instantiation error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc36">6.3.2</A>&#XA0;&#XA0;Instantiation error</H4><!--SEC END --><P>
<A NAME="Instantiation-error"></A>
An instantiation error occurs when an argument or one of its components is
variable while an instantiated argument was expected.
<I><TT>ErrorTerm</TT></I> has the following form:
<TT>instantiation_error</TT>.</P><P>The system predicate <TT>&#X2019;$pl_err_instantiation&#X2019;</TT> raises this
error in the current error context (section&#XA0;<A HREF="#General-format-and-error-context">6.3.1</A>).</P><!--TOC subsubsection Uninstantiation error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc37">6.3.3</A>&#XA0;&#XA0;Uninstantiation error</H4><!--SEC END --><P>
<A NAME="Uninstantiation-error"></A>
An uninstantiation Error when an argument or one of its components is not a
variable, and a variable or a component as variable is required.
<I><TT>ErrorTerm</TT></I> has the following form:
<TT>uninstantiation_error(<I>Culprit</I>)</TT> where <I><TT>Culprit</TT></I> is the argument or one
of its components which caused the error.</P><P>The system predicate <TT>&#X2019;$pl_err_uninstantiation&#X2019;(Culprit)</TT> raises this
error in the current error context (section&#XA0;<A HREF="#General-format-and-error-context">6.3.1</A>).</P><!--TOC subsubsection Type error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc38">6.3.4</A>&#XA0;&#XA0;Type error</H4><!--SEC END --><P>
<A NAME="Type-error"></A>
A type error occurs when the type of an argument or one of its components is
not the expected type (but not a variable). <I><TT>ErrorTerm</TT></I> has
the following form: <TT>type_error(<I>Type</I>, <I>Culprit</I>)</TT> where
<I><TT>Type</TT></I> is the expected type and <I><TT>Culprit</TT></I>
the argument which caused the error. <I><TT>Type</TT></I> is one of:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>atom</TT></LI><LI CLASS="li-itemize"><TT>atomic</TT></LI><LI CLASS="li-itemize"><TT>boolean</TT></LI><LI CLASS="li-itemize"><TT>byte</TT></LI><LI CLASS="li-itemize"><TT>callable</TT></LI><LI CLASS="li-itemize"><TT>character</TT></LI><LI CLASS="li-itemize"><TT>compound</TT></LI><LI CLASS="li-itemize"><TT>evaluable</TT></LI><LI CLASS="li-itemize"><TT>fd_bool_evaluable</TT></LI><LI CLASS="li-itemize"><TT>fd_evaluable</TT></LI><LI CLASS="li-itemize"><TT>fd_variable</TT></LI><LI CLASS="li-itemize"><TT>float</TT></LI><LI CLASS="li-itemize"><TT>in_byte</TT></LI><LI CLASS="li-itemize"><TT>in_character</TT></LI><LI CLASS="li-itemize"><TT>integer</TT></LI><LI CLASS="li-itemize"><TT>list</TT></LI><LI CLASS="li-itemize"><TT>number</TT></LI><LI CLASS="li-itemize"><TT>pair</TT></LI><LI CLASS="li-itemize"><TT>predicate_indicator</TT></LI></UL><P>The system predicate <TT>&#X2019;$pl_err_type&#X2019;(Type, Culprit)</TT> raises this
error in the current error context (section&#XA0;<A HREF="#General-format-and-error-context">6.3.1</A>).</P><!--TOC subsubsection Domain error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc39">6.3.5</A>&#XA0;&#XA0;Domain error</H4><!--SEC END --><P>
<A NAME="Domain-error"></A>
A domain error occurs when the type of an argument is correct but its value
is outside the expected domain. <I><TT>ErrorTerm</TT></I> has the
following form: <TT>domain_error(<I>Domain</I>, <I>Culprit</I>)</TT>
where <I><TT>Domain</TT></I> is the expected domain and
<I><TT>Culprit</TT></I> the argument which caused the error.
<I><TT>Domain</TT></I> is one of:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>atom_property</TT></LI><LI CLASS="li-itemize"><TT>buffering_mode</TT></LI><LI CLASS="li-itemize"><TT>character_code_list</TT></LI><LI CLASS="li-itemize"><TT>close_option</TT></LI><LI CLASS="li-itemize"><TT>date_time</TT></LI><LI CLASS="li-itemize"><TT>eof_action</TT></LI><LI CLASS="li-itemize"><TT>fd_labeling_option</TT></LI><LI CLASS="li-itemize"><TT>flag_value</TT></LI><LI CLASS="li-itemize"><TT>format_control_sequence</TT></LI><LI CLASS="li-itemize"><TT>g_array_index</TT></LI><LI CLASS="li-itemize"><TT>io_mode</TT></LI><LI CLASS="li-itemize"><TT>non_empty_list</TT></LI><LI CLASS="li-itemize"><TT>not_less_than_zero</TT></LI><LI CLASS="li-itemize"><TT>operator_priority</TT></LI><LI CLASS="li-itemize"><TT>operator_specifier</TT></LI><LI CLASS="li-itemize"><TT>order</TT></LI><LI CLASS="li-itemize"><TT>os_file_permission</TT></LI><LI CLASS="li-itemize"><TT>os_file_property</TT></LI><LI CLASS="li-itemize"><TT>os_path</TT></LI><LI CLASS="li-itemize"><TT>predicate_property</TT></LI><LI CLASS="li-itemize"><TT>prolog_flag</TT></LI><LI CLASS="li-itemize"><TT>read_option</TT></LI><LI CLASS="li-itemize"><TT>selectable_item</TT></LI><LI CLASS="li-itemize"><TT>socket_address</TT></LI><LI CLASS="li-itemize"><TT>socket_domain</TT></LI><LI CLASS="li-itemize"><TT>source_sink</TT></LI><LI CLASS="li-itemize"><TT>statistics_key</TT></LI><LI CLASS="li-itemize"><TT>statistics_value</TT></LI><LI CLASS="li-itemize"><TT>stream</TT></LI><LI CLASS="li-itemize"><TT>stream_option</TT></LI><LI CLASS="li-itemize"><TT>stream_or_alias</TT></LI><LI CLASS="li-itemize"><TT>stream_position</TT></LI><LI CLASS="li-itemize"><TT>stream_property</TT></LI><LI CLASS="li-itemize"><TT>stream_seek_method</TT></LI><LI CLASS="li-itemize"><TT>stream_type</TT></LI><LI CLASS="li-itemize"><TT>term_stream_or_alias</TT></LI><LI CLASS="li-itemize"><TT>var_binding_option</TT></LI><LI CLASS="li-itemize"><TT>write_option</TT></LI></UL><P>The system predicate <TT>&#X2019;$pl_err_domain&#X2019;(Domain, Culprit)</TT> raises
this error in the current error context (section&#XA0;<A HREF="#General-format-and-error-context">6.3.1</A>).</P><!--TOC subsubsection Existence error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc40">6.3.6</A>&#XA0;&#XA0;Existence error</H4><!--SEC END --><P>
<A NAME="Existence-error"></A>
an existence error occurs when an object on which an operation is to be
performed does not exist. <I><TT>ErrorTerm</TT></I> has the following
form: <TT>existence_error(<I>Object</I>, <I>Culprit</I>)</TT> where
<I><TT>Object</TT></I> is the type of the object and
<I><TT>Culprit</TT></I> the argument which caused the error.
<I><TT>Object</TT></I> is one of:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>procedure</TT></LI><LI CLASS="li-itemize"><TT>source_sink</TT></LI><LI CLASS="li-itemize"><TT>stream</TT></LI></UL><P>The system predicate <TT>&#X2019;$pl_err_existence&#X2019;(Object, Culprit)</TT> raises
this error in the current error context (section&#XA0;<A HREF="#General-format-and-error-context">6.3.1</A>).</P><!--TOC subsubsection Permission error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc41">6.3.7</A>&#XA0;&#XA0;Permission error</H4><!--SEC END --><P>
<A NAME="Permission-error"></A>
A permission error occurs when an attempt to perform a prohibited operation
is made. <I><TT>ErrorTerm</TT></I> has the following form:
<TT>permission_error(<I>Operation</I>, <I>Permission</I>,
<I>Culprit</I>)</TT> where <I><TT>Operation</TT></I> is the operation which
caused the error, <I><TT>Permission</TT></I> the type of the tried
permission and <I><TT>Culprit</TT></I> the argument which caused the
error. <I><TT>Operation</TT></I> is one of:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>access</TT></LI><LI CLASS="li-itemize"><TT>add_alias</TT></LI><LI CLASS="li-itemize"><TT>close</TT></LI><LI CLASS="li-itemize"><TT>create</TT></LI><LI CLASS="li-itemize"><TT>input</TT></LI><LI CLASS="li-itemize"><TT>modify</TT></LI><LI CLASS="li-itemize"><TT>open</TT></LI><LI CLASS="li-itemize"><TT>output</TT></LI><LI CLASS="li-itemize"><TT>reposition</TT></LI></UL><P>and <I><TT>Permission</TT></I> is one of:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>binary_stream</TT></LI><LI CLASS="li-itemize"><TT>flag</TT></LI><LI CLASS="li-itemize"><TT>operator</TT></LI><LI CLASS="li-itemize"><TT>past_end_of_stream</TT></LI><LI CLASS="li-itemize"><TT>private_procedure</TT></LI><LI CLASS="li-itemize"><TT>source_sink</TT></LI><LI CLASS="li-itemize"><TT>static_procedure</TT></LI><LI CLASS="li-itemize"><TT>stream</TT></LI><LI CLASS="li-itemize"><TT>text_stream</TT></LI></UL><P>The system predicate <TT>&#X2019;$pl_err_permission&#X2019;(Operation, Permission,
Culprit)</TT> raises this error in the current error context (section&#XA0;<A HREF="#General-format-and-error-context">6.3.1</A>).</P><!--TOC subsubsection Representation error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc42">6.3.8</A>&#XA0;&#XA0;Representation error</H4><!--SEC END --><P>
<A NAME="Representation-error"></A>
A representation error occurs when an implementation limit has been
breached. <I><TT>ErrorTerm</TT></I> has the following form:
<TT>representation_error(<I>Limit</I>)</TT> where <I><TT>Limit</TT></I>
is the name of the reached limit. <I><TT>Limit</TT></I> is one of:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>character</TT></LI><LI CLASS="li-itemize"><TT>character_code</TT></LI><LI CLASS="li-itemize"><TT>in_character_code</TT></LI><LI CLASS="li-itemize"><TT>max_arity</TT></LI><LI CLASS="li-itemize"><TT>max_integer</TT></LI><LI CLASS="li-itemize"><TT>min_integer</TT></LI><LI CLASS="li-itemize"><TT>too_many_variables</TT></LI></UL><P>The errors <TT>max_integer</TT> and <TT>min_integer</TT> are not currently
implemented.</P><P>The system predicate <TT>&#X2019;$pl_err_representation&#X2019;(Limit)</TT> raises this
error in the current error context (section&#XA0;<A HREF="#General-format-and-error-context">6.3.1</A>).</P><!--TOC subsubsection Evaluation error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc43">6.3.9</A>&#XA0;&#XA0;Evaluation error</H4><!--SEC END --><P>
<A NAME="Evaluation-error"></A>
An evaluation error occurs when an arithmetic expression gives rise to
an exceptional value. <I><TT>ErrorTerm</TT></I> has the following form:
<TT>evaluation_error(<I>Error</I>)</TT> where <I><TT>Error</TT></I> is
the name of the error. <I><TT>Error</TT></I> is one of:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>float_overflow</TT></LI><LI CLASS="li-itemize"><TT>int_overflow</TT></LI><LI CLASS="li-itemize"><TT>undefined</TT></LI><LI CLASS="li-itemize"><TT>underflow</TT></LI><LI CLASS="li-itemize"><TT>zero_divisor</TT></LI></UL><P>The errors <TT>float_overflow</TT>, <TT>int_overflow</TT>,
<TT>undefined</TT> and <TT>underflow</TT> are not currently
implemented.</P><P>The system predicate <TT>&#X2019;$pl_err_evaluation&#X2019;(Error)</TT> raises this
error in the current error context (section&#XA0;<A HREF="#General-format-and-error-context">6.3.1</A>).</P><!--TOC subsubsection Resource error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc44">6.3.10</A>&#XA0;&#XA0;Resource error</H4><!--SEC END --><P>
<A NAME="Resource-error"></A>
A resource error occurs when GNU Prolog does not have enough resources.
<I><TT>ErrorTerm</TT></I> has the following form:
<TT>resource_error(<I>Resource</I>)</TT> where <I><TT>Resource</TT></I> is the
name of the resource. <I><TT>Resource</TT></I> is one of:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>print_object_not_linked</TT></LI><LI CLASS="li-itemize"><TT>too_big_fd_constraint</TT></LI></UL><P>The system predicate <TT>&#X2019;$pl_err_resource&#X2019;(Resource)</TT> raises this
error in the current error context (section&#XA0;<A HREF="#General-format-and-error-context">6.3.1</A>).</P><!--TOC subsubsection Syntax error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc45">6.3.11</A>&#XA0;&#XA0;Syntax error</H4><!--SEC END --><P>
<A NAME="Syntax-error"></A>
A syntax error occurs when a sequence of character does not conform to the
syntax of terms. <I><TT>ErrorTerm</TT></I> has the following form:
<TT>syntax_error(<I>Error</I>)</TT> where <I><TT>Error</TT></I> is an
atom explaining the error.</P><P>The system predicate <TT>&#X2019;$pl_err_syntax&#X2019;(Error)</TT> raises this
error in the current error context (section&#XA0;<A HREF="#General-format-and-error-context">6.3.1</A>).</P><!--TOC subsubsection System error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc46">6.3.12</A>&#XA0;&#XA0;System error</H4><!--SEC END --><P>
A system error can occur at any stage. A system error is generally
associated with an external component (e.g. operating system).
<I><TT>ErrorTerm</TT></I> has the following form:
<TT>system_error(<I>Error</I>)</TT> where <I><TT>Error</TT></I> is an
atom explaining the error. This is an extension to ISO which only defines
<TT>system_error</TT> without arguments.</P><P>The system predicate <TT>&#X2019;$pl_err_system&#X2019;(Error)</TT> raises this
error in the current error context (section&#XA0;<A HREF="#General-format-and-error-context">6.3.1</A>).</P><!--CUT END -->
<!--TOC section Prolog directives and control constructs-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc47">7</A>&#XA0;&#XA0;Prolog directives and control constructs</H2><!--SEC END --><!--CUT DEF subsection 1 --><!--TOC subsection Prolog directives-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc48">7.1</A>&#XA0;&#XA0;Prolog directives</H3><!--SEC END --><!--TOC subsubsection Introduction-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc49">7.1.1</A>&#XA0;&#XA0;Introduction</H4><!--SEC END --><P>
Prolog directives are annotations inserted in Prolog source files for the
compiler. A Prolog directive is used to specify:</P><UL CLASS="itemize"><LI CLASS="li-itemize">the properties of some procedures defined in the source file.</LI><LI CLASS="li-itemize">the format and the syntax for read-terms in the source file (using
changeable Prolog flags).</LI><LI CLASS="li-itemize">included source files.</LI><LI CLASS="li-itemize">a goal to be executed at run-time.</LI></UL><!--TOC subsubsection <TT>dynamic/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc50">7.1.2</A>&#XA0;&#XA0;<TT>dynamic/1</TT></H4><!--SEC END --><P>
<A NAME="dynamic/1"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
dynamic(+predicate_indicator)<BR>
dynamic(+predicate_indicator_list)<BR>
dynamic(+predicate_indicator_sequence)</TT></DD></DL><P><B>Description</B></P><P><TT>dynamic(Pred)</TT> specifies that the procedure whose
predicate indicator is <TT>Pred</TT> is a dynamic procedure. This directive
makes it possible to alter the definition of <TT>Pred</TT> by adding or
removing clauses. For more information refer to the section about dynamic
clause management (section&#XA0;<A HREF="#Introduction:(Dynamic-clause-management)">8.7.1</A>).</P><P>This directive shall precede the definition of <TT>Pred</TT> in the source
file.</P><P>If there is no clause for <TT>Pred</TT> in the source file, <TT>Pred</TT>
exists however as an empty predicate (this means that
<TT>current_predicate(Pred)</TT> succeeds).</P><P>In order to allow multiple definitions, <TT>Pred</TT> can also be a list of
predicate indicators or a sequence of predicate indicators using
<TT>&#X2019;,&#X2019;/2</TT> as separator.</P><P><B>Portability</B></P><P>ISO directive.</P><!--TOC subsubsection <TT>public/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc51">7.1.3</A>&#XA0;&#XA0;<TT>public/1</TT></H4><!--SEC END --><P>
<A NAME="public/1"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
public(+predicate_indicator)<BR>
public(+predicate_indicator_list)<BR>
public(+predicate_indicator_sequence)</TT></DD></DL><P><B>Description</B></P><P><TT>public(Pred)</TT> specifies that the procedure whose predicate indicator
is <TT>Pred</TT> is a public procedure. This directive makes it possible to
inspect the clauses of <TT>Pred</TT>. For more information refer to the
section about dynamic clause management (section&#XA0;<A HREF="#Introduction:(Dynamic-clause-management)">8.7.1</A>).</P><P>This directive shall precede the definition of <TT>Pred</TT> in the source
file. Since a dynamic procedure is also public. It is useless (but correct)
to define a public directive for a predicate already declared as dynamic.</P><P>In order to allow multiple definitions, <TT>Pred</TT> can also be a list of
predicate indicators or a sequence of predicate indicators using
<TT>&#X2019;,&#X2019;/2</TT> as separator.</P><P><B>Portability</B></P><P>GNU Prolog directive. The ISO reference does not define any directive to
declare a predicate public but it does distinguish public predicates. It is
worth noting that in most Prolog systems the <TT>public/1</TT> directive is
as a visibility declaration. Indeed, declaring a predicate as public makes
it visible from any predicate defined in any other file (otherwise the
predicate is only visible from predicates defined in the same source file as
itself). When a module system is incorporated in GNU Prolog a more general
visibility declaration shall be provided conforming to the ISO reference.</P><!--TOC subsubsection <TT>multifile/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc52">7.1.4</A>&#XA0;&#XA0;<TT>multifile/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
multifile(+predicate_indicator)<BR>
multifile(+predicate_indicator_list)<BR>
multifile(+predicate_indicator_sequence)</TT></DD></DL><P><B>Description</B></P><P><TT>multifile(Pred)</TT> specifies that the procedure whose predicate
indicator is <TT>Pred</TT> is a multifle procedure (the clauses of
<TT>Pred</TT> can reside in several source files). This directive is only
supported by GNU Prolog since version 1.4.0.</P><P><B>Portability</B></P><P>ISO directive.</P><!--TOC subsubsection <TT>discontiguous/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc53">7.1.5</A>&#XA0;&#XA0;<TT>discontiguous/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
discontiguous(+predicate_indicator)<BR>
discontiguous(+predicate_indicator_list)<BR>
discontiguous(+predicate_indicator_sequence)</TT></DD></DL><P><B>Description</B></P><P><TT>discontiguous(Pred)</TT> specifies that the procedure whose predicate
indicator is <TT>Pred</TT> is a discontiguous procedure. Namely, the clauses
defining <TT>Pred</TT> are not restricted to be consecutive but can appear
anywhere in the source file.</P><P>This directive shall precede the definition of <TT>Pred</TT> in the source
file.</P><P>In order to allow multiple definitions, <TT>Pred</TT> can also be a list of
predicate indicators or a sequence of predicate indicators using
<TT>&#X2019;,&#X2019;/2</TT> as separator.</P><P>A multifile predicate cannot be directly called from a file where it is not
declared as multifile (the native compiler must know the called predicate is
multifile). Workarounds: either call it via a meta-call (e.g. using
<TT>call/1</TT>) or declare it as multifile in the calling source file). A
good habit is to encapsulate a multifile predicate in a monofile predicate
which invokes it (external call only invoke the monofile wrapper predicate).</P><P><B>Portability</B></P><P>ISO directive. </P><!--TOC subsubsection <TT>ensure_linked/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc54">7.1.6</A>&#XA0;&#XA0;<TT>ensure_linked/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
ensure_linked(+predicate_indicator)<BR>
ensure_linked(+predicate_indicator_list)<BR>
ensure_linked(+predicate_indicator_sequence)</TT></DD></DL><P><B>Description</B></P><P><TT>ensure_linked(Pred)</TT> specifies that the procedure
whose predicate indicator is <TT>Pred</TT> must be included by the linker.
This directive is useful when compiling to native code to force the linker to
include the code of a given predicate. Indeed, if the <TT>gplc</TT> is
invoked with an option to reduce the size of the executable
(section&#XA0;<A HREF="#Using-the-compiler">4.4.3</A>), the linker only includes the code of predicates
that are statically referenced. However, the linker cannot detect dynamically
referenced predicates (used as data passed to a meta-call predicate). The use
of this directive prevents it to exclude the code of such predicates.</P><P>In order to allow multiple definitions, <TT>Pred</TT> can also be a list of
predicate indicators or a sequence of predicate indicators using
<TT>&#X2019;,&#X2019;/2</TT> as separator.</P><P><B>Portability</B></P><P>GNU Prolog directive.</P><!--TOC subsubsection <TT>built_in/0</TT>,
<TT>built_in/1</TT>,
<TT>built_in_fd/0</TT>,
<TT>built_in_fd/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc55">7.1.7</A>&#XA0;&#XA0;<TT>built_in/0</TT>,
<TT>built_in/1</TT>,
<TT>built_in_fd/0</TT>,
<TT>built_in_fd/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
built_in<BR>
built_in(+predicate_indicator)<BR>
built_in(+predicate_indicator_list)<BR>
built_in(+predicate_indicator_sequence)<BR>
built_in_fd<BR>
built_in_fd(+predicate_indicator)<BR>
built_in_fd(+predicate_indicator_list)<BR>
built_in_fd(+predicate_indicator_sequence)</TT></DD></DL><P><B>Description</B></P><P><TT>built_in</TT> specifies that the procedures defined from
now have the <TT>built_in</TT> property (section&#XA0;<A HREF="#predicate-property/2">8.8.2</A>).</P><P><TT>built_in(Pred)</TT> is similar to <TT>built_in/0</TT> but
only affects the procedure whose predicate indicator is <TT>Pred</TT>.</P><P>This directive shall precede the definition of <TT>Pred</TT> in the source
file.</P><P>In order to allow multiple definitions, <TT>Pred</TT> can also be a list of
predicate indicators or a sequence of predicate indicators using
<TT>&#X2019;,&#X2019;/2</TT> as separator.</P><P><TT>built_in_fd</TT> (resp.
<TT>built_in_fd(Pred)</TT>) is similar to
<TT>built_in</TT> (resp. <TT>built_in(Pred)</TT>) but sets the
<TT>built_in_fd</TT> predicate property (section&#XA0;<A HREF="#predicate-property/2">8.8.2</A>).</P><P><B>Portability</B></P><P>GNU Prolog directives.</P><!--TOC subsubsection <TT>include/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc56">7.1.8</A>&#XA0;&#XA0;<TT>include/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
include(+atom)</TT></DD></DL><P><B>Description</B></P><P><TT>include(File)</TT> specifies that the content of the Prolog source
<TT>File</TT> shall be inserted. The resulting Prolog text is identical to
the Prolog text obtained by replacing the directive by the content of the
Prolog source <TT>File</TT>.</P><P>See <TT>absolute_file_name/2</TT> for information about the syntax of
<TT>File</TT> (section&#XA0;<A HREF="#absolute-file-name/2">8.26.1</A>).</P><P><B>Portability</B></P><P>ISO directive.</P><!--TOC subsubsection <TT>if/1</TT>, <TT>else/0</TT>, <TT>endif/0</TT>, <TT>elif/1</TT> -->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc57">7.1.9</A>&#XA0;&#XA0;<TT>if/1</TT>, <TT>else/0</TT>, <TT>endif/0</TT>, <TT>elif/1</TT> </H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
if(+callable_term)<BR>
else<BR>
endif<BR>
elif(+callable_term)</TT></DD></DL><P><B>Description</B></P><P>These directives are for conditional compilation.</P><P><TT>if(Goal)</TT> compile subsequent code only if <TT>Goal</TT>
succeeds. <TT>Goal</TT> is first processed by <TT>expand_term/2</TT>
(section&#XA0;<A HREF="#expand-term/2">8.17.2</A>). If <TT>Goal</TT> raises an exception it is printed
and <TT>Goal</TT> fails.</P><P><TT>else</TT> introduces the <I>else</I> part.</P><P><TT>endif</TT> terminates a conditional compilation part.</P><P><TT>elif(Goal)</TT> is a shorthand for <TT>:- else. :- if(Goal). &#X2026; :- endif</TT>.</P><P><B>Portability</B></P><P>GNU Prolog directive. Also in SWI and YAP.</P><!--TOC subsubsection <TT>ensure_loaded/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc58">7.1.10</A>&#XA0;&#XA0;<TT>ensure_loaded/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
ensure_loaded(+atom)</TT></DD></DL><P><B>Description</B></P><P><TT>ensure_loaded(File)</TT> is not supported by GNU Prolog. When such a
directive is encountered it is simply ignored.</P><P><B>Portability</B></P><P>ISO directive. Not supported.</P><!--TOC subsubsection <TT>op/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc59">7.1.11</A>&#XA0;&#XA0;<TT>op/3</TT></H4><!--SEC END --><P>
<A NAME="op/3"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
op(+integer, +operator_specifier, +atom_or_atom_list)</TT></DD></DL><P><B>Description</B></P><P><TT>op(Priority, OpSpecifier, Operator)</TT> alters the operator table. This
directive is executed as soon as it is encountered by calling the built-in
predicate <TT>op/3</TT> (section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>). A system
directive is also generated to reflect the effect of this directive at
run-time (section&#XA0;<A HREF="#Running-an-executable">4.4.4</A>).</P><P><B>Portability</B></P><P>ISO directive.</P><!--TOC subsubsection <TT>char_conversion/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc60">7.1.12</A>&#XA0;&#XA0;<TT>char_conversion/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
char_conversion(+character, +character)</TT></DD></DL><P><B>Description</B></P><P><TT>char_conversion(InChar, OutChar)</TT> alters the character-conversion
mapping. This directive is executed as soon as it is encountered by a call
to the built-in predicate <TT>char_conversion/2</TT>
(section&#XA0;<A HREF="#char-conversion/2">8.14.12</A>). A system directive is also generated to reflect
the effect of this directive at run-time (section&#XA0;<A HREF="#Running-an-executable">4.4.4</A>).</P><P><B>Portability</B></P><P>ISO directive.</P><!--TOC subsubsection <TT>set_prolog_flag/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc61">7.1.13</A>&#XA0;&#XA0;<TT>set_prolog_flag/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
set_prolog_flag(+flag, +term)</TT></DD></DL><P><B>Description</B></P><P><TT>set_prolog_flag(Flag, Value)</TT> sets the value of the
Prolog flag <TT>Flag</TT> to <TT>Value</TT>. This directive is
executed as soon as it is encountered by a call to the built-in predicate
<TT>set_prolog_flag/2</TT> (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>). A system directive
is also generated to reflect the effect of this directive at run-time
(section&#XA0;<A HREF="#Running-an-executable">4.4.4</A>).</P><P><B>Portability</B></P><P>ISO directive.</P><!--TOC subsubsection <TT>initialization/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc62">7.1.14</A>&#XA0;&#XA0;<TT>initialization/1</TT></H4><!--SEC END --><P>
<A NAME="initialization/1"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
initialization(+callable_term)</TT></DD></DL><P><B>Description</B></P><P><TT>initialization(Goal)</TT> adds <TT>Goal</TT> to the set of goal which
shall be executed at run-time. A user directive is generated to execute
<TT>Goal</TT> at run-time. If several initialization directives appear in
the same file they are executed in the order of appearance
(section&#XA0;<A HREF="#Running-an-executable">4.4.4</A>).</P><P><B>Portability</B></P><P>ISO directive.</P><!--TOC subsubsection <TT>foreign/2</TT>,
<TT>foreign/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc63">7.1.15</A>&#XA0;&#XA0;<TT>foreign/2</TT>,
<TT>foreign/1</TT></H4><!--SEC END --><P>
<A NAME="foreign/2"></A>

</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
foreign(+callable_term, +foreign_option_list)<BR>
foreign(+callable_term)</TT></DD></DL><P><B>Description</B></P><P><TT>foreign(Template, Options)</TT> defines an interface predicate whose
prototype is <TT>Template</TT> according to the options given by
<TT>Options</TT>. Refer to the foreign code interface for more information
(section&#XA0;<A HREF="#Calling-C-from-Prolog">10.3</A>).</P><P><TT>foreign(Template)</TT> is equivalent to <TT>foreign(Template, [])</TT>.</P><P><B>Portability</B></P><P>GNU Prolog directive.</P><!--TOC subsection Prolog control constructs-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc64">7.2</A>&#XA0;&#XA0;Prolog control constructs</H3><!--SEC END --><P>
<A NAME="control-construct"></A></P><P>GNU Prolog follows the ISO notion of control constructs. </P><!--TOC subsubsection <TT>true/0</TT>,
<TT>fail/0</TT>,
<TT>!/0</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc65">7.2.1</A>&#XA0;&#XA0;<TT>true/0</TT>,
<TT>fail/0</TT>,
<TT>!/0</TT></H4><!--SEC END --><P>
<A NAME="true/0"></A>


</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
true<BR>
fail<BR>
!</TT></DD></DL><P><B>Description</B></P><P><TT>true</TT> always succeeds.</P><P><TT>fail</TT> always fails (enforces backtracking).</P><P><TT>!</TT> always succeeds and the for side-effect of removing all
choice-points created since the invocation of the predicate activating it.</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>ISO control constructs.</P><!--TOC subsubsection <TT>(&#X2019;,&#X2019;)/2</TT> - conjunction,
<TT>(;)/2</TT> - disjunction,
<TT>(-</TT><TT>&gt;</TT><TT>)/2</TT> - if-then,
<TT>(*-</TT><TT>&gt;</TT><TT>)/2</TT> - soft-cut (soft if-then)-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc66">7.2.2</A>&#XA0;&#XA0;<TT>(&#X2019;,&#X2019;)/2</TT> - conjunction,
<TT>(;)/2</TT> - disjunction,
<TT>(-&gt;)/2</TT> - if-then,
<TT>(*-&gt;)/2</TT> - soft-cut (soft if-then)</H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
&#X2019;,&#X2019;(+callable_term, +callable_term)<BR>
;(+callable_term, +callable_term)<BR>
-&gt;(+callable_term, +callable_term)<BR>
*-&gt;(+callable_term, +callable_term)</TT></DD></DL><P><B>Description</B></P><P><TT>Goal1 , Goal2</TT> executes <TT>Goal1</TT> and, in case of
success, executes <TT>Goal2</TT>.</P><P><TT>Goal1 ; Goal2</TT> first creates a choice-point and executes
<TT>Goal1</TT>. On backtracking <TT>Goal2</TT> is executed.</P><P><TT>Goal1 -&gt; Goal2</TT> first executes <TT>Goal1</TT> and,
in case of success, removes all choice-points created by <TT>Goal1</TT> and
executes <TT>Goal2</TT>. This control construct acts like an if-then
(<TT>Goal1</TT> is the test part and <TT>Goal2</TT> the then part). Note that
if <TT>Goal1</TT> fails <TT>-&gt;/2</TT> fails also. <TT>-&gt;/2</TT> is
often combined with <TT>;/2</TT> to define an if-then-else as follows:
<TT>Goal1 -&gt; Goal2 ; Goal3</TT>. Note that <TT>Goal1 -&gt; Goal2</TT>
is the first argument of the <TT>(;)/2</TT> and <TT>Goal3</TT> (the else
part) is the second argument. Such an if-then-else control construct first
creates a choice-point for the else-part (intuitively associated with
<TT>;/2</TT>) and then executes <TT>Goal1</TT>. In case of success, all
choice-points created by <TT>Goal1</TT> together with the choice-point for
the else-part are removed and <TT>Goal2</TT> is executed. If <TT>Goal1</TT>
fails then <TT>Goal3</TT> is executed.</P><P><TT>Goal1 *-&gt; Goal2 ; Goal3</TT> implements the so-called
soft-cut. It acts as the above if-then-else except that if
<TT>Goal1</TT> succeeds only <TT>Goal3</TT> is cut (the alternative solutions
of <TT>Goal1</TT> are preserved and can be found by backtracking). Note that
<TT>Goal1 *-&gt; Goal2</TT> alone (i.e. without an else branch
<TT>Goal3</TT>) is equivalent to <TT>(Goal1 , Goal2)</TT>.</P><P><TT>&#X2019;,&#X2019;</TT>, <TT>;</TT>, <TT>-&gt;</TT> and <TT>*-&gt;</TT> are predefined
infix operators (section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Goal1</TT> or <TT>Goal2</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Goal1</TT> is neither a variable nor a callable term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(callable, Goal1)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Goal2</TT> is neither a variable nor a callable term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(callable, Goal2)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
The predicate indicator <TT>Pred</TT> of <TT>Goal1</TT> or
<TT>Goal2</TT> does not correspond to an existing procedure and the value of
the <TT>unknown</TT> Prolog flag is <TT>error</TT> (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(procedure, Pred)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO control constructs except <TT>(*-&gt;)/2</TT> which is GNU Prolog specific.</P><!--TOC subsubsection <TT>call/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc67">7.2.3</A>&#XA0;&#XA0;<TT>call/1</TT></H4><!--SEC END --><P>
<A NAME="call/1"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
call(+callable_term)</TT></DD></DL><P><B>Description</B></P><P><TT>call(Goal)</TT> executes <TT>Goal</TT>. <TT>call/1</TT> succeeds if
<TT>Goal</TT> represents a goal which is true. When <TT>Goal</TT> contains a
cut symbol <TT>!</TT> (section&#XA0;<A HREF="#true/0">7.2.1</A>) as a subgoal, the effect of
<TT>!</TT> does not extend outside <TT>Goal</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Goal</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Goal</TT> is neither a variable nor a callable term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(callable, Goal)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
The predicate indicator <TT>Pred</TT> of <TT>Goal</TT> does not
correspond to an existing procedure and the value of the <TT>unknown</TT>
Prolog flag is <TT>error</TT> (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(procedure, Pred)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO control construct.</P><!--TOC subsubsection <TT>catch/3</TT>,
<TT>throw/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc68">7.2.4</A>&#XA0;&#XA0;<TT>catch/3</TT>,
<TT>throw/1</TT></H4><!--SEC END --><P>
<A NAME="catch/3"></A>

</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
catch(?callable_term, ?term, ?term)<BR>
throw(+nonvar)</TT></DD></DL><P><B>Description</B></P><P><TT>catch(Goal, Catcher, Recovery)</TT> is similar to <TT>call(Goal)</TT>
(section&#XA0;<A HREF="#call/1">7.2.3</A>). If this succeeds or fails, so does the call to
<TT>catch/3</TT>. If however, during the execution of <TT>Goal</TT>, there
is a call to <TT>throw(Ball)</TT>, the current flow of control is
interrupted, and control returns to a call of <TT>catch/3</TT> that is being
executed. This can happen in one of two ways:</P><UL CLASS="itemize"><LI CLASS="li-itemize">implicitly, when an error condition for a built-in predicate is
satisfied.</LI><LI CLASS="li-itemize">explicitly, when the program executes a call of <TT>throw/1</TT>
because the program wishes to abandon the current processing, and instead to
take an alternative action.</LI></UL><P><TT>throw(Ball)</TT> causes the normal flow of control to be transferred
back to an existing call of <TT>catch/3</TT>. When a call to
<TT>throw(Ball)</TT> happens, <TT>Ball</TT> is copied and the stack is
unwound back to the call to <TT>catch/3</TT>, whereupon the copy of
<TT>Ball</TT> is unified with <TT>Catcher</TT>. If this unification
succeeds, then <TT>catch/3</TT> executes the goal <TT>Recovery</TT> using
<TT>call/1</TT> (section&#XA0;<A HREF="#call/1">7.2.3</A>) in order to determine the success or
failure of <TT>catch/3</TT>. Otherwise, in case the unification fails,
the stack keeps unwinding, looking for an earlier invocation of
<TT>catch/3</TT>. <TT>Ball</TT> may be any non-variable term.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Ball</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P>If <TT>Ball</TT> does not unify with the <TT>Catcher</TT> argument of
any call of <TT>catch/3</TT>, a system error message is displayed and
<TT>throw/1</TT> fails.</P><P>When <TT>catch/3</TT> calls <TT>Goal</TT> or <TT>Recovery</TT> it uses <TT>call/1</TT>
(section&#XA0;<A HREF="#call/1">7.2.3</A>), an <TT>instantiation_error</TT>, a <TT>type_error</TT>
or an <TT>existence_error</TT> can then occur depending on
<TT>Goal</TT> or <TT>Recovery</TT>.</P><P><B>Portability</B></P><P>ISO control constructs.</P><!--CUT END -->
<!--TOC section Prolog built-in predicates-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc69">8</A>&#XA0;&#XA0;Prolog built-in predicates</H2><!--SEC END --><!--CUT DEF subsection 1 --><!--TOC subsection Type testing-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc70">8.1</A>&#XA0;&#XA0;Type testing</H3><!--SEC END --><!--TOC subsubsection <TT>var/1</TT>,
<TT>nonvar/1</TT>,
<TT>atom/1</TT>,
<TT>integer/1</TT>,
<TT>float/1</TT>,
<TT>number/1</TT>,
<TT>atomic/1</TT>,<BR>
 <TT>compound/1</TT>,
<TT>callable/1</TT>,
<TT>ground/1</TT>,
<TT>is_list/1</TT>,
<TT>list/1</TT>,
<TT>partial_list/1</TT>,
<TT>list_or_partial_list/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc71">8.1.1</A>&#XA0;&#XA0;<TT>var/1</TT>,
<TT>nonvar/1</TT>,
<TT>atom/1</TT>,
<TT>integer/1</TT>,
<TT>float/1</TT>,
<TT>number/1</TT>,
<TT>atomic/1</TT>,<BR>
 <TT>compound/1</TT>,
<TT>callable/1</TT>,
<TT>ground/1</TT>,
<TT>is_list/1</TT>,
<TT>list/1</TT>,
<TT>partial_list/1</TT>,
<TT>list_or_partial_list/1</TT></H4><!--SEC END --><P>
<A NAME="var/1"></A>













</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
var(?term)<BR>
nonvar(?term)<BR>
atom(?term)<BR>
integer(?term)<BR>
float(?term)<BR>
number(?term)<BR>
atomic(?term)<BR>
compound(?term)<BR>
callable(?term)<BR>
ground(?term)<BR>
is_list(?term)<BR>
list(?term)<BR>
partial_list(?term)<BR>
list_or_partial_list(?term)</TT></DD></DL><P><B>Description</B></P><P><TT>var(Term)</TT> succeeds if <TT>Term</TT> is currently
uninstantiated (which therefore has not been bound to anything, except
possibly another uninstantiated variable).</P><P><TT>nonvar(Term)</TT> succeeds if <TT>Term</TT> is currently instantiated
(opposite of <TT>var/1</TT>).</P><P><TT>atom(Term)</TT> succeeds if <TT>Term</TT> is currently instantiated
to an atom.</P><P><TT>integer(Term)</TT> succeeds if <TT>Term</TT> is currently
instantiated to an integer.</P><P><TT>float(Term)</TT> succeeds if <TT>Term</TT> is currently instantiated
to a floating point number.</P><P><TT>number(Term)</TT> succeeds if <TT>Term</TT> is currently instantiated
to an integer or a floating point number.</P><P><TT>atomic(Term)</TT> succeeds if <TT>Term</TT> is currently instantiated
to an atom, an integer or a floating point number.</P><P><TT>compound(Term)</TT> succeeds if <TT>Term</TT> is currently
instantiated to a compound term, i.e. a term of arity &gt; 0 (a list or a
structure).</P><P><TT>callable(Term)</TT> succeeds if <TT>Term</TT> is currently
instantiated to a callable term, i.e. an atom or a compound term.</P><P><TT>ground(Term)</TT> succeeds if <TT>Term</TT> is a ground term.</P><P><TT>list(Term)</TT> succeeds if <TT>Term</TT> is currently instantiated
to a list, i.e. the atom <TT>[]</TT> (empty list) or a term with principal
functor <TT>&#X2019;.&#X2019;/2</TT> and with second argument (the tail) a list.</P><P><TT>is_list(Term)</TT> behaves like <TT>list(Term)</TT> (for compatibility
purpose).</P><P><TT>partial_list(Term)</TT> succeeds if <TT>Term</TT> is currently
instantiated to a partial list, i.e. a variable or a term whose the main
functor is <TT>&#X2019;.&#X2019;/2</TT> and the second argument (the tail) is a partial
list.</P><P><TT>list_or_partial_list(Term)</TT> succeeds if <TT>Term</TT> is
currently instantiated to a list or a partial list.</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P><TT>var/1</TT>, <TT>nonvar/1</TT>, <TT>atom/1</TT>, <TT>integer/1</TT>,
<TT>float/1</TT>, <TT>number/1</TT>, <TT>atomic/1</TT>, <TT>compound/1</TT>
<TT>callable/1</TT> and <TT>ground/1</TT> are ISO predicates.</P><P><TT>list/1</TT>, <TT>partial_list/1</TT> and
<TT>list_or_partial_list/1</TT> are GNU Prolog predicates.</P><!--TOC subsection Term unification-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc72">8.2</A>&#XA0;&#XA0;Term unification</H3><!--SEC END --><!--TOC subsubsection <TT>(=)/2</TT> - Prolog unification-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc73">8.2.1</A>&#XA0;&#XA0;<TT>(=)/2</TT> - Prolog unification</H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
=(?term, ?term)</TT></DD></DL><P><B>Description</B></P><P><TT>Term1 = Term2</TT> unifies <TT>Term1</TT> and <TT>Term2</TT>. No occurs
check is done, i.e. this predicate does not check if a variable is unified
with a compound term containing this variable (this can lead to an infinite
loop).</P><P><TT>=</TT> is a predefined infix operator (section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>unify_with_occurs_check/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc74">8.2.2</A>&#XA0;&#XA0;<TT>unify_with_occurs_check/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
unify_with_occurs_check(?term, ?term)
</TT></DD></DL><P><B>Description</B></P><P><TT>unify_with_occurs_check(Term1, Term2)</TT> unifies <TT>Term1</TT> and
<TT>Term2</TT>. The occurs check test is done (i.e. the unification fails if
a variable is unified with a compound term containing this variable).</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>(</TT><TT>\</TT><TT>=)/2</TT> - not Prolog unifiable-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc75">8.2.3</A>&#XA0;&#XA0;<TT>(\=)/2</TT> - not Prolog unifiable</H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
\=(?term, ?term)
</TT></DD></DL><P><B>Description</B></P><P><TT>Term1 \= Term2</TT> succeeds if <TT>Term1</TT> and <TT>Term2</TT>
are not unifiable (no occurs check is done).</P><P><TT>\=</TT> is a predefined infix operator (section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsection Term comparison-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc76">8.3</A>&#XA0;&#XA0;Term comparison</H3><!--SEC END --><!--TOC subsubsection Standard total ordering of terms-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc77">8.3.1</A>&#XA0;&#XA0;Standard total ordering of terms</H4><!--SEC END --><P>
<A NAME="Standard-total-ordering-of-terms"></A>
The built-in predicates described in this section allows the user to compare
Prolog terms. Prolog terms are totally ordered according to the standard
total ordering of terms which is as follows (from the smallest term to the
greatest):</P><UL CLASS="itemize"><LI CLASS="li-itemize">variables, oldest first.</LI><LI CLASS="li-itemize">finite domain variables (section&#XA0;<A HREF="#Finite-Domain-variables">9.1.1</A>), oldest
first.</LI><LI CLASS="li-itemize">floating point numbers, in numeric order.</LI><LI CLASS="li-itemize">integers, in numeric order.</LI><LI CLASS="li-itemize">atoms, in alphabetical (i.e. character code) order.</LI><LI CLASS="li-itemize">compound terms, ordered first by arity, then by the name of the
principal functor and by the arguments in left-to-right order.</LI></UL><P>A list is treated as a compound term (whose principal functor is
<TT>&#X2019;.&#X2019;/2</TT>).</P><P>The portability of the order of variables is not guaranteed (in the ISO
reference the order of variables is system dependent).</P><!--TOC subsubsection <TT>(==)/2</TT> - term identical,
<TT>(</TT><TT>\</TT><TT>==)/2</TT> - term not identical,<BR>
 <TT>(@</TT><TT>&lt;</TT><TT>)/2</TT> - term less than,
<TT>(@=</TT><TT>&lt;</TT><TT>)/2</TT> - term less than or equal to,<BR>
 <TT>(@</TT><TT>&gt;</TT><TT>)/2</TT> - term greater than,
<TT>(@</TT><TT>&gt;</TT><TT>=)/2</TT> - term greater than or equal to-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc78">8.3.2</A>&#XA0;&#XA0;<TT>(==)/2</TT> - term identical,
<TT>(\==)/2</TT> - term not identical,<BR>
 <TT>(@&lt;)/2</TT> - term less than,
<TT>(@=&lt;)/2</TT> - term less than or equal to,<BR>
 <TT>(@&gt;)/2</TT> - term greater than,
<TT>(@&gt;=)/2</TT> - term greater than or equal to</H4><!--SEC END --><P>
<A NAME="(==)/2"></A>





</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
==(?term, ?term)<BR>
\==(?term, ?term)<BR>
@&lt;(?term, ?term)<BR>
@=&lt;(?term, ?term)<BR>
@&gt;(?term, ?term)<BR>
@&gt;=(?term, ?term)</TT></DD></DL><P><B>Description</B></P><P>These predicates compare two terms according to the standard total ordering
of terms (section&#XA0;<A HREF="#Standard-total-ordering-of-terms">8.3.1</A>).</P><P><TT>Term1 == Term2</TT> succeeds if <TT>Term1</TT> and <TT>Term2</TT> are
equal.</P><P><TT>Term1 \== Term2</TT> succeeds if <TT>Term1</TT> and
<TT>Term2</TT> are different.</P><P><TT>Term1 @&lt; Term2</TT> succeeds if <TT>Term1</TT> is less than
<TT>Term2</TT>.</P><P><TT>Term1 @=&lt; Term2</TT> succeeds if <TT>Term1</TT> is less than or
equal to <TT>Term2</TT>.</P><P><TT>Term1 @&gt; Term2</TT> succeeds if <TT>Term1</TT> is greater than
<TT>Term2</TT>.</P><P><TT>Term1 @&gt;= Term2</TT> succeeds if <TT>Term1</TT> is greater than
or equal to <TT>Term2</TT>.</P><P><TT>==</TT>, <TT>\==</TT>, <TT>@&lt;</TT>, <TT>@=&lt;</TT>,
<TT>@&gt;</TT> and <TT>@&gt;=</TT> are predefined infix operators (section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>ISO predicates.</P><!--TOC subsubsection <TT>compare/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc79">8.3.3</A>&#XA0;&#XA0;<TT>compare/3</TT></H4><!--SEC END --><P>
<A NAME="compare/3"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
compare(?atom, +term, +term)</TT></DD></DL><P><B>Description</B></P><P><TT>compare(Order, Term1, Term2)</TT> compares <TT>Term1</TT> and
<TT>Term2</TT> according to the standard (section&#XA0;<A HREF="#Standard-total-ordering-of-terms">8.3.1</A>) and unifies <TT>Order</TT> with:</P><UL CLASS="itemize"><LI CLASS="li-itemize">the atom <TT>&lt;</TT> if <TT>Term1</TT> is less than <TT>Term2</TT>.</LI><LI CLASS="li-itemize">the atom <TT>=</TT> if <TT>Term1</TT> and <TT>Term2</TT> are equal.</LI><LI CLASS="li-itemize">the atom <TT>&gt;</TT> if <TT>Term1</TT> is greater than
<TT>Term2</TT>.</LI></UL><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Order</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Order)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Order</TT> is an atom but not <TT>&lt;</TT>, <TT>=</TT> or <TT>&gt;</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(order, Order)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsection Term processing-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc80">8.4</A>&#XA0;&#XA0;Term processing</H3><!--SEC END --><!--TOC subsubsection <TT>functor/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc81">8.4.1</A>&#XA0;&#XA0;<TT>functor/3</TT></H4><!--SEC END --><P>
<A NAME="functor/3"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
functor(+nonvar, ?atomic, ?integer)<BR>
functor(-nonvar, +atomic, +integer)</TT></DD></DL><P><B>Description</B></P><P><TT>functor(Term, Name, Arity)</TT> succeeds if the principal functor of
<TT>Term</TT> is <TT>Name</TT> and its arity is <TT>Arity</TT>. This
predicate can be used in two ways:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>Term</TT> is not a variable: extract the name (an atom or a number
if <TT>Term</TT> is a number) and the arity of <TT>Term</TT> (if
<TT>Term</TT> is atomic <TT>Arity</TT> = 0).</LI><LI CLASS="li-itemize"><TT>Term</TT> is a variable: unify <TT>Term</TT> with a general term
whose principal functor is given by <TT>Name</TT> and arity is given by
<TT>Arity</TT>.</LI></UL><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Term</TT> and <TT>Name</TT> are both variables</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Term</TT> and <TT>Arity</TT> are both variables</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Term</TT> is a variable and <TT>Name</TT> is neither a variable
nor an atomic term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atomic, Name)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Term</TT> is a variable and <TT>Arity</TT> is neither a
variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Arity)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Term</TT> is a variable, <TT>Name</TT> is a constant but not an
atom and <TT>Arity</TT> is an integer &gt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Name)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Term</TT> is a variable and <TT>Arity</TT> is an integer &gt;
<TT>max_arity</TT> flag (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(max_arity)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Term</TT> is a variable and <TT>Arity</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, Arity)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>arg/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc82">8.4.2</A>&#XA0;&#XA0;<TT>arg/3</TT></H4><!--SEC END --><P>
<A NAME="arg/3"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
arg(+integer, +compound_term, ?term)</TT></DD></DL><P><B>Description</B></P><P><TT>arg(N, Term, Arg)</TT> succeeds if the <TT>N</TT><EM>th</EM> argument of
<TT>Term</TT> is <TT>Arg</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>N</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Term</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>N</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, N)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Term</TT> is neither a variable nor a compound term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(compound, Term)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>N</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, N)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>(=..)/2</TT> - univ-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc83">8.4.3</A>&#XA0;&#XA0;<TT>(=..)/2</TT> - univ</H4><!--SEC END --><P>
<A NAME="(=..)/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
=..(+nonvar, ?list)<BR>
=..(-nonvar, +list)</TT></DD></DL><P><B>Description</B></P><P><TT>Term =.. List</TT> succeeds if <TT>List</TT> is a list whose head is the
atom corresponding to the principal functor of <TT>Term</TT> and whose tail
is a list of the arguments of <TT>Term</TT>.</P><P><TT>=..</TT> is a predefined infix operator (section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Term</TT> is a variable and <TT>List</TT> is a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, List)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Term</TT> is a variable and <TT>List</TT> is a list whose head
is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is a list whose head <TT>H</TT> is neither an atom
nor a variable and whose tail is not the empty list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, H)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is a list whose head <TT>H</TT> is a compound term
and whose tail is the empty list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atomic, H)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Term</TT> is a variable and <TT>List</TT> is the empty list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(non_empty_list, [])</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Term</TT> is a variable and the tail of <TT>List</TT> has a
length &gt; <TT>max_arity</TT> flag (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(max_arity)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>copy_term/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc84">8.4.4</A>&#XA0;&#XA0;<TT>copy_term/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
copy_term(?term, ?term)</TT></DD></DL><P><B>Description</B></P><P><TT>copy_term(Term1, Term2)</TT> succeeds if <TT>Term2</TT> unifies with a
term <TT>T</TT> which is a renamed copy of <TT>Term1</TT>.</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>term_variables/2</TT>,
		<TT>term_variables/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc85">8.4.5</A>&#XA0;&#XA0;<TT>term_variables/2</TT>,
		<TT>term_variables/3</TT></H4><!--SEC END --><P><A NAME="term_variables/2-3"></A></P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
term_variables(?term, ?list)<BR>
term_variables(?term, ?list, ?list)<BR>

</TT></DD></DL><P><B>Description</B></P><P><TT>term_variables(Term, List)</TT> succeeds if <TT>List</TT> unifies with a
list of variables (including FD variables), each sharing with a unique
variable of <TT>Term</TT>. The variables in <TT>List</TT> are ordered in
order of appearance traversing <TT>Term</TT> depth-first and left-to-right.</P><P><TT>term_variables(Term, List, Tail)</TT> is a difference-list version of the above predicate, i.e. <TT>Tail</TT> is the tail of the variable-list <TT>List</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
in <TT>term_variables/2</TT> <TT>List</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, List)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P><TT>term_variables/2</TT> is an ISO Predicate. <TT>term_variables/3</TT> is a 
GNU Prolog predicate.</P><!--TOC subsubsection <TT>subsumes_term/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc86">8.4.6</A>&#XA0;&#XA0;<TT>subsumes_term/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
subsumes_term(?term, ?term)</TT></DD></DL><P><B>Description</B></P><P><TT>subsumes_term(General, Specific)</TT> succeeds if <TT>General</TT> can
be made equivalent to <TT>Specific</TT> by binding variables in
<TT>General</TT> leaving <TT>Specific</TT> unaffected. The current implementation performs the unification (with
occurs check) and ensures that the variable set of <TT>Specific</TT> is not
changed by the unification (which is then undone). Note that this predicate
fails in the presence of FD variables in <TT>Specific</TT>.</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>acyclic_term/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc87">8.4.7</A>&#XA0;&#XA0;<TT>acyclic_term/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
acyclic_term(?term)</TT></DD></DL><P><B>Description</B></P><P><TT>acyclic_term(Term)</TT> succeeds if <TT>Term</TT> does not contain a
cyclic (sub-)term. In this case, Term may be processed safely. If
<TT>acyclic_term(Term)</TT> fails, <TT>Term</TT> contains a cycle and
processing Term is not safe, because GNU Prolog does not support the
unification of cyclic terms but permits their creation. Cycles can be safely
undone by failing over their creation. The use of <TT>acyclic_term/1</TT>
shall thus be reserved to protect critical predicates against cyclic terms.</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>setarg/4</TT>,
<TT>setarg/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc88">8.4.8</A>&#XA0;&#XA0;<TT>setarg/4</TT>,
<TT>setarg/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
setarg(+integer, +compound_term, +term, +boolean)<BR>
setarg(+integer, +compound_term, +term)</TT></DD></DL><P><B>Description</B></P><P><TT>setarg(N, Term, NewValue, Undo)</TT> replaces destructively the
<TT>N</TT><EM>th</EM> argument of <TT>Term</TT> with <TT>NewValue</TT>. This
assignment is undone on backtracking if <TT>Undo</TT> = <TT>true</TT>. This
should only used if there is no further use of the old value of the replaced
argument. If <TT>Undo</TT> = <TT>false</TT> then <TT>NewValue</TT> must be
either an atom or an integer.</P><P><TT>setarg(N, Term, NewValue)</TT> is equivalent to <TT>setarg(N, Term,
NewValue, true)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>N</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>N</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, N)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>N</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, N)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Term</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Term</TT> is neither a variable nor a compound term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(compound, Term)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>NewValue</TT> is neither an atom nor an integer and
<TT>Undo</TT> = <TT>false</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atomic, NewValue)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Undo</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Undo</TT> is neither a variable nor a boolean</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(boolean, Undo)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsection Variable naming/numbering-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc89">8.5</A>&#XA0;&#XA0;Variable naming/numbering</H3><!--SEC END --><P>
<A NAME="Variable-naming/numbering"></A></P><!--TOC subsubsection <TT>name_singleton_vars/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc90">8.5.1</A>&#XA0;&#XA0;<TT>name_singleton_vars/1</TT></H4><!--SEC END --><P>
<A NAME="name-singleton-vars/1"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
name_singleton_vars(?term)</TT></DD></DL><P><B>Description</B></P><P><TT>name_singleton_vars(Term)</TT> binds each singleton variable appearing
in <TT>Term</TT> with a term of the form <TT>&#X2019;$VARNAME&#X2019;(&#X2019;_&#X2019;)</TT>. Such a
term can be output by <TT>write_term/3</TT> as a variable name
(section&#XA0;<A HREF="#write-term/3">8.14.6</A>).</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>name_query_vars/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc91">8.5.2</A>&#XA0;&#XA0;<TT>name_query_vars/2</TT></H4><!--SEC END --><P>
<A NAME="name-query-vars/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
name_query_vars(+list, ?list)</TT></DD></DL><P><B>Description</B></P><P><TT>name_query_vars(List, Rest)</TT> for each element of <TT>List</TT> of
the form <TT>Name = Var</TT> where <TT>Name</TT> is an atom and <TT>Var</TT>
a variable, binds <TT>Var</TT> with the term <TT>&#X2019;$VARNAME&#X2019;(Name)</TT>.
Such a term can be output by <TT>write_term/3</TT> as a variable name
(section&#XA0;<A HREF="#write-term/3">8.14.6</A>). <TT>Rest</TT> is unified with the list of elements of
<TT>List</TT> that have not given rise to a binding. This predicate is
provided as a way to name the variable lists obtained returned by
<TT>read_term/3</TT> with <TT>variable_names(List)</TT> or
<TT>singletons(List)</TT> options (section&#XA0;<A HREF="#read-term/3">8.14.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, List)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Rest</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Rest)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>bind_variables/2</TT>,
<TT>numbervars/3</TT>,
<TT>numbervars/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc92">8.5.3</A>&#XA0;&#XA0;<TT>bind_variables/2</TT>,
<TT>numbervars/3</TT>,
<TT>numbervars/1</TT></H4><!--SEC END --><P>
<A NAME="bind-variables/2"></A>


</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
bind_variables(?term, +var_binding_option_list)<BR>
numbervars(?term, +integer, ?integer)<BR>
numbervars(?term)</TT></DD></DL><P><B>Description</B></P><P><TT>bind_variables(Term, Options)</TT> binds each variable appearing in
<TT>Term</TT> according to the options given by <TT>Options</TT>.</P><P><B>Variable binding options</B>: <TT>Options</TT> is a list of variable
binding options. If this list contains contradictory options, the rightmost
option is the one which applies. Possible options are:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>numbervars</TT>: specifies that each variable appearing in
<TT>Term</TT> should be bound to a term of the form <TT>&#X2019;$VAR&#X2019;(N)</TT>
where <TT>N</TT> is an integer. Such a term can be output by
<TT>write_term/3</TT> as a variable name (section&#XA0;<A HREF="#write-term/3">8.14.6</A>). This is
the default.</LI><LI CLASS="li-itemize"><TT>namevars</TT>: specifies that each variables appearing in
<TT>Term</TT> shall be bound to a term of the form
<TT>&#X2019;$VARNAME&#X2019;(Name)</TT> where <TT>Name</TT> is the atom that would be
output by <TT>write_term/3</TT> seeing a term of the <TT>&#X2019;$VAR&#X2019;(N)</TT>
where <TT>N</TT> is an integer. Such a term can be output by
<TT>write_term/3</TT> as a variable name (section&#XA0;<A HREF="#write-term/3">8.14.6</A>). This is
the alternative to <TT>numbervars</TT>.</LI><LI CLASS="li-itemize"><TT>from(From)</TT>: the first integer <TT>N</TT> to use for
number/name variables of <TT>Term</TT> is <TT>From</TT>. The default value
is <TT>0</TT>.</LI><LI CLASS="li-itemize"><TT>next(Next)</TT>: when <TT>bind_variables/2</TT> succeeds,
<TT>Next</TT> is unified with the (last integer <TT>N</TT>)+1 used
to bind the variables of <TT>Term</TT>.</LI><LI CLASS="li-itemize"><TT>exclude(List)</TT>: collects all variable names appearing
in <TT>List</TT> to avoid a clash when binding a variable of <TT>Term</TT>.
Precisely a number <TT>N</TT> &#X2265; <TT>From</TT> will not be used to bind a
variable of <TT>Term</TT> if:<UL CLASS="itemize"><LI CLASS="li-itemize">there is a sub-term of <TT>List</TT> of the form <TT>&#X2019;$VAR&#X2019;(N)</TT>
or <TT>&#X2019;$VARNAME&#X2019;(Name)</TT> where <TT>Name</TT> is the constant that would
be output by <TT>write_term/3</TT> seeing a term of the
<TT>&#X2019;$VAR&#X2019;(N)</TT>.</LI><LI CLASS="li-itemize">an element of <TT>List</TT> is of the form <TT>Name = Var</TT> where
<TT>Name</TT> is an atom that would be output by <TT>write_term/3</TT> on
seeing a term of the from <TT>&#X2019;$VAR&#X2019;(N)</TT>. This case allows for lists
returned by <TT>read_term/3</TT>
(with <TT>variable_names(List)</TT> or
<TT>singletons(List)</TT> options) (section&#XA0;<A HREF="#read-term/3">8.14.1</A>) and by
<TT>name_query_vars/2</TT> (section&#XA0;<A HREF="#name-query-vars/2">8.5.2</A>).</LI></UL></LI></UL><P><TT>numbervars(Term, From, Next)</TT> is equivalent to
<TT>bind_variables(Term, [from(From), next(Next)]</TT>, i.e. each variable
of <TT>Term</TT> is bound to <TT>&#X2019;$VAR&#X2019;(N)</TT> where <TT>From &#X2264;</TT>
<TT>N</TT> &lt; <TT>Next</TT>.</P><P><TT>numbervars(Term)</TT> is equivalent to <TT>numbervars(Term, 0, _)</TT>.</P><P>See also <TT>term_variables</TT> (section&#XA0;<A HREF="#term_variables/2-3">8.4.5</A>) which returns the set of variables of a
term.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Options</TT> is a partial list or a list with an element
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Options</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Options)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Options</TT> list is neither a
variable nor a variable binding option</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(var_binding_option, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>From</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>From</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, From)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Next</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Next)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, List)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>term_ref/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc93">8.5.4</A>&#XA0;&#XA0;<TT>term_ref/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
term_ref(+term, ?integer)<BR>
term_ref(?term, +integer)</TT></DD></DL><P><B>Description</B></P><P><TT>term_ref(Term, Ref)</TT> succeeds if the internal reference of
<TT>Term</TT> is <TT>Ref</TT>. This predicate can be used either to obtain
the internal reference of a term or to obtain the term associated with a given
reference. Note that two identical terms can have different internal
references. A good way to use this predicate is to first record the internal
reference of a given term and to later re-obtain the term via this
reference.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Term</TT> and <TT>Ref</TT> are both variables</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Ref</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Ref)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Ref</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, Ref)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsection Arithmetic-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc94">8.6</A>&#XA0;&#XA0;Arithmetic</H3><!--SEC END --><!--TOC subsubsection Evaluation of an arithmetic expression-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc95">8.6.1</A>&#XA0;&#XA0;Evaluation of an arithmetic expression</H4><!--SEC END --><P>
<A NAME="Evaluation-of-an-arithmetic-expression"></A>
An arithmetic expression is a Prolog term built from numbers,
variables, and functors (or operators) that represent arithmetic functions.
When an expression is evaluated each variable must be bound to a
non-variable expression. An expression evaluates to a number, which may be
an integer or a floating point number. The following table details the
components of an arithmetic expression, how they are evaluated, the types
expected/returned and if they are ISO or an extension:</P><BLOCKQUOTE CLASS="table"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left NOWRAP>Expression</TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">Result = <I>eval</I>(Expression)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>Signature</TD><TD VALIGN=top ALIGN=center NOWRAP>ISO</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>a variable</TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">bound to an expression <TT>E</TT>, result is <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF &#X2192; IF</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
an integer number</TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">this number</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>I</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
a floating point number</TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">this number</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>F</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>pi</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">the value of &#X3C0; = 3.141592...</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>F</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>e</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">the value of <I>e</I> = 2.718281...</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>F</TD><TD VALIGN=top ALIGN=center NOWRAP>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>epsilon</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">difference between 1.0 and minimum float &gt; 1.0</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>F</TD><TD VALIGN=top ALIGN=center NOWRAP>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>+ E</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF &#X2192; IF</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>- E</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">- <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF &#X2192; IF</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>inc(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>eval</I>(<TT>E</TT>) + 1</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF &#X2192; IF</TD><TD VALIGN=top ALIGN=center NOWRAP>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>dec(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>eval</I>(<TT>E</TT>) - 1</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF &#X2192; IF</TD><TD VALIGN=top ALIGN=center NOWRAP>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 + E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>eval</I>(<TT>E1</TT>) + <I>eval</I>(<TT>E2</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF, IF &#X2192; IF</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 - E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>eval</I>(<TT>E1</TT>) - <I>eval</I>(<TT>E2</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF, IF &#X2192; IF</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 * E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>eval</I>(<TT>E1</TT>) * <I>eval</I>(<TT>E2</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF, IF &#X2192; IF</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 / E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>eval</I>(<TT>E1</TT>) / <I>eval</I>(<TT>E2</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF, IF &#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 // E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>rnd</I>(<I>eval</I>(<TT>E1</TT>) /
<I>eval</I>(<TT>E2</TT>))</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>I, I &#X2192; I</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 rem E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>eval</I>(<TT>E1</TT>) -
(<I>rnd</I>(<I>eval</I>(<TT>E1</TT>) /
<I>eval</I>(<TT>E2</TT>)) * <I>eval</I>(<TT>E2</TT>))</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>I, I &#X2192;
I</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 div E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">&#X230A;(<I>eval</I>(<TT>E1</TT>) -
<I>eval</I>(<TT>E1</TT>) <TT>mod</TT> <I>eval</I>(<TT>E2</TT>)) /
<I>eval</I>(<TT>E2</TT>)&#X230B;</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>I, I &#X2192; I</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 mod E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>eval</I>(<TT>E1</TT>) -
(&#X230A;<I>eval</I>(<TT>E1</TT>) / <I>eval</I>(<TT>E2</TT>)&#X230B;
* <I>eval</I>(<TT>E2</TT>))</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>I, I &#X2192; I</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 /\ E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>eval</I>(<TT>E1</TT>) bitwise_and
<I>eval</I>(<TT>E2</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>I, I &#X2192; I</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 \/ E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>eval</I>(<TT>E1</TT>) bitwise_or
<I>eval</I>(<TT>E2</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>I, I &#X2192; I</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>xor(E1,E2)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>eval</I>(<TT>E1</TT>) bitwise_xor
<I>eval</I>(<TT>E2</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>I, I &#X2192; I</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>\ E</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">bitwise_not <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>I &#X2192;
I</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 &lt;&lt; E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>eval</I>(<TT>E1</TT>) integer_shift_left
<I>eval</I>(<TT>E2</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>I, I &#X2192; I</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 &gt;&gt; E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>eval</I>(<TT>E1</TT>) integer_shift_right
<I>eval</I>(<TT>E2</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>I, I &#X2192; I</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>lsb(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">least significant bit (from 0) of <I>eval</I>(<TT>E</TT>) or -1</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>I
&#X2192; I</TD><TD VALIGN=top ALIGN=center NOWRAP>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>msb(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">most significant bit (from 0) of <I>eval</I>(<TT>E</TT>) or -1</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>I
&#X2192; I</TD><TD VALIGN=top ALIGN=center NOWRAP>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>popcount(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">number of 1-bits in <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>I
&#X2192; I</TD><TD VALIGN=top ALIGN=center NOWRAP>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>abs(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">absolute value of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF
&#X2192; IF</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>sign(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">sign of <I>eval</I>(<TT>E</TT>) (-1 if &lt; 0, 0 if = 0,
+1 if &gt; 0)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF &#X2192; IF</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>min(E1,E2)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">minimal value between <I>eval</I>(<TT>E1</TT>) and
<I>eval</I>(<TT>E2</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF, IF &#X2192; ?</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>max(E1,E2)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">maximal value between <I>eval</I>(<TT>E1</TT>) and
<I>eval</I>(<TT>E2</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF, IF &#X2192; ?</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>gcd(E1,E2)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">greatest common divisor of <I>eval</I>(<TT>E1</TT>) and
<I>eval</I>(<TT>E2</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>I, I &#X2192; I</TD><TD VALIGN=top ALIGN=center NOWRAP>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 ^ E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>eval</I>(<TT>E1</TT>) raised to the power of
<I>eval</I>(<TT>E2</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF, IF &#X2192; IF</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 ** E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>eval</I>(<TT>E1</TT>) raised to the power of
<I>eval</I>(<TT>E2</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF, IF &#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>sqrt(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">square root of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF
&#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>tan(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">tangent of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF
&#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>atan(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">arc tangent of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF
&#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>atan2(Y,X)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">principal value of arc tangent
of <I>eval</I>(<TT>Y</TT>) / <I>eval</I>(<TT>X</TT>) using both signs for the quadrant</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF
&#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>cos(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">cosine of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF &#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>acos(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">arc cosine of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF, IF &#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>sin(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">sine of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF &#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>asin(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">arc sine of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF &#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>tanh(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">hyperbolic tangent of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF
&#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>atanh(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">hyperbolic arc tangent of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF
&#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>cosh(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">hyperbolic cosine of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF &#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>acosh(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">hyperbolic arc cosine of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF, IF &#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>sinh(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">hyperbolic sine of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF &#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>asinh(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">hyperbolic arc sine of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF &#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>exp(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>e</I> raised to the power of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF &#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>log(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">natural logarithm of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF
&#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>log10(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">base 10 logarithm of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF
&#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>log(R, E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">base <I>eval</I>(<TT>R</TT>) logarithm of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>F, IF
&#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>N</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>float(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">the floating point number equal to
<I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>IF &#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>ceiling(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">rounds <I>eval</I>(<TT>E</TT>) upward to the
nearest integer</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>F &#X2192; I</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>floor(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">rounds <I>eval</I>(<TT>E</TT>) downward to the
nearest integer</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>F &#X2192; I</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>round(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">rounds <I>eval</I>(<TT>E</TT>) to the nearest integer</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>F &#X2192; I</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>truncate(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">the integer value of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>F
&#X2192; I</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>float_fractional_part(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">the float equal to the fractional part
of <I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>F &#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>float_integer_part(E)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">the float equal to the integer part of
<I>eval</I>(<TT>E</TT>)</DIV></TD><TD VALIGN=top ALIGN=center NOWRAP>F &#X2192; F</TD><TD VALIGN=top ALIGN=center NOWRAP>Y</TD></TR>
</TABLE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The meaning of the signature field is as follows:</P><UL CLASS="itemize"><LI CLASS="li-itemize">I &#X2192; I: unary function, the operand must be an integer and
the result is an integer.</LI><LI CLASS="li-itemize">F &#X2192; F: unary function, the operand must be a floating
point number and the result is a floating point number.</LI><LI CLASS="li-itemize">F &#X2192; I: unary function, the operand must be a floating
point number and the result is an integer.</LI><LI CLASS="li-itemize">IF &#X2192; F: unary function, the operand can be an integer or a
floating point number and the result is a floating point number.</LI><LI CLASS="li-itemize">IF &#X2192; IF: unary function, the operand can be an integer or
a floating point number and the result has the same type as the operand.</LI><LI CLASS="li-itemize">I, I &#X2192; I: binary function: each operand must be an integer
and the result is an integer.</LI><LI CLASS="li-itemize">IF, IF &#X2192; IF: binary function: each operand can be an
integer or a floating point number and the result is a floating point number
if at least one operand is a floating point number, an integer otherwise.</LI><LI CLASS="li-itemize">IF, IF &#X2192; ?: binary function: each operand can be an
integer or a floating point number and the result has the same type as the
selected operand. This is used for <TT>min</TT> and <TT>max</TT>. Note that
in case of equality between an integer and a floating point number the
result is an integer.</LI></UL><P><TT>is</TT>, <TT>+</TT>, <TT>-</TT>, <TT>*</TT>, <TT>/</TT>, <TT>//</TT>,
<TT>div</TT>, <TT>rem</TT>, <TT>mod</TT>, <TT>/\</TT>, <TT>\/</TT>,
<TT>&lt;&lt;</TT>, <TT>&gt;&gt;</TT>, <TT>**</TT> and <TT>^</TT> are predefined infix
operators. <TT>+</TT>, <TT>-</TT> and <TT>\</TT>, are predefined prefix
operators (section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</P><P><B>Integer division rounding function</B>: the integer division rounding
function <TT><I>rnd</I>(X)</TT> rounds the floating point number
<TT>X</TT> to an integer. There are two possible definitions (depending on
the target machine) for this function which differ on negative numbers:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT><I>rnd</I>(X)</TT> = integer part of <TT>X</TT>, e.g.
<TT><I>rnd</I>(-1.5)</TT> = <TT>-1</TT> (round toward 0)</LI><LI CLASS="li-itemize"><TT><I>rnd</I>(X)</TT> = &#X230A;<TT>X</TT>&#X230B;, e.g.
<TT><I>rnd</I>(-1.5)</TT> = <TT>-2</TT> (round toward &#X2212;&#X221E;)</LI></UL><P>The definition of this function determines the definition of the integer
division and remainder (<TT>(//)/2</TT> and <TT>(rem)/2</TT>). It is
possible to test the value (<TT>toward_zero</TT> or <TT>down</TT>) of the
<TT>integer_rounding_function</TT> Prolog flag to determine which
function being used (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>). Since rounding toward zero is
the most common case, two additional evaluable functors (<TT>(div)/2</TT> and
<TT>(mod)/2</TT>) are available which consider rounding toward &#X2212;&#X221E;.</P><P><B>Fast mathematical mode</B>: in order to speed-up integer computations,
the GNU Prolog compiler can generate faster code when invoked with the
<TT>--fast-math</TT> option (section&#XA0;<A HREF="#Using-the-compiler">4.4.3</A>). In this mode only
integer operations are allowed and a variable in an expression must be bound
at evaluation time to an integer. No type checking is done.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
a sub-expression <TT>E</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
a sub-expression <TT>E</TT> is neither a number nor an evaluable
functor</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(evaluable, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
a sub-expression <TT>E</TT> is a floating point number while an
integer is expected</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
a sub-expression <TT>E</TT> is an integer while a floating point
number is expected</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(float, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
a division by zero occurs</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>evaluation_error(zero_divisor)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>Refer to the above table to determine which evaluable functors are ISO
and which are GNU Prolog extensions. For efficiency reasons, GNU
Prolog does not detect the following ISO arithmetic errors:
<TT>float_overflow</TT>,
<TT>int_overflow, int_underflow</TT>, and <TT>undefined</TT>.</P><!--TOC subsubsection <TT>(is)/2</TT> - evaluate expression-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc96">8.6.2</A>&#XA0;&#XA0;<TT>(is)/2</TT> - evaluate expression</H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
is(?term, +evaluable)</TT></DD></DL><P><B>Description</B></P><P><TT>Result is Expression</TT> succeeds if <TT>Result</TT> can be
unified with <I>eval</I>(<TT>Expression</TT>). Refer to the
evaluation of an arithmetic expression for the definition of the
<I>eval</I> function
(section&#XA0;<A HREF="#Evaluation-of-an-arithmetic-expression">8.6.1</A>).</P><P><TT>is</TT> is a predefined infix operator (section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</P><P><B>Errors</B></P><P>Refer to the evaluation of an arithmetic expression for possible errors
(section&#XA0;<A HREF="#Evaluation-of-an-arithmetic-expression">8.6.1</A>).</P><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>(=:=)/2</TT> - arithmetic equal,
<TT>(=</TT><TT>\</TT><TT>=)/2</TT> - arithmetic not equal,<BR>
 <TT>(</TT><TT>&lt;</TT><TT>)/2</TT> - arithmetic less than,
<TT>(=</TT><TT>&lt;</TT><TT>)/2</TT> - arithmetic less than or equal to,<BR>
 <TT>(</TT><TT>&gt;</TT><TT>)/2</TT> - arithmetic greater than,
<TT>(</TT><TT>&gt;</TT><TT>=)/2</TT> - arithmetic greater than or equal to-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc97">8.6.3</A>&#XA0;&#XA0;<TT>(=:=)/2</TT> - arithmetic equal,
<TT>(=\=)/2</TT> - arithmetic not equal,<BR>
 <TT>(&lt;)/2</TT> - arithmetic less than,
<TT>(=&lt;)/2</TT> - arithmetic less than or equal to,<BR>
 <TT>(&gt;)/2</TT> - arithmetic greater than,
<TT>(&gt;=)/2</TT> - arithmetic greater than or equal to</H4><!--SEC END --><P>
<A NAME="(=:=)/2"></A>





</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
=:=(+evaluable, +evaluable)<BR>
=\=(+evaluable, +evaluable)<BR>
&lt;(+evaluable, +evaluable)<BR>
=&lt;(+evaluable, +evaluable)<BR>
&gt;(+evaluable, +evaluable)<BR>
&gt;=(+evaluable, +evaluable)</TT></DD></DL><P><B>Description</B></P><P><TT>Expr1 =:= Expr2</TT> succeeds if <I>eval</I>(<TT>Expr1</TT>) =
<I>eval</I>(<TT>Expr2</TT>).</P><P><TT>Expr1 =\= Expr2</TT> succeeds if <I>eval</I>(<TT>Expr1</TT>)
&#X2260; <I>eval</I>(<TT>Expr2</TT>).</P><P><TT>Expr1 &lt; Expr2</TT> succeeds if <I>eval</I>(<TT>Expr1</TT>) &lt;
<I>eval</I>(<TT>Expr2</TT>).</P><P><TT>Expr1 =&lt; Expr2</TT> succeeds if <I>eval</I>(<TT>Expr1</TT>)
&#X2264; <I>eval</I>(<TT>Expr2</TT>).</P><P><TT>Expr1 &gt; Expr2</TT> succeeds if <I>eval</I>(<TT>Expr1</TT>) &gt;
<I>eval</I>(<TT>Expr2</TT>).</P><P><TT>Expr1 &gt;= Expr2</TT> succeeds if <I>eval</I>(<TT>Expr1</TT>)
&#X2265; <I>eval</I>(<TT>Expr2</TT>).</P><P>Refer to the evaluation of an arithmetic expression for the definition of
the <I>eval</I> function (section&#XA0;<A HREF="#Evaluation-of-an-arithmetic-expression">8.6.1</A>).</P><P><TT>=:=</TT>, <TT>=\=</TT>, <TT>&lt;</TT>, <TT>=&lt;</TT>,
<TT>&gt;</TT> and <TT>&gt;=</TT> are predefined infix operators
(section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</P><P><B>Errors</B></P><P>Refer to the evaluation of an arithmetic expression for possible errors
(section&#XA0;<A HREF="#Evaluation-of-an-arithmetic-expression">8.6.1</A>).</P><P><B>Portability</B></P><P>ISO predicates.</P><!--TOC subsubsection <TT>succ/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc98">8.6.4</A>&#XA0;&#XA0;<TT>succ/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
succ(+integer, ?integer)<BR>
succ(-integer, +integer) </TT></DD></DL><P><B>Description</B></P><P><TT>succ(X, Y)</TT> is true iff <TT>Y</TT> is the successor of the non-negative integer <TT>X</TT>. </P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>X</TT> and <TT>Y</TT> are both variables</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>X</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, X)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Y</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Y)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>X</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, X)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Y</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, Y)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsection Dynamic clause management-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc99">8.7</A>&#XA0;&#XA0;Dynamic clause management</H3><!--SEC END --><!--TOC subsubsection Introduction-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc100">8.7.1</A>&#XA0;&#XA0;Introduction</H4><!--SEC END --><P>
<A NAME="Introduction:(Dynamic-clause-management)"></A>
<B>Static and dynamic procedures</B>: a procedure is either dynamic or
static. All built-in predicates are static. A user-defined procedure is
static by default unless a <TT>dynamic/1</TT> directive precedes its
definition (section&#XA0;<A HREF="#dynamic/1">7.1.2</A>). Adding a clause to a non-existent procedure
creates a dynamic procedure. The clauses of a dynamic procedure can be
altered (e.g. using <TT>asserta/1</TT>), the clauses of a static procedure
cannot be altered.</P><P><B>Private and public procedures</B>: each procedure is either public or
private. A dynamic procedure is always public. Each built-in predicate is
private, and a static user-defined procedure is private by default unless a
<TT>public/1</TT> directive precedes its definition (section&#XA0;<A HREF="#public/1">7.1.3</A>). If a
dynamic declaration exists it is unnecessary to add a public declaration
since a dynamic procedure is also public. A clause of a public procedure can
be inspected (e.g. using <TT>clause/2</TT>), a clause of a private procedure
cannot be inspected.</P><P><B>A logical database update view</B>: any change in the database that
occurs as the result of executing a goal (e.g. when a sub-goal is a call of
<TT>assertz/1</TT> or <TT>retract/1</TT>) only affects subsequent
activations. The change does not affect any activation that is currently
being executed. Thus the database is frozen during the execution of a goal,
and the list of clauses defining a predication is fixed at the moment of its
execution.</P><!--TOC subsubsection <TT>asserta/1</TT>,
<TT>assertz/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc101">8.7.2</A>&#XA0;&#XA0;<TT>asserta/1</TT>,
<TT>assertz/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
asserta(+clause)<BR>
assertz(+clause)</TT></DD></DL><P><B>Description</B></P><P><TT>asserta(Clause)</TT> first converts the term <TT>Clause</TT> to a clause
and then adds it to the current internal database. The predicate concerned
must be dynamic (section&#XA0;<A HREF="#Introduction:(Dynamic-clause-management)">8.7.1</A>) or
undefined and the clause is inserted before the first clause of the
predicate. If the predicated is undefined it is created as a dynamic
procedure.</P><P><TT>assertz(Clause)</TT> acts like <TT>asserta/1</TT> except that the clause
is added at the end of all existing clauses of the concerned predicate.</P><P><B>Converting a term <TT>Clause</TT> to a clause <TT>Clause1</TT>:</B></P><UL CLASS="itemize"><LI CLASS="li-itemize">extract the head and the body of <TT>Clause</TT>: either
<TT>Clause</TT> = <TT>(Head :- Body)</TT> or <TT>Clause</TT> = <TT>Head</TT>
and <TT>Body</TT> = <TT>true</TT>.</LI><LI CLASS="li-itemize"><TT>Head</TT> must be a callable term (or else the conversion fails).</LI><LI CLASS="li-itemize">convert <TT>Body</TT> to a body clause (i.e. a goal) <TT>Body1</TT>.</LI><LI CLASS="li-itemize">the converted clause <TT>Clause1</TT> = <TT>(Head :- Body1)</TT>.</LI></UL><P><B>Converting a term <TT>T</TT> to a goal:</B></P><UL CLASS="itemize"><LI CLASS="li-itemize">if <TT>T</TT> is a variable it is replaced by the term
<TT>call(T)</TT>.</LI><LI CLASS="li-itemize">if <TT>T</TT> is a control construct <TT>(&#X2019;,&#X2019;)/2</TT>, <TT>(;)/2</TT>
or <TT>(-&gt;)/2</TT> each argument of the control construct is recursively
converted to a goal.</LI><LI CLASS="li-itemize">if <TT>T</TT> is a callable term it remains unchanged.</LI><LI CLASS="li-itemize">otherwise the conversion fails (<TT>T</TT> is neither a variable nor a
callable term).</LI></UL><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Head</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Head</TT> is neither a variable nor a callable term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(callable, Head)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Body</TT> cannot be converted to a goal</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(callable, Body)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
The predicate indicator <TT>Pred</TT> of <TT>Head</TT> is that of a
static procedure</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(modify, static_procedure, Pred)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicates.</P><!--TOC subsubsection <TT>retract/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc102">8.7.3</A>&#XA0;&#XA0;<TT>retract/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
retract(+clause)</TT></DD></DL><P><B>Description</B></P><P><TT>retract(Clause)</TT> erases the first clause of the database
that unifies with <TT>Clause</TT>. The concerned predicate must be a
dynamic procedure
(section&#XA0;<A HREF="#Introduction:(Dynamic-clause-management)">8.7.1</A>). Removing all clauses
of a procedure does not erase the procedure definition. To achieve
this use <TT>abolish/1</TT> (section&#XA0;<A HREF="#abolish/1">8.7.6</A>). <TT>retract/1</TT> is
re-executable on backtracking.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Head</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Head</TT> is neither a variable nor a callable term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(callable, Head)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
The predicate indicator <TT>Pred</TT> of <TT>Head</TT> is that of a
static procedure</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(modify, static_procedure, Pred)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate. In the ISO reference, the operation associated with the
<TT>permission_error</TT> is <TT>access</TT> while it is <TT>modify</TT> in
GNU Prolog. This seems to be an error of the ISO reference since for
<TT>asserta/1</TT> (which is similar in spirit to <TT>retract/1</TT>) the
operation is also <TT>modify</TT>.</P><!--TOC subsubsection <TT>retractall/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc103">8.7.4</A>&#XA0;&#XA0;<TT>retractall/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
retractall(+head)</TT></DD></DL><P><B>Description</B></P><P><TT>retractall(Head)</TT> erases all clauses whose head unifies with
<TT>Head</TT>. The concerned predicate must be a dynamic procedure
(section&#XA0;<A HREF="#Introduction:(Dynamic-clause-management)">8.7.1</A>). The procedure definition
is not removed so that it is found by <TT>current_predicate/1</TT>
(section&#XA0;<A HREF="#current-predicate/1">8.8.1</A>). <TT>abolish/1</TT> should be used to remove the
procedure (section&#XA0;<A HREF="#abolish/1">8.7.6</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Head</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Head</TT> is not a callable term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(callable, Head)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
The predicate indicator <TT>Pred</TT> of <TT>Head</TT> is that of a
static procedure</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(modify, static_procedure, Pred)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>clause/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc104">8.7.5</A>&#XA0;&#XA0;<TT>clause/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
clause(+head, ?callable_term)</TT></DD></DL><P><B>Description</B></P><P><TT>clause(Head, Body)</TT> succeeds if there exists a clause in the
database that unifies with <TT>Head :- Body</TT>. The predicate in question
must be a public procedure (section&#XA0;<A HREF="#Introduction:(Dynamic-clause-management)">8.7.1</A>). Clauses are delivered from the first to the last. This
predicate is re-executable on backtracking.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Head</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Head</TT> is neither a variable nor a callable term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(callable, Head)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
The predicate indicator <TT>Pred</TT> of <TT>Head</TT> is that of a
private procedure</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(access, private_procedure, Pred)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Body</TT> is neither a variable nor a callable term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(callable, Body)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>abolish/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc105">8.7.6</A>&#XA0;&#XA0;<TT>abolish/1</TT></H4><!--SEC END --><P>
<A NAME="abolish/1"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
abolish(+predicate_indicator)</TT></DD></DL><P><B>Description</B></P><P><TT>abolish(Pred)</TT> removes from the database the procedure whose
predicate indicator is <TT>Pred</TT>. The concerned predicate must be a
dynamic procedure (section&#XA0;<A HREF="#Introduction:(Dynamic-clause-management)">8.7.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pred</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pred</TT> is a term <TT>Name/Arity</TT> and either
<TT>Name</TT> or <TT>Arity</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pred</TT> is neither a variable nor a predicate indicator</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(predicate_indicator, Pred)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pred</TT> is a term <TT>Name/Arity</TT> and <TT>Arity</TT> is
neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Arity)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pred</TT> is a term <TT>Name/Arity</TT> and <TT>Name</TT> is
neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Name)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pred</TT> is a term <TT>Name/Arity</TT> and <TT>Arity</TT> is
an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, Arity)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pred</TT> is a term <TT>Name/Arity</TT> and <TT>Arity</TT> is
an integer &gt; <TT>max_arity</TT> flag (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(max_arity)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
The predicate indicator <TT>Pred</TT> is that of a static
procedure</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(modify, static_procedure, Pred)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsection Predicate information-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc106">8.8</A>&#XA0;&#XA0;Predicate information</H3><!--SEC END --><!--TOC subsubsection <TT>current_predicate/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc107">8.8.1</A>&#XA0;&#XA0;<TT>current_predicate/1</TT></H4><!--SEC END --><P>
<A NAME="current-predicate/1"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
current_predicate(?predicate_indicator)</TT></DD></DL><P><B>Description</B></P><P><TT>current_predicate(Pred)</TT> succeeds if there
exists a predicate indicator of a defined procedure that unifies with
<TT>Pred</TT>. All user defined procedures are found, whether static or
dynamic. Internal system procedures whose name begins
with <TT>&#X2019;$&#X2019;</TT> are not found. A user-defined procedure is found
even when it has no clauses. A user-defined procedure is not found if
it has been abolished. To conform to the ISO reference, built-in predicates
are not found except if the <TT>strict_iso</TT> Prolog flag is switched off (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>). This predicate is re-executable on
backtracking.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pred</TT> is neither a variable nor a predicate indicator</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(predicate_indicator, Pred)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pred</TT> is a term <TT>Name/Arity</TT> and <TT>Arity</TT> is
neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Arity)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pred</TT> is a term <TT>Name/Arity</TT> and <TT>Name</TT> is
neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Name)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pred</TT> is a term <TT>Name/Arity</TT> and <TT>Arity</TT> is
an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, Arity)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pred</TT> is a term <TT>Name/Arity</TT> and <TT>Arity</TT> is
an integer &gt; <TT>max_arity</TT> flag (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(max_arity)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>predicate_property/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc108">8.8.2</A>&#XA0;&#XA0;<TT>predicate_property/2</TT></H4><!--SEC END --><P>
<A NAME="predicate-property/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
predicate_property(?callable, ?predicate_property)</TT></DD></DL><P><B>Description</B></P><P><TT>predicate_property(Head, Property)</TT> succeeds if <TT>Head</TT> refers
to a predicate that has a property <TT>Property</TT>. All user defined
procedures and built-in predicates are found. Internal system procedures
whose name begins with <TT>&#X2019;$&#X2019;</TT> are not found. This predicate is
re-executable on backtracking.</P><P>Since version 1.4.0, <TT>predicate_property/2</TT> no longer accepts a
predicate indicator. Control constructs are now returned. Properties
<TT>built_in_fd</TT> and <TT>control_construct</TT> now imply the property
<TT>built_in</TT>.</P><P><B>Predicate properties</B>:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>static</TT>: if the procedure is static.</LI><LI CLASS="li-itemize"><TT>dynamic</TT>: if the procedure is dynamic.</LI><LI CLASS="li-itemize"><TT>private</TT>: if the procedure is private.</LI><LI CLASS="li-itemize"><TT>public</TT>: if the procedure is public.</LI><LI CLASS="li-itemize"><TT>monofile</TT>: if the procedure is monofile.</LI><LI CLASS="li-itemize"><TT>multifile</TT>: if the procedure is multifile.</LI><LI CLASS="li-itemize"><TT>user</TT>: if the procedure is a user-defined procedure.</LI><LI CLASS="li-itemize"><TT>built_in</TT>: if the procedure is a built-in predicate or a control construct.</LI><LI CLASS="li-itemize"><TT>built_in_fd</TT>: if the procedure is an FD built-in predicate.</LI><LI CLASS="li-itemize"><TT>control_construct</TT>: if the procedure is a control construct (section&#XA0;<A HREF="#control-construct">7.2</A>).</LI><LI CLASS="li-itemize"><TT>native_code</TT>: if the procedure is compiled in native code.</LI><LI CLASS="li-itemize"><TT>prolog_file(File)</TT>: source file from which the
procedure has been read.</LI><LI CLASS="li-itemize"><TT>prolog_line(Line)</TT>: line number of the source
file.</LI><LI CLASS="li-itemize"><TT>meta_predicate(Head)</TT>: if the procedure is a
meta-predicate unify <TT>Head</TT> with the head-pattern. The head-pattern
is a compound term with the same name and arity as the predicate where each
argument of the term is a meta argument specifier as follows:<DL CLASS="description"><DT CLASS="dt-description"><B>integer <TT>N</TT></B></DT><DD CLASS="dd-description"> the argument is a term that is used to reference a
predicate with <TT>N</TT> more arguments than the given argument term (e.g. <TT>call(0)</TT>).</DD><DT CLASS="dt-description"><TT><B>:</B></TT></DT><DD CLASS="dd-description"> the argument is module sensitive, but does not directly
refer to a predicate (e.g. <TT>consult(:)</TT>).</DD><DT CLASS="dt-description"><TT><B>-</B></TT></DT><DD CLASS="dd-description"> the argument is not module sensitive and unbound on entry.</DD><DT CLASS="dt-description"><TT><B>?</B></TT></DT><DD CLASS="dd-description"> the argument is not module sensitive and the mode is unspecified.</DD><DT CLASS="dt-description"><TT><B>+</B></TT></DT><DD CLASS="dd-description"> the argument is not module sensitive and bound (i.e., nonvar) on entry.</DD></DL></LI></UL><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Head</TT> is neither a variable nor a callable term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(callable, Head)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Property</TT> is neither a variable nor a predicate property
term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(predicate_property, Property)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Property</TT> = <TT>prolog_file(File)</TT> and <TT>File</TT>
is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, File)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Property</TT> = <TT>prolog_line(Line)</TT> and <TT>Line</TT>
is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Line)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsection All solutions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc109">8.9</A>&#XA0;&#XA0;All solutions</H3><!--SEC END --><!--TOC subsubsection Introduction-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc110">8.9.1</A>&#XA0;&#XA0;Introduction</H4><!--SEC END --><P>
<A NAME="Introduction:(All-solutions)"></A>
It is sometimes useful to collect all solutions for a goal. This can be done
by repeatedly backtracking and gradually building the list of solutions. The
following built-in predicates are provided to automate this process.</P><P>The built-in predicates described in this section invoke <TT>call/1</TT>
(section&#XA0;<A HREF="#call/1">7.2.3</A>) on the argument <TT>Goal</TT>. When efficiency is crucial
and <TT>Goal</TT> is complex it is better to define an auxiliary predicate
which can then be compiled, and have <TT>Goal</TT> call this predicate.</P><!--TOC subsubsection <TT>findall/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc111">8.9.2</A>&#XA0;&#XA0;<TT>findall/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
findall(?term, +callable_term, ?list)</TT></DD></DL><P><B>Description</B></P><P><TT>findall(Template, Goal, Instances)</TT> succeeds if <TT>Instances</TT>
unifies with the list of values to which a variable <TT>X</TT> not occurring
in <TT>Template</TT> or <TT>Goal</TT> would be instantiated by successive
re-executions of <TT>call(Goal), X = Template</TT> after systematic
replacement of all variables in <TT>X</TT> by new variables. Thus, the order
of the list <TT>Instances</TT> corresponds to the order in which the proofs
are found.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Goal</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Goal</TT> is neither a variable nor a callable term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(callable, Goal)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
The predicate indicator <TT>Pred</TT> of <TT>Goal</TT> does not
correspond to an existing procedure and the value of the <TT>unknown</TT>
Prolog flag is <TT>error</TT> (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(procedure, Pred)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Instances</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Instances)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>bagof/3</TT>,
<TT>setof/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc112">8.9.3</A>&#XA0;&#XA0;<TT>bagof/3</TT>,
<TT>setof/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
bagof(?term, +callable_term, ?list)<BR>
setof(?term, +callable_term, ?list)</TT></DD></DL><P><B>Description</B></P><P><TT>bagof(Template, Goal, Instances)</TT> assembles as a list the
set of solutions of <TT>Goal</TT> for each different instantiation of the
free variables in <TT>Goal</TT>. The elements of each list are in order of
solution, but the order in which each list is found is undefined.
This predicate is re-executable on backtracking.</P><P><B>Free variable set</B>: <TT>bagof/3</TT> groups the solutions of
<TT>Goal</TT> according to the free variables in <TT>Goal</TT>. This set
corresponds to all variables occurring in <TT>Goal</TT> but not in
<TT>Template</TT>. It is sometimes useful to exclude some additional
variables of <TT>Goal</TT>. For that, <TT>bagof/3</TT> recognizes a goal of
the form <TT>T^Goal</TT> and exclude all variables occurring in <TT>T</TT>
from the free variable set. <TT>(^)/2</TT> can be viewed as an
<EM>existential quantifier</EM> (the logical reading of <TT>X^Goal</TT>
being &#X201C;there exists an <TT>X</TT> such that <TT>Goal</TT> is true&#X201D;). The
use of this existential qualifier is superfluous outside <TT>bagof/3</TT>
(and <TT>setof/3</TT>) and then is not recognized.</P><P><TT>(^)/2</TT> is a predefined infix operator (section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</P><P><TT>setof(Template, Goal, Instances)</TT> is equivalent to
<TT>bagof(Template,Goal,I), sort(I,Instances)</TT>. Each list is then a
sorted list (duplicate elements are removed).</P><P>From the implementation point of view <TT>setof/3</TT> is as fast as
<TT>bagof/3</TT>. Both predicates use an in-place (i.e. destructive) sort
(section&#XA0;<A HREF="#sort/2">8.20.13</A>) and require the same amount of memory.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Goal</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Goal</TT> is neither a variable nor a callable term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(callable, Goal)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
The predicate indicator <TT>Pred</TT> of <TT>Goal</TT> does not
correspond to an existing procedure and the value of the <TT>unknown</TT>
Prolog flag is <TT>error</TT> (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(procedure, Pred)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Instances</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Instances)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicates.</P><!--TOC subsection Streams-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc113">8.10</A>&#XA0;&#XA0;Streams</H3><!--SEC END --><P>
<A NAME="Streams"></A></P><!--TOC subsubsection Introduction-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc114">8.10.1</A>&#XA0;&#XA0;Introduction</H4><!--SEC END --><P>
<A NAME="Introduction:(Streams)"></A>
A stream provides a logical view of a source/sink.</P><P><B>Sources and sinks</B>: a program can output results to a sink or input
data from a source. A source/sink may be a file (regular file, terminal,
device,&#X2026;), a constant term, a pipe, a socket,&#X2026;</P><P><B>Associating a stream to a source/sink</B>: to manipulate a source/sink
it must be associated with a stream. This provides a logical and uniform view
of the source/sink whatever its type. Once this association has been
established, i.e. a stream has been created, all subsequent references to
the source/sink are made by referring the stream. A stream is
unidirectional: it is either an input stream or an output stream. For a
classical file, the association is done by opening the file (whose name is
specified as an atom) with the <TT>open/4</TT> (section&#XA0;<A HREF="#open/4">8.10.6</A>). GNU Prolog
makes it possible to treat a Prolog constant term as a source/sink and
provides built-in predicates to associate a stream to such a term
(section&#XA0;<A HREF="#Constant-term-streams">8.11</A>). GNU Prolog provides operating system interface
predicates defining pipes between GNU Prolog and child processes with streams
associated with these pipes, e.g. <TT>popen/3</TT> (section&#XA0;<A HREF="#popen/3">8.27.21</A>).
Similarly, socket interface predicates associate streams to a socket to
allow the communication, e.g. <TT>socket_connect/4</TT>
(section&#XA0;<A HREF="#socket-connect/4">8.28.5</A>).</P><P><B>Stream-term</B>: a stream-term identifies a stream during a call of an
input/output built-in predicate. It is created as a result of associating a
stream to a source/sink (section above). A stream-term is a compound term of
the form <TT>&#X2019;$stream&#X2019;(I)</TT> where <TT>I</TT> is an integer.</P><P><B>Stream aliases</B>: any stream may be associated with a stream alias
which is an atom which may be used to refer to that stream. The association
can be done at open time or using <TT>add_stream_alias/2</TT>
(section&#XA0;<A HREF="#add-stream-alias/2">8.10.20</A>). Such an association automatically ends when the
stream is closed. A particular alias only refers to at most one stream at any
one time. However, more than one alias can be associated with a stream. Most
built-in predicates which have a stream-term as an input argument also accept
a stream alias as that argument. However, built-in predicates which return a
stream-term do not accept a stream alias.</P><P><B>Standard streams</B>: three streams are predefined and open during the
execution of every goal: the standard input stream which has the alias
<TT>user_input</TT>, the standard output stream which has the alias
<TT>user_output</TT> and the standard error stream which has the alias
<TT>user_error</TT>. A goal which attempts to close either standard stream
succeeds, but does not close the stream.</P><P><B>Current streams</B>: during execution there is a current input stream
and a current output stream. By default, the current input and output
streams are the standard input and output streams, but the built-in
predicates <TT>set_input/1</TT> (section&#XA0;<A HREF="#set-input/1">8.10.4</A>) and
<TT>set_output/1</TT> (section&#XA0;<A HREF="#set-output/1">8.10.5</A>) can be used to change them.
When the current input stream is closed, the standard input stream becomes
the current input stream. When the current output stream is closed, the
standard output stream becomes the current output stream.</P><P><B>Text streams and binary streams</B>: a text stream is a sequence of
characters. A text stream is also regarded as a sequence of lines where each
line is a possibly empty sequence of characters followed by a new line
character. GNU Prolog may add or remove space characters at the ends of lines
in order to conform to the conventions for representing text streams in the
operating system. A binary stream is a sequence of bytes. Only a few
built-in predicates can deal with binary streams, e.g.
<TT>get_byte/2</TT> (section&#XA0;<A HREF="#Byte-input/output">8.13</A>).</P><P><B>Stream positions</B>: the stream position of a stream identifies an
absolute position of the source/sink to which the stream is connected and
defines where in the source/sink the next input or output will take place. A
stream position is a ground term of the form
<TT>&#X2019;$stream_position&#X2019;(I1, I2, I3, I4)</TT> where <TT>I1</TT>,
<TT>I2</TT>, <TT>I3</TT> and <TT>I4</TT> are integers. Stream positions are
used to reposition a stream (when possible) using for instance
<TT>set_stream_position/2</TT> (section&#XA0;<A HREF="#set-stream-position/2">8.10.13</A>).</P><P><B>The position end of stream</B>: when all data of a stream
<I><TT>S</TT></I> has been input <I><TT>S</TT></I> has a stream position
end-of-stream. At this stream position a goal to input more data will return
a specific value to indicate that end of stream has been reached (e.g.
<TT>-1</TT> for <TT>get_code/2</TT> or <TT>end_of_file</TT> for
<TT>get_char/2</TT>,&#X2026;). When this terminating value has been input, the
stream has a stream position past-end-of-stream.</P><P><B>Buffering mode</B>: input/output on a stream can be buffered
(line-buffered or block-buffered) or not buffered at all. The buffering mode
can be specified at open time or using <TT>set_stream_buffering/2</TT>
(section&#XA0;<A HREF="#set-stream-buffering/2">8.10.27</A>). Line buffering is used on output streams,
output data are only written to the sink when a new-line character is output
(or at the close time). Block buffering is used on input or output. On input
streams, when an input is requested on the source, if the buffer is empty,
all available characters are read (within the limits of the size of the
buffer), subsequent reads will first use the characters in the buffer. On
output streams, output data are stored in the buffer and only when the
buffer is full is it physically written on the sink. Thus, an output to a
buffered stream may not be sent immediately to the sink connected to that
stream. When it is necessary to be certain that output has been delivered,
the built-in predicate <TT>flush_output/1</TT> (section&#XA0;<A HREF="#flush-output/1">8.10.8</A>)
should be used. Finally, it is also possible to use non-buffered streams, in
that case input/output are directly done on the connected source/sink. This
can be useful for communication purposes (e.g. sockets) or when a precise
control is needed, e.g. <TT>select/5</TT> (section&#XA0;<A HREF="#wait/2">8.27.25</A>).</P><P><B>Stream mirrors</B>: any stream may be associated with mirror streams
specified at open time or using <TT>add_stream_mirror/2</TT>
(section&#XA0;<A HREF="#add-stream-mirror/2">8.10.22</A>). Then, all characters/bytes read from/written to
the stream are also written on each mirror stream. The association
automatically ends when either the stream or the mirror stream is closed. It
is also possible to explicitly remove a mirror stream using
<TT>remove_stream_mirror/2</TT>
(section&#XA0;<A HREF="#remove-stream-mirror/2">8.10.23</A>).</P><!--TOC subsubsection <TT>current_input/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc115">8.10.2</A>&#XA0;&#XA0;<TT>current_input/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
current_input(?stream)</TT></DD></DL><P><B>Description</B></P><P><TT>current_input(Stream)</TT> unifies <TT>Stream</TT> with the stream-term
identifying the current input stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Stream</TT> is neither a variable nor a stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream, Stream)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>current_output/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc116">8.10.3</A>&#XA0;&#XA0;<TT>current_output/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
current_output(?stream)</TT></DD></DL><P><B>Description</B></P><P><TT>current_output(Stream)</TT> unifies <TT>Stream</TT> with the
stream-term identifying the current output stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Stream</TT> is neither a variable nor a stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream, Stream)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>set_input/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc117">8.10.4</A>&#XA0;&#XA0;<TT>set_input/1</TT></H4><!--SEC END --><P>
<A NAME="set-input/1"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
set_input(+stream_or_alias)</TT></DD></DL><P><B>Description</B></P><P><TT>set_input(SorA)</TT> sets the current input stream to be the stream
associated with the stream-term or alias <TT>SorA</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an output stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>set_output/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc118">8.10.5</A>&#XA0;&#XA0;<TT>set_output/1</TT></H4><!--SEC END --><P>
<A NAME="set-output/1"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
set_output(+stream_or_alias)</TT></DD></DL><P><B>Description</B></P><P><TT>set_output(SorA)</TT> sets the current output stream to be the stream
associated with the stream-term or alias <TT>SorA</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an input stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(output, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>open/4</TT>,
<TT>open/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc119">8.10.6</A>&#XA0;&#XA0;<TT>open/4</TT>,
<TT>open/3</TT></H4><!--SEC END --><P>
<A NAME="open/4"></A>

</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
open(+source_sink, +io_mode, -stream, +stream_option_list)<BR>
open(+source_sink, +io_mode, -stream)</TT></DD></DL><P><B>Description</B></P><P><TT>open(SourceSink, Mode, Stream, Options)</TT> opens the source/sink
<TT>SourceSink</TT> for input or output as indicated by <TT>Mode</TT> and
the list of stream-options <TT>Options</TT> and unifies <TT>Stream</TT> with
the stream-term which is associated with this stream. See
<TT>absolute_file_name/2</TT> for information about the syntax of
<TT>SourceSink</TT> (section&#XA0;<A HREF="#absolute-file-name/2">8.26.1</A>).</P><P><B>Input/output modes</B>: <TT>Mode</TT> is an atom which defines the
input/output operations that may be performed the stream. Possible modes
are:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>read</TT>: the source/sink is a source and must already exist.
Input starts at the beginning of the source.</LI><LI CLASS="li-itemize"><TT>write</TT>: the source/sink is a sink. If the sink already exists
then it is emptied else an empty sink is created. Output starts at the
beginning of that sink.</LI><LI CLASS="li-itemize"><TT>append</TT>: the source/sink is a sink. If the sink does not exist
it is created. Output starts at the end of that sink.</LI></UL><P><B>Stream options</B>: <TT>Options</TT> is a list of stream options. If
this list contains contradictory options, the rightmost option is the one
which applies. Possible options are:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>type(text</TT>/<TT>binary)</TT>: specifies whether the
stream is a text stream or a binary stream. The default value is
<TT>text</TT>.</LI><LI CLASS="li-itemize"><TT>reposition(true</TT>/<TT>false)</TT>: specifies
whether it is possible to reposition the stream. The default value is
<TT>true</TT> except if the stream cannot be repositioned (e.g. a terminal).</LI><LI CLASS="li-itemize"><TT>eof_action(error</TT>/<TT>eof_code</TT>/<TT>reset)</TT>:
specifies the effect of attempting to input from a stream whose stream
position is past-end-of-stream:<UL CLASS="itemize"><LI CLASS="li-itemize"><TT>error</TT>: a <TT>permission_error</TT> is raised signifying that
no more input exists in this stream.</LI><LI CLASS="li-itemize"><TT>eof_code</TT>: the result of input is as if the stream position
is end-of-stream.</LI><LI CLASS="li-itemize"><TT>reset</TT>: the stream position is reset so that it is not
past-end-of-stream, and another attempt is made to input from it (this is
useful when inputting from a terminal).</LI></UL><P>The default value is <TT>eof_code</TT>.</P></LI><LI CLASS="li-itemize"><TT>alias(Alias)</TT>: specifies that the atom <TT>Alias</TT>
is to be an alias for the stream. By default no alias is attached to the
stream. Several aliases can be defined for a same stream.</LI><LI CLASS="li-itemize"><TT>mirror(Mirror)</TT>: specifies the stream associated with
the stream-term or alias <TT>Mirror</TT> is a mirror for the stream. By
default no mirror is attached to the stream. Several mirrors can be defined
for a same stream.</LI><LI CLASS="li-itemize"><TT>buffering(none</TT>/<TT>line</TT>/<TT>block)</TT>:
specifies which type of buffering is used by input/output operations on
this stream:<UL CLASS="itemize"><LI CLASS="li-itemize"><TT>none</TT>: no buffering.</LI><LI CLASS="li-itemize"><TT>line</TT>: output operations buffer data emitted until a new-line
occurs</LI><LI CLASS="li-itemize"><TT>block</TT>: input/output operations buffer data until a given
number (implementation dependant) of characters/bytes have been treated.</LI></UL><P>The default value is <TT>line</TT> for a terminal (TTY), <TT>block</TT>
otherwise.</P></LI></UL><P><TT>open(SourceSink, Mode, Stream)</TT> is equivalent to
<TT>open(SourceSink, Mode, Stream, [])</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SourceSink</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Mode</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Options</TT> is a partial list or a list with an element
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Mode</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Mode)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Options</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Options)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Stream</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(variable, Stream)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SourceSink</TT> is neither a variable nor a source/sink</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(source_sink, SourceSink)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Mode</TT> is an atom but not an input/output mode</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(io_mode, Mode)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Options</TT> list is neither a
variable nor a stream-option</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_option, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
the source/sink specified by <TT>SourceSink</TT> does not exist</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(source_sink, SourceSink)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
the source/sink specified by <TT>SourceSink</TT> cannot be opened</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(open, source_sink, SourceSink)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Options</TT> list is
<TT>alias(A)</TT> and <TT>A</TT> is already associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(open, source_sink, alias(A))</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Options</TT> list is
<TT>mirror(M)</TT> and <TT>M</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, M)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Options</TT> list is
<TT>mirror(M)</TT> and <TT>M</TT> is an input stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(output, stream, M)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Options</TT> list is
<TT>reposition(true)</TT> and it is not possible to reposition this stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(open, source_sink, reposition(true))</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicates. The <TT>mirror</TT> and <TT>buffering</TT> stream options
are GNU Prolog extensions.</P><!--TOC subsubsection <TT>close/2</TT>,
<TT>close/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc120">8.10.7</A>&#XA0;&#XA0;<TT>close/2</TT>,
<TT>close/1</TT></H4><!--SEC END --><P>
<A NAME="close/2"></A>

</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
close(+stream_or_alias, +close_option_list)<BR>
close(+stream_or_alias)</TT></DD></DL><P><B>Description</B></P><P><TT>close(SorA, Options)</TT> closes the stream associated with the stream-term
or alias <TT>SorA</TT>. If <TT>SorA</TT> is the standard input stream or the
standard output stream <TT>close/2</TT> simply succeeds else the associated
source/sink is physically closed. If <TT>SorA</TT> is the current input
stream the current input stream becomes the standard input stream
<TT>user_input</TT>. If <TT>SorA</TT> is the current output stream the
current output stream becomes the standard output stream
<TT>user_output</TT>.</P><P><B>Close options</B>: <TT>Options</TT> is a list of close options. For the
moment only one option is available:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>force(true</TT>/<TT>false)</TT>: with <TT>false</TT>, if
an error occurs when trying to close the source/sink, the stream is not
closed and an error (<TT>system_error</TT> or <TT>resource_error</TT>) is
raised (but <TT>close/2</TT> succeeds). With <TT>true</TT>, if an error
occurs it is ignored and the stream is closed. The purpose of
<TT>force/1</TT> option is to allow an error handling routine to do its best
to reclaim resources. The default value is <TT>false</TT>.</LI></UL><P><TT>close(SorA)</TT> is equivalent to <TT>close(SorA, [])</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Options</TT> is a partial list or a list with an element
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Options</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Options)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Options</TT> list is neither a
variable nor a close-option</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(close_option, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> needs a special close (section&#XA0;<A HREF="#Constant-term-streams">8.11</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(needs_special_close)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicates. The <TT>system_error(needs_special_close)</TT> is a
GNU Prolog extension.</P><!--TOC subsubsection <TT>flush_output/1</TT>,
<TT>flush_output/0</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc121">8.10.8</A>&#XA0;&#XA0;<TT>flush_output/1</TT>,
<TT>flush_output/0</TT></H4><!--SEC END --><P>
<A NAME="flush-output/1"></A>

</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
flush_output(+stream_or_alias)<BR>
flush_output</TT></DD></DL><P><B>Description</B></P><P><TT>flush_output(SorA)</TT> sends any buffered output characters/bytes to
the stream.</P><P><TT>flush_output/0</TT> applies to the current output stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an input stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(output, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicates.</P><!--TOC subsubsection <TT>current_stream/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc122">8.10.9</A>&#XA0;&#XA0;<TT>current_stream/1</TT></H4><!--SEC END --><P>
<A NAME="current-stream/1"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
current_stream(?stream)</TT></DD></DL><P><B>Description</B></P><P><TT>current_stream(Stream)</TT> succeeds if there exists
a stream-term that unifies with <TT>Stream</TT>. This predicate is
re-executable on backtracking.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Stream</TT> is neither a variable nor a stream-term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream, Stream)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>stream_property/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc123">8.10.10</A>&#XA0;&#XA0;<TT>stream_property/2</TT></H4><!--SEC END --><P>
<A NAME="stream-property/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
stream_property(?stream, ?stream_property)</TT></DD></DL><P><B>Description</B></P><P><TT>stream_property(Stream, Property)</TT> succeeds if
<TT>current_stream(Stream)</TT> succeeds (section&#XA0;<A HREF="#current-stream/1">8.10.9</A>) and if
<TT>Property</TT> unifies with one of the properties of the stream. This
predicate is re-executable on backtracking.</P><P><B>Stream properties</B>:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>file_name(F)</TT>: the name of the connected
source/sink.</LI><LI CLASS="li-itemize"><TT>mode(M)</TT>: <TT>M</TT> is the open mode (<TT>read</TT>,
<TT>write</TT>, <TT>append</TT>).</LI><LI CLASS="li-itemize"><TT>input</TT>: if it is an input stream.</LI><LI CLASS="li-itemize"><TT>output</TT>: if it is an output stream.</LI><LI CLASS="li-itemize"><TT>alias(A)</TT>: <TT>A</TT> is an alias of the stream.</LI><LI CLASS="li-itemize"><TT>mirror(M)</TT>: <TT>M</TT> is a mirror stream of the
stream.</LI><LI CLASS="li-itemize"><TT>type(T)</TT>: <TT>T</TT> is the type of the stream
(<TT>text</TT>, <TT>binary</TT>).</LI><LI CLASS="li-itemize"><TT>reposition(R)</TT>: <TT>R</TT> is the reposition
boolean (<TT>true</TT>, <TT>false</TT>).</LI><LI CLASS="li-itemize"><TT>eof_action(A)</TT>: <TT>A</TT> is the end-of-file
action (<TT>error</TT>, <TT>eof_code</TT>, <TT>reset</TT>).</LI><LI CLASS="li-itemize"><TT>buffering(B)</TT>: <TT>B</TT> is the buffering mode
(<TT>none</TT>, <TT>line</TT>, <TT>block</TT>).</LI><LI CLASS="li-itemize"><TT>end_of_stream(E)</TT>: <TT>E</TT> is the
current end-of-stream status (<TT>not</TT>, <TT>at</TT>, <TT>past</TT>). If
the stream position is end-of-stream then <TT>E</TT> is unified with
<TT>at</TT> else if the stream position is past-end-of-stream then <TT>E</TT>
is unified with <TT>past</TT> else <TT>E</TT> is unified with <TT>not</TT>.</LI><LI CLASS="li-itemize"><TT>position(P)</TT>: <TT>P</TT> is the stream-position
term associated with the current position.</LI></UL><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Stream</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Stream</TT> is neither a variable nor a stream-term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream, Stream)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Property</TT> is neither a variable nor a stream property</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_property, Property)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Property</TT> = <TT>file_name(E)</TT>,<TT> mode(E)</TT>,
<TT>alias(E)</TT>, <TT>end_of_stream(E)</TT>, <TT>eof_action(E)</TT>,
<TT>reposition(E)</TT>, <TT>type(E)</TT> or <TT>buffering(E)</TT> and
<TT>E</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate. The <TT>buffering/1</TT> property is a GNU Prolog extension.</P><!--TOC subsubsection <TT>at_end_of_stream/1</TT>,
<TT>at_end_of_stream/0</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc124">8.10.11</A>&#XA0;&#XA0;<TT>at_end_of_stream/1</TT>,
<TT>at_end_of_stream/0</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
at_end_of_stream(+stream_or_alias)<BR>
at_end_of_stream</TT></DD></DL><P><B>Description</B></P><P><TT>at_end_of_stream(SorA)</TT> succeeds if the stream associated with
stream-term or alias <TT>SorA</TT> has a stream position end-of-stream or
past-end-of-stream. This predicate can be defined using
<TT>stream_property/2</TT> (section&#XA0;<A HREF="#stream-property/2">8.10.10</A>).</P><P><TT>at_end_of_stream/0</TT> applies to the current input stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an output stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicates. The <TT>permission_error(input, stream, SorA)</TT> is a
GNU Prolog extension.</P><!--TOC subsubsection <TT>stream_position/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc125">8.10.12</A>&#XA0;&#XA0;<TT>stream_position/2</TT></H4><!--SEC END --><P>
<A NAME="stream-position/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
stream_position(+stream_or_alias, ?stream_position)</TT></DD></DL><P><B>Description</B></P><P><TT>stream_position(SorA, Position)</TT> succeeds unifying
<TT>Position</TT> with the stream-position term associated with the current
position of the stream-term or alias <TT>SorA</TT>. This predicate can be
defined using <TT>stream_property/2</TT> (section&#XA0;<A HREF="#stream-property/2">8.10.10</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Position</TT> is neither a variable nor a stream-position term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_position, Position)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>set_stream_position/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc126">8.10.13</A>&#XA0;&#XA0;<TT>set_stream_position/2</TT></H4><!--SEC END --><P>
<A NAME="set-stream-position/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
set_stream_position(+stream_or_alias, +stream_position)</TT></DD></DL><P><B>Description</B></P><P><TT>set_stream_position(SorA, Position)</TT> sets the position of
the stream associated with the stream-term or alias <TT>SorA</TT> to
<TT>Position</TT>. <TT>Position</TT> should have previously been returned by
<TT>stream_property/2</TT> (section&#XA0;<A HREF="#stream-property/2">8.10.10</A>) or by
<TT>stream_position/2</TT> (section&#XA0;<A HREF="#stream-position/2">8.10.12</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Position</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Position</TT> is neither a variable nor a stream-position term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_position, Position)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> has stream property <TT>reposition(false)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(reposition, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>seek/4</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc127">8.10.14</A>&#XA0;&#XA0;<TT>seek/4</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
seek(+stream_or_alias, +stream_seek_method, +integer, ?integer)</TT></DD></DL><P><B>Description</B></P><P><TT>seek(SorA, Whence, Offset, NewOffset)</TT> sets the position of
the stream associated with the stream-term or alias <TT>SorA</TT> to
<TT>Offset</TT> according to <TT>Whence</TT> and unifies <TT>NewOffset</TT>
with the new offset from the beginning of the file. <TT>seek/4</TT> can only
be used on binary streams. <TT>Whence</TT> is an atom from:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>bof</TT>: the position is set relatively to the begin of the file
(<TT>Offset</TT> should be &#X2265; 0).</LI><LI CLASS="li-itemize"><TT>current</TT>: the position is set relatively to the current
position (<TT>Offset</TT> can be &#X2265; 0 or &#X2264; 0).</LI><LI CLASS="li-itemize"><TT>eof</TT>: the position is set relatively to the end of the file
(<TT>Offset</TT> should be &#X2264; 0).</LI></UL><P>This predicate is an interface to the C Unix function <TT>lseek(2)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Whence</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Offset</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Whence</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Whence)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Whence</TT> is an atom but not a valid stream seek method</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_seek_method, Whence)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Offset</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Offset)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>NewOffset</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, NewOffset)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> has stream property <TT>reposition(false)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(reposition, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a text stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(reposition, text_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>character_count/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc128">8.10.15</A>&#XA0;&#XA0;<TT>character_count/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
character_count(+stream_or_alias, ?integer)</TT></DD></DL><P><B>Description</B></P><P><TT>character_count(SorA, Count)</TT> unifies <TT>Count</TT> with the
number of characters/bytes read/written on the stream associated with
stream-term or alias <TT>SorA</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Count</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Count)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>line_count/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc129">8.10.16</A>&#XA0;&#XA0;<TT>line_count/2</TT></H4><!--SEC END --><P>
<A NAME="line-count/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
line_count(+stream_or_alias, ?integer)</TT></DD></DL><P><B>Description</B></P><P><TT>line_count(SorA, Count)</TT> unifies <TT>Count</TT> with the number of
lines read/written on the stream associated with the stream-term or alias
<TT>SorA</TT>. This predicate can only be used on text streams.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Count</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Count)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a binary stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(access, binary_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>line_position/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc130">8.10.17</A>&#XA0;&#XA0;<TT>line_position/2</TT></H4><!--SEC END --><P>
<A NAME="line-position/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
line_position(+stream_or_alias, ?integer)</TT></DD></DL><P><B>Description</B></P><P><TT>line_position(SorA, Count)</TT> unifies
<TT>Count</TT> with the number of characters read/written on the current
line of the stream associated with the stream-term or alias
<TT>SorA</TT>. This predicate can only be used on text streams.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Count</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Count)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a binary stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(access, binary_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>stream_line_column/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc131">8.10.18</A>&#XA0;&#XA0;<TT>stream_line_column/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
stream_line_column(+stream_or_alias, ?integer, ?integer)</TT></DD></DL><P><B>Description</B></P><P><TT>stream_line_column(SorA, Line, Column)</TT> unifies <TT>Line</TT>
(resp. <TT>Column</TT>) with the current line number (resp. column number)
of the stream associated with the stream-term or alias <TT>SorA</TT>. This
predicate can only be used on text streams. Note that <TT>Line</TT>
corresponds to the value returned by <TT>line_count/2</TT> + 1
(section&#XA0;<A HREF="#line-count/2">8.10.16</A>) and <TT>Column</TT> to the value returned
by <TT>line_position/2</TT> + 1 (section&#XA0;<A HREF="#line-position/2">8.10.17</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Line</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Line)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Column</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Column)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a binary stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(access, binary_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>set_stream_line_column/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc132">8.10.19</A>&#XA0;&#XA0;<TT>set_stream_line_column/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
set_stream_line_column(+stream_or_alias, +integer, +integer)</TT></DD></DL><P><B>Description</B></P><P><TT>set_stream_line_column(SorA, Line, Column)</TT> sets the stream
position of the stream associated with the stream-term or alias <TT>SorA</TT>
according to the line number <TT>Line</TT> and the column number
<TT>Column</TT>. This predicate can only be used on text streams. It first
repositions the stream to the beginning of the file and then reads character
by character until the required position is reached.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Line</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Column</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Line</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Line)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Column</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Column)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a binary stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(reposition, binary_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> has stream property <TT>reposition(false)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(reposition, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>add_stream_alias/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc133">8.10.20</A>&#XA0;&#XA0;<TT>add_stream_alias/2</TT></H4><!--SEC END --><P>
<A NAME="add-stream-alias/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
add_stream_alias(+stream_or_alias, +atom)</TT></DD></DL><P><B>Description</B></P><P><TT>add_stream_alias(SorA, Alias)</TT> adds <TT>Alias</TT> as a new alias
to the stream associated with the stream-term or alias <TT>SorA</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Alias</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Alias</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Alias)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Alias</TT> is already associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(add_alias, source_sink, alias(Alias))</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>current_alias/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc134">8.10.21</A>&#XA0;&#XA0;<TT>current_alias/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
current_alias(?stream, ?atom)</TT></DD></DL><P><B>Description</B></P><P><TT>current_alias(Stream, Alias)</TT> succeeds if
<TT>current_stream(Stream)</TT> succeeds (section&#XA0;<A HREF="#current-stream/1">8.10.9</A>) and if
<TT>Alias</TT> unifies with one of the aliases of the stream. It can be
defined using <TT>stream_property/2</TT> (section&#XA0;<A HREF="#stream-property/2">8.10.10</A>). This
predicate is re-executable on backtracking.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Stream</TT> is neither a variable nor a stream-term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream, Stream)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Alias</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Alias)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>add_stream_mirror/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc135">8.10.22</A>&#XA0;&#XA0;<TT>add_stream_mirror/2</TT></H4><!--SEC END --><P>
<A NAME="add-stream-mirror/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
add_stream_mirror(+stream_or_alias, +stream_or_alias)</TT></DD></DL><P><B>Description</B></P><P><TT>add_stream_mirror(SorA, Mirror)</TT> adds the stream associated with
the stream-term or alias <TT>Mirror</TT> as a new mirror to the stream
associated with the stream-term or alias <TT>SorA</TT>. After this, all
characters (or bytes) read from (or written to) <TT>SorA</TT> are also
written to <TT>Mirror</TT>. This mirroring occurs until <TT>Mirror</TT> is
explicitly removed using <TT>remove_stream_mirror/2</TT>
(section&#XA0;<A HREF="#remove-stream-mirror/2">8.10.23</A>) or implicitly when <TT>Mirror</TT> is closed.
Several mirror streams can be associated with a same stream. If <TT>Mirror</TT>
represents the same stream as <TT>SorA</TT> or if <TT>Mirror</TT> is already
a mirror for <TT>SorA</TT>, no mirror is added.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Mirror</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Mirror</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, Mirror)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Mirror</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, Mirror)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Mirror</TT> is an input stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(output, stream, Mirror)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>remove_stream_mirror/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc136">8.10.23</A>&#XA0;&#XA0;<TT>remove_stream_mirror/2</TT></H4><!--SEC END --><P>
<A NAME="remove-stream-mirror/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
remove_stream_mirror(+stream_or_alias, +stream_or_alias)</TT></DD></DL><P><B>Description</B></P><P><TT>remove_stream_mirror(SorA, Mirror)</TT> removes the stream associated
with the stream-term or alias <TT>Mirror</TT> from the list of mirrors of the
stream associated with the stream-term or alias <TT>SorA</TT>. This predicate
fails if <TT>Mirror</TT> is not a mirror stream for <TT>SorA</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Mirror</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Mirror</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, Mirror)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Mirror</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, Mirror)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>current_mirror/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc137">8.10.24</A>&#XA0;&#XA0;<TT>current_mirror/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
current_mirror(?stream, ?stream)</TT></DD></DL><P><B>Description</B></P><P><TT>current_mirror(Stream, M)</TT> succeeds if
<TT>current_stream(Stream)</TT> succeeds (section&#XA0;<A HREF="#current-stream/1">8.10.9</A>) and if
<TT>M</TT> unifies with one of the mirrors of the stream. It can be
defined using <TT>stream_property/2</TT> (section&#XA0;<A HREF="#stream-property/2">8.10.10</A>). This
predicate is re-executable on backtracking.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Stream</TT> is neither a variable nor a stream-term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream, Stream)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>M</TT> is neither a variable nor a stream-term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream, M)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>set_stream_type/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc138">8.10.25</A>&#XA0;&#XA0;<TT>set_stream_type/2</TT></H4><!--SEC END --><P>
<A NAME="set-stream-type/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
set_stream_type(+stream_or_alias, +atom)</TT></DD></DL><P><B>Description</B></P><P><TT>set_stream_type(SorA, Type)</TT> updates the type associated with
stream-term or alias <TT>SorA</TT>. The value of <TT>Type</TT> is an atom in
<TT>text</TT> or <TT>binary</TT> as for <TT>open/4</TT> (section&#XA0;<A HREF="#open/4">8.10.6</A>).
The type of a stream can only be changed before any input/output operation
is executed.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Type</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Type</TT> is neither a variable nor a valid type</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_type, Type)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
An I/O operation has already been executed on <TT>SorA</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(modify, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>set_stream_eof_action/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc139">8.10.26</A>&#XA0;&#XA0;<TT>set_stream_eof_action/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
set_stream_eof_action(+stream_or_alias, +atom)</TT></DD></DL><P><B>Description</B></P><P><TT>set_stream_eof_action(SorA, Action)</TT>
updates the <TT>eof_action</TT> option associated with the stream-term or
alias <TT>SorA</TT>. The value of <TT>Action</TT> is one of the atoms
<TT>error</TT>, <TT>eof_code</TT>, <TT>reset</TT> as for <TT>open/4</TT> (section&#XA0;<A HREF="#open/4">8.10.6</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Action</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Action</TT> is neither a variable nor a valid eof action</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(eof_action, Action)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an output stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(modify, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>set_stream_buffering/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc140">8.10.27</A>&#XA0;&#XA0;<TT>set_stream_buffering/2</TT></H4><!--SEC END --><P>
<A NAME="set-stream-buffering/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
set_stream_buffering(+stream_or_alias, +atom)</TT></DD></DL><P><B>Description</B></P><P><TT>set_stream_buffering(SorA, Buffering)</TT>
updates the buffering mode associated with the stream-term or alias
<TT>SorA</TT>. The value of <TT>Buffering</TT> is one of the atoms
<TT>none</TT>, <TT>line</TT> or <TT>block</TT> as for <TT>open/4</TT>
(section&#XA0;<A HREF="#open/4">8.10.6</A>). This predicate may only be used after opening a stream
and before any other operations have been performed on it.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Buffering</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Buffering</TT> is neither a variable nor a valid buffering
mode</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(buffering_mode, Buffering)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsection Constant term streams-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc141">8.11</A>&#XA0;&#XA0;Constant term streams</H3><!--SEC END --><P>
<A NAME="Constant-term-streams"></A></P><!--TOC subsubsection Introduction-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc142">8.11.1</A>&#XA0;&#XA0;Introduction</H4><!--SEC END --><P>
<A NAME="Introduction:(Constant-term-streams)"></A>
Constant term streams allow the user to consider a constant term (atom,
character list or character code list) as a source/sink by associating to
them a stream. Reading from a constant term stream will deliver the
characters of the constant term as if they had been read from a standard
file. Characters written on a constant term stream are stored to form the
final constant term when the stream is closed. The built-in predicates
described in this section allow the user to open and close a constant term
stream for input or output. However, very often, a constant term stream is
created to be only read or written once and then closed. To avoid the
creation and the destruction of such a stream, GNU Prolog offers several
built-in predicates to perform single input/output from/to constant terms
(section&#XA0;<A HREF="#Input/output-from/to-constant-terms">8.15</A>).</P><!--TOC subsubsection <TT>open_input_atom_stream/2</TT>,
<TT>open_input_chars_stream/2</TT>,<BR>
 <TT>open_input_codes_stream/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc143">8.11.2</A>&#XA0;&#XA0;<TT>open_input_atom_stream/2</TT>,
<TT>open_input_chars_stream/2</TT>,<BR>
 <TT>open_input_codes_stream/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
open_input_atom_stream(+atom, -stream)<BR>
open_input_chars_stream(+character_list, -stream)<BR>
open_input_codes_stream(+character_code_list, -stream)</TT></DD></DL><P><B>Description</B></P><P><TT>open_input_atom_stream(Atom, Stream)</TT> unifies <TT>Stream</TT>
with the stream-term which is associated with a new input text-stream whose
data are the characters of <TT>Atom</TT>.</P><P><TT>open_input_chars_stream(Chars, Stream)</TT> is similar to
<TT>open_input_atom_stream/2</TT> except that data are the content of the
character list <TT>Chars</TT>.</P><P><TT>open_input_codes_stream(Codes, Stream)</TT> is similar to
<TT>open_input_atom_stream/2</TT> except that data are the content of the
character code list <TT>Codes</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Stream</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(variable, Stream)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Chars</TT> is a partial list or a list with an element
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Codes</TT> is a partial list or a list with an element
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is neither a variable nor a an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Atom)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Chars</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Chars)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Codes</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Codes)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Chars</TT> list is neither a
variable nor a character</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(character, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Codes</TT> list is neither a
variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Codes</TT> list is an integer but
not a character code</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(character_code)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>close_input_atom_stream/1</TT>,
<TT>close_input_chars_stream/1</TT>,<BR>
 <TT>close_input_codes_stream/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc144">8.11.3</A>&#XA0;&#XA0;<TT>close_input_atom_stream/1</TT>,
<TT>close_input_chars_stream/1</TT>,<BR>
 <TT>close_input_codes_stream/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
close_input_atom_stream(+stream_or_alias)<BR>
close_input_chars_stream(+stream_or_alias)<BR>
close_input_codes_stream(+stream_or_alias)</TT></DD></DL><P><B>Description</B></P><P><TT>close_input_atom_stream(SorA)</TT> closes the constant term stream
associated with the stream-term or alias <TT>SorA</TT>. <TT>SorA</TT> must a
stream open with <TT>open_input_atom_stream/2</TT>
(section&#XA0;<A HREF="#Introduction:(Constant-term-streams)">8.11.1</A>).</P><P><TT>close_input_chars_stream(SorA)</TT> acts similarly for a character
list stream.</P><P><TT>close_input_codes_stream(SorA)</TT> acts similarly for a character
code list stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an output stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(close, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a stream-term or alias but does not refer to a
constant term stream.</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(term_stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>open_output_atom_stream/1</TT>,
<TT>open_output_chars_stream/1</TT>,<BR>
 <TT>open_output_codes_stream/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc145">8.11.4</A>&#XA0;&#XA0;<TT>open_output_atom_stream/1</TT>,
<TT>open_output_chars_stream/1</TT>,<BR>
 <TT>open_output_codes_stream/1</TT></H4><!--SEC END --><P>
<A NAME="open-output-atom-stream/1"></A>


</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
open_output_atom_stream(-stream)<BR>
open_output_chars_stream(-stream)<BR>
open_output_codes_stream(-stream)</TT></DD></DL><P><B>Description</B></P><P><TT>open_output_atom_stream(Stream)</TT> unifies <TT>Stream</TT> with the
stream-term which is associated with a new output text-stream. All characters
written to this stream are collected and will be returned as an atom when
the stream is closed by <TT>close_output_atom_stream/2</TT>
(section&#XA0;<A HREF="#close-output-atom-stream/2">8.11.5</A>).</P><P><TT>open_output_chars_stream(Stream)</TT> is similar to
<TT>open_output_atom_stream/1</TT> except that the result will be a
character list.</P><P><TT>open_output_codes_stream(Stream)</TT> is similar to
<TT>open_output_atom_stream/1</TT> except that the result will be a
character code list.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Stream</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(variable, Stream)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>close_output_atom_stream/2</TT>,
<TT>close_output_chars_stream/2</TT>,<BR>
 <TT>close_output_codes_stream/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc146">8.11.5</A>&#XA0;&#XA0;<TT>close_output_atom_stream/2</TT>,
<TT>close_output_chars_stream/2</TT>,<BR>
 <TT>close_output_codes_stream/2</TT></H4><!--SEC END --><P>
<A NAME="close-output-atom-stream/2"></A>


</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
close_output_atom_stream(+stream_or_alias, ?atom)<BR>
close_output_chars_stream(+stream_or_alias, ?character_list)<BR>
close_output_codes_stream(+stream_or_alias, ?character_code_list)</TT></DD></DL><P><B>Description</B></P><P><TT>close_output_atom_stream(SorA, Atom)</TT> closes the constant term
stream associated with the stream-term or alias <TT>SorA</TT>. <TT>SorA</TT> must
be associated with a stream open with <TT>open_output_atom_stream/1</TT>
(section&#XA0;<A HREF="#open-output-atom-stream/1">8.11.4</A>). <TT>Atom</TT> is unified with an atom
formed with all characters written on the stream.</P><P><TT>close_output_chars_stream(SorA, Chars)</TT> acts similarly for a
character list stream.</P><P><TT>close_output_codes_stream(SorA, Codes)</TT> acts similarly for a
character code list stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Atom)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Chars</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Chars)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Codes</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Codes)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Chars</TT> list is neither a
variable nor a character</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(character, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Codes</TT> list is neither a
variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Codes</TT> list is an integer but
not a character code</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(character_code)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an input stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(close, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a stream-term or alias but does not refer to a
constant term stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(term_stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsection Character input/output-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc147">8.12</A>&#XA0;&#XA0;Character input/output</H3><!--SEC END --><P>
These built-in predicates enable a single character or character code to be
input from and output to a text stream. The atom <TT>end_of_file</TT> is
returned as character to indicate the end-of-file. <TT>-1</TT> is returned
as character code to indicate the end-of-file.</P><!--TOC subsubsection <TT>get_char/2</TT>,
<TT>get_char/1</TT>,
<TT>get_code/1</TT>,
<TT>get_code/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc148">8.12.1</A>&#XA0;&#XA0;<TT>get_char/2</TT>,
<TT>get_char/1</TT>,
<TT>get_code/1</TT>,
<TT>get_code/2</TT></H4><!--SEC END --><P>
<A NAME="get-char/2"></A>



</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
get_char(+stream_or_alias, ?in_character)<BR>
get_char(?in_character)<BR>
get_code(+stream_or_alias, ?in_character_code)<BR>
get_code(?in_character_code)</TT></DD></DL><P><B>Description</B></P><P><TT>get_char(SorA, Char)</TT> succeeds if <TT>Char</TT> unifies with the
next character read from the stream associated with the stream-term or alias
<TT>SorA</TT>.</P><P><TT>get_code/2</TT> is similar to <TT>get_char/2</TT> but deals with
character codes.</P><P><TT>get_char/1</TT> and <TT>get_code/1</TT> apply to the current input
stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Char</TT> is neither a variable nor an in-character</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(in_character, Char)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Code</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Code)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an output stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a binary stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, binary_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> has stream properties <TT>end_of_stream(past)</TT>
and <TT>eof_action(error)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, past_end_of_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
The entity input from the stream is not a character</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(character)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Code</TT> is an integer but not an in-character code</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(in_character_code)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicates.</P><!--TOC subsubsection <TT>get_key/2</TT>,
<TT>get_key/1</TT>
	 <TT>get_key_no_echo/2</TT>,
<TT>get_key_no_echo/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc149">8.12.2</A>&#XA0;&#XA0;<TT>get_key/2</TT>,
<TT>get_key/1</TT>
	 <TT>get_key_no_echo/2</TT>,
<TT>get_key_no_echo/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
get_key(+stream_or_alias, ?integer)<BR>
get_key(?integer)<BR>
get_key_no_echo(+stream_or_alias, ?integer)<BR>
get_key_no_echo(?integer)</TT></DD></DL><P><B>Description</B></P><P><TT>get_key(SorA, Code)</TT> succeeds if <TT>Code</TT> unifies with the
character code of the next key read from the stream associated with the
stream-term or alias <TT>SorA</TT>. It is intended to read a single key from
the keyboard (thus <TT>SorA</TT> should refer to current input stream). No
buffering is performed (a character is read as soon as available) and
function keys can also be read (in that case, <TT>Code</TT> is an integer &gt;
255). The read character is echoed if it is printable.</P><P>This facility is only possible if the <TT>linedit</TT> facility has been
installed (section&#XA0;<A HREF="#The-line-editor">4.2.6</A>) otherwise <TT>get_key/2</TT> behaves
similarly to <TT>get_code/2</TT> (section&#XA0;<A HREF="#get-char/2">8.12.1</A>) (the code of the first
character is returned) but also pumps remaining characters until a character
&lt; space (0x20) is read (in particular RETURN). The same behavior
occurs if <TT>SorA</TT> does not refer to the current input stream or if
this stream is not attached to a terminal.</P><P><TT>get_key_no_echo/2</TT> behaves similarly to <TT>get_key/2</TT>
except that the read character is not echoed.</P><P><TT>get_key/1</TT> and <TT>get_key_no_echo/1</TT> apply to the current
input stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Code</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Code)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an output stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a binary stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, binary_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> has stream properties <TT>end_of_stream(past)</TT>
and <TT>eof_action(error)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, past_end_of_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>peek_char/2</TT>,
<TT>peek_char/1</TT>,
<TT>peek_code/1</TT>,
<TT>peek_code/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc150">8.12.3</A>&#XA0;&#XA0;<TT>peek_char/2</TT>,
<TT>peek_char/1</TT>,
<TT>peek_code/1</TT>,
<TT>peek_code/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
peek_char(+stream_or_alias, ?in_character)<BR>
peek_char(?in_character)<BR>
peek_code(+stream_or_alias, ?in_character_code)<BR>
peek_code(?in_character_code)</TT></DD></DL><P><B>Description</B></P><P><TT>peek_char(SorA, Char)</TT> succeeds if <TT>Char</TT> unifies with the
next character that will be read from the stream associated with the stream-term
or alias <TT>SorA</TT>. The character is not read.</P><P><TT>peek_code/2</TT> is similar to <TT>peek_char/2</TT> but deals with
character codes.</P><P><TT>peek_char/1</TT> and <TT>peek_code/1</TT> apply to the current input
stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Char</TT> is neither a variable nor an in-character</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(in_character, Char)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Code</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Code)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an output stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a binary stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, binary_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> has stream properties <TT>end_of_stream(past)</TT>
and <TT>eof_action(error)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, past_end_of_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
The entity input from the stream is not a character</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(character)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Code</TT> is an integer but not an in-character code</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(in_character_code)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicates.</P><!--TOC subsubsection <TT>unget_char/2</TT>,
<TT>unget_char/1</TT>,
<TT>unget_code/2</TT>,
<TT>unget_code/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc151">8.12.4</A>&#XA0;&#XA0;<TT>unget_char/2</TT>,
<TT>unget_char/1</TT>,
<TT>unget_code/2</TT>,
<TT>unget_code/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
unget_char(+stream_or_alias, +character)<BR>
unget_char(+character)<BR>
unget_code(+stream_or_alias, +character_code)<BR>
unget_code(+character_code)</TT></DD></DL><P><B>Description</B></P><P><TT>unget_char(SorA, Char)</TT> pushes back <TT>Char</TT>
onto the stream associated with the stream-term or alias <TT>SorA</TT>.
<TT>Char</TT> will be the next character read by <TT>get_char/2</TT>. The
maximum number of characters that can be cumulatively pushed back is given by
the <TT>max_unget</TT> Prolog flag (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>).</P><P><TT>unget_code/2</TT> is similar to <TT>unget_char/2</TT> but deals with
character codes.</P><P><TT>unget_char/1</TT> and <TT>unget_code/1</TT> apply to the current input
stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Char</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Code</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Char</TT> is neither a variable nor a character</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(character, Char)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Code</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Code)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an output stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a binary stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, binary_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Code</TT> is an integer but not a character code</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(character_code)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>put_char/2</TT>,
<TT>put_char/1</TT>,
<TT>put_code/1</TT>,
<TT>put_code/2</TT>,
<TT>nl/1</TT>,
<TT>nl/0</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc152">8.12.5</A>&#XA0;&#XA0;<TT>put_char/2</TT>,
<TT>put_char/1</TT>,
<TT>put_code/1</TT>,
<TT>put_code/2</TT>,
<TT>nl/1</TT>,
<TT>nl/0</TT></H4><!--SEC END --><P>
<A NAME="put-char/2"></A>





</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
put_char(+stream_or_alias, +character)<BR>
put_char(+character)<BR>
put_code(+stream_or_alias, +character_code)<BR>
put_code(+character_code)<BR>
nl(+stream_or_alias)<BR>
nl</TT></DD></DL><P><B>Description</B></P><P><TT>put_char(SorA, Char)</TT> writes <TT>Char</TT> onto the
stream associated with the stream-term or alias <TT>SorA</TT>.</P><P><TT>put_code/2</TT> is similar to <TT>put_char/2</TT> but deals with
character codes.</P><P><TT>nl(SorA)</TT> writes a new-line character onto the stream
associated with the stream-term or alias <TT>SorA</TT>. This is equivalent to
<TT>put_char(SorA, &#X2019;\n&#X2019;)</TT>.</P><P><TT>put_char/1</TT>, <TT>put_code/1</TT> and <TT>nl/0</TT> apply to the
current output stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Char</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Code</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Char</TT> is neither a variable nor a character</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(character, Char)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Code</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Code)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an input stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(output, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a binary stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(output, binary_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Code</TT> is an integer but not a character code</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(character_code)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicates.</P><!--TOC subsection Byte input/output-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc153">8.13</A>&#XA0;&#XA0;Byte input/output</H3><!--SEC END --><P>
<A NAME="Byte-input/output"></A></P><P>These built-in predicates enable a single byte to be input from and output
to a binary stream. <TT>-1</TT> is returned to indicate the end-of-file.</P><!--TOC subsubsection <TT>get_byte/2</TT>,
<TT>get_byte/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc154">8.13.1</A>&#XA0;&#XA0;<TT>get_byte/2</TT>,
<TT>get_byte/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
get_byte(+stream_or_alias, ?in_byte)<BR>
get_byte(?in_byte)</TT></DD></DL><P><B>Description</B></P><P><TT>get_byte(SorA, Byte)</TT> succeeds if <TT>Byte</TT> unifies with the
next byte read from the stream associated with the stream-term or alias
<TT>SorA</TT>.</P><P><TT>get_byte/1</TT> applies to the current input stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Byte</TT> is neither a variable nor an in-byte</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(in_byte, Byte)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an output stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a text stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, text_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> has stream properties <TT>end_of_stream(past)</TT>
and <TT>eof_action(error)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, past_end_of_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicates.</P><!--TOC subsubsection <TT>peek_byte/2</TT>,
<TT>peek_byte/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc155">8.13.2</A>&#XA0;&#XA0;<TT>peek_byte/2</TT>,
<TT>peek_byte/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
peek_byte(+stream_or_alias, ?in_byte)<BR>
peek_byte(?in_byte)</TT></DD></DL><P><B>Description</B></P><P><TT>peek_byte(SorA, Byte)</TT> succeeds if <TT>Byte</TT> unifies with the
next byte that will be read from the stream associated with the stream-term or
alias <TT>SorA</TT>. The byte is not read.</P><P><TT>peek_byte/1</TT> applies to the current input stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Byte</TT> is neither a variable nor an in-byte</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(in_byte, Byte)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an output stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a text stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, text_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> has stream properties <TT>end_of_stream(past)</TT>
and <TT>eof_action(error)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, past_end_of_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicates.</P><!--TOC subsubsection <TT>unget_byte/2</TT>,
<TT>unget_byte/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc156">8.13.3</A>&#XA0;&#XA0;<TT>unget_byte/2</TT>,
<TT>unget_byte/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
unget_byte(+stream_or_alias, +byte)<BR>
unget_byte(+byte)</TT></DD></DL><P><B>Description</B></P><P><TT>unget_byte(SorA, Byte)</TT> pushes back <TT>Byte</TT> onto the stream
associated with the stream-term or alias <TT>SorA</TT>. <TT>Byte</TT> will be
the next byte read by <TT>get_byte/2</TT>. The maximum number of bytes that
can be successively pushed back is given by the <TT>max_unget</TT>
Prolog flag (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>).</P><P><TT>unget_byte/1</TT> applies to the current input stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Byte</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Byte</TT> is neither a variable nor a byte</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(byte, Byte)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an output stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a text stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, text_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>put_byte/2</TT>,
<TT>put_byte/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc157">8.13.4</A>&#XA0;&#XA0;<TT>put_byte/2</TT>,
<TT>put_byte/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
put_byte(+stream_or_alias, +byte)<BR>
put_byte(+byte)</TT></DD></DL><P><B>Description</B></P><P><TT>put_byte(SorA, Byte)</TT> writes <TT>Byte</TT> onto the stream
associated with the stream-term or alias <TT>SorA</TT>.</P><P><TT>put_byte/1</TT> applies to the current output stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Byte</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Byte</TT> is neither a variable nor a byte</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(byte, Byte)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an output stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(output, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a text stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(output, text_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsection Term input/output-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc158">8.14</A>&#XA0;&#XA0;Term input/output</H3><!--SEC END --><P>
<A NAME="Term-input/output"></A>
These built-in predicates enable a Prolog term to be input from or output to
a text stream. The atom <TT>end_of_file</TT> is returned as term to
indicate the end-of-file. The syntax of such terms can also be altered by
changing the operators (section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>), and making some
characters equivalent to others (section&#XA0;<A HREF="#char-conversion/2">8.14.12</A>) if the
<TT>char_conversion</TT> Prolog flag is <TT>on</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>). Double quoted tokens will be returned as an atom
or a character list or a character code list depending on the value of the
<TT>double_quotes</TT> Prolog flag (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>). Similarly, back quoted tokens are returned depending on the value of the
<TT>back_quotes</TT> Prolog flag.</P><!--TOC subsubsection <TT>read_term/3</TT>,
<TT>read_term/2</TT>,
<TT>read/2</TT>,
<TT>read/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc159">8.14.1</A>&#XA0;&#XA0;<TT>read_term/3</TT>,
<TT>read_term/2</TT>,
<TT>read/2</TT>,
<TT>read/1</TT></H4><!--SEC END --><P>
<A NAME="read-term/3"></A>



</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
read_term(+stream_or_alias, ?term, +read_option_list)<BR>
read_term(?term, +read_option_list)<BR>
read(+stream_or_alias, ?term)<BR>
read(?term)</TT></DD></DL><P><B>Description</B></P><P><TT>read_term(SorA, Term, Options)</TT> is true if
<TT>Term</TT> unifies with the next term read from the stream associated
with the stream-term or alias <TT>SorA</TT> according to the options given by
<TT>Options</TT>.</P><P><B>Read options</B>: <TT>Options</TT> is a list of read options. If this
list contains contradictory options, the rightmost option is the one which
applies. Possible options are:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>variables(VL)</TT>: <TT>VL</TT> is unified with the
list of all variables of the input term, in left-to-right traversal
order. Anonymous variables are included in the list <TT>VL</TT>.</LI><LI CLASS="li-itemize"><TT>variable_names(VNL)</TT>: <TT>VNL</TT> is
unified with the list of pairs <TT>Name = Var</TT> where <TT>Var</TT> is a
named variable of the term and <TT>Name</TT> is the atom associated with the
name of <TT>Var</TT>. Anonymous variables are not included in the list
<TT>VNL</TT>.</LI><LI CLASS="li-itemize"><TT>singletons(SL)</TT>: <TT>SL</TT> is unified with the
list of pairs <TT>Name = Var</TT> where <TT>Var</TT> is a named variable
which occurs only once in the term and <TT>Name</TT> is the atom associated
to the name of <TT>Var</TT>. Anonymous variables are not included in the list
<TT>SL</TT>.</LI><LI CLASS="li-itemize"><TT>syntax_error(error</TT>/<TT>warning</TT>/<TT>fail)</TT>:
specifies the effect of a syntax error:<UL CLASS="itemize"><LI CLASS="li-itemize"><TT>error</TT>: a <TT>syntax_error</TT> is raised.</LI><LI CLASS="li-itemize"><TT>warning</TT>: a warning message is displayed and the predicate
fails.</LI><LI CLASS="li-itemize"><TT>fail</TT>: the predicate quietly fails.</LI></UL><P>The default value is the value of the <TT>syntax_error</TT>
Prolog flag (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>).</P></LI><LI CLASS="li-itemize"><TT>end_of_term(dot</TT>/<TT>eof)</TT>: specifies the
end-of-term delimiter: <TT>dot</TT> is the classical full-stop delimiter (a
dot followed with a layout character), <TT>eof</TT> is the end-of-file
delimiter. This option is useful for predicates like
<TT>read_term_from_atom/3</TT> (section&#XA0;<A HREF="#read-term-from-atom/3">8.15.1</A>) to avoid to add a
terminal dot at the end of the atom. The default value is <TT>dot</TT>.</LI></UL><P><TT>read(SorA, Term)</TT> is equivalent to
<TT>read_term(SorA, Term, [])</TT>.</P><P><TT>read_term/2</TT> and <TT>read/1</TT> apply to the current input stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Options</TT> is a partial list or a list with an element
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Options</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Options)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Options</TT> list is neither a
variable nor a valid read option</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(read_option, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an output stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a binary stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, binary_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> has stream properties <TT>end_of_stream(past)</TT>
and <TT>eof_action(error)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, past_end_of_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
a syntax error occurs and the value of the <TT>syntax_error</TT>
Prolog flag is <TT>error</TT> (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>syntax_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicates. The ISO reference raises a
<TT>representation_error(Flag)</TT> where <TT>Flag</TT> is
<TT>max_arity</TT>,<TT> max_integer</TT>, or<TT> min_integer</TT> when
the read term breaches an implementation defined limit specified by
<TT>Flag</TT>. GNU Prolog detects neither <TT>min_integer</TT> nor
<TT>max_integer</TT> violation and treats a <TT>max_arity</TT> violation
as a syntax error. The read options <TT>syntax_error</TT> and
<TT>end_of_term</TT> are GNU Prolog extensions.</P><!--TOC subsubsection <TT>read_atom/2</TT>,
<TT>read_atom/1</TT>,
<TT>read_integer/2</TT>,
<TT>read_integer/1</TT>,<BR>
 <TT>read_number/2</TT>,
<TT>read_number/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc160">8.14.2</A>&#XA0;&#XA0;<TT>read_atom/2</TT>,
<TT>read_atom/1</TT>,
<TT>read_integer/2</TT>,
<TT>read_integer/1</TT>,<BR>
 <TT>read_number/2</TT>,
<TT>read_number/1</TT></H4><!--SEC END --><P>
<A NAME="read-atom/2"></A>





</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
read_atom(+stream_or_alias, ?atom)<BR>
read_atom(?atom)<BR>
read_integer(+stream_or_alias, ?integer)<BR>
read_integer(?integer)<BR>
read_number(+stream_or_alias, ?number)<BR>
read_number(?number)</TT></DD></DL><P><B>Description</B></P><P><TT>read_atom(SorA, Atom)</TT> succeeds if <TT>Atom</TT>
unifies with the next atom read from the stream associated with the
stream-term or alias <TT>SorA</TT>.</P><P><TT>read_integer(SorA, Integer)</TT> succeeds if
<TT>Integer</TT> unifies with the next integer read from the stream
associated with the stream-term or alias <TT>SorA</TT>.</P><P><TT>read_number(SorA, Number)</TT> succeeds if
<TT>Number</TT> unifies with the next number (integer or floating point
number) read from the stream associated with the stream-term or alias
<TT>SorA</TT>.</P><P><TT>read_atom/1</TT>, <TT>read_integer/1</TT> and <TT>read_number/1</TT>
apply to the current input stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Atom)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Integer</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Integer)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Number</TT> is neither a variable nor a number</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(number, Number)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an output stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a binary stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, binary_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> has stream properties <TT>end_of_stream(past)</TT>
and <TT>eof_action(error)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, past_end_of_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
a syntax error occurs and the value of the <TT>syntax_error</TT>
Prolog flag is <TT>error</TT> (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>syntax_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>read_token/2</TT>,
<TT>read_token/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc161">8.14.3</A>&#XA0;&#XA0;<TT>read_token/2</TT>,
<TT>read_token/1</TT></H4><!--SEC END --><P>
<A NAME="read-token/2"></A>

</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
read_token(+stream_or_alias, ?nonvar)<BR>
read_token(?nonvar)</TT></DD></DL><P><B>Description</B></P><P><TT>read_token(SorA, Token)</TT> succeeds if <TT>Token</TT> unifies with
the encoding of the next Prolog token read from the stream associated with
stream-term or alias <TT>SorA</TT>.</P><P><B>Token encoding</B>:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>var(A)</TT>: a variable is read whose name is the atom
<TT>A</TT>.</LI><LI CLASS="li-itemize">an atom <TT>A</TT>: an atom <TT>A</TT> is read.</LI><LI CLASS="li-itemize">integer <TT>N</TT>: an integer <TT>N</TT> is read.</LI><LI CLASS="li-itemize">floating point number <TT>N</TT>: a floating point number <TT>N</TT>
is read.</LI><LI CLASS="li-itemize"><TT>string(A)</TT>: a string (double quoted item) is read whose
characters forms the atom <TT>A</TT>.</LI><LI CLASS="li-itemize"><TT>punct(P)</TT>: a punctuation character <TT>P</TT> is read
(<TT>P</TT> is a one-character atom in <TT>()[]{|}</TT>, the atom
<TT>full_stop</TT> or the atom <TT>end_of_file</TT>).</LI><LI CLASS="li-itemize"><TT>back_quotes(A)</TT>: a back quoted item is read
whose characters forms the atom <TT>A</TT>.</LI><LI CLASS="li-itemize"><TT>extended(A)</TT>: an extended character <TT>A</TT> (an
atom) is read.</LI></UL><P>As for <TT>read_term/3</TT>, the behavior of <TT>read_token/2</TT> can be
affected by some Prolog flags (section&#XA0;<A HREF="#Term-input/output">8.14</A>).</P><P><TT>read_token/1</TT> applies to the current input stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an output stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a binary stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, binary_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> has stream properties <TT>end_of_stream(past)</TT>
and <TT>eof_action(error)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, past_end_of_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
a syntax error occurs and the value of the <TT>syntax_error</TT>
Prolog flag is <TT>error</TT> (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>syntax_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>syntax_error_info/4</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc162">8.14.4</A>&#XA0;&#XA0;<TT>syntax_error_info/4</TT></H4><!--SEC END --><P>
<A NAME="syntax-error-info/4"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
syntax_error_info(?atom, ?integer, ?integer, ?atom)</TT></DD></DL><P><B>Description</B></P><P><TT>syntax_error_info(FileName, Line, Column, Error)</TT> returns the
information associated with the last syntax error. <TT>Line</TT> is the line
number of the error, <TT>Column</TT> is the column number of the error and
<TT>Error</TT> is an atom explaining the error.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>FileName</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, FileName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Line</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Line)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Column</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Column)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Error</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Error)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>last_read_start_line_column/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc163">8.14.5</A>&#XA0;&#XA0;<TT>last_read_start_line_column/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
last_read_start_line_column(?integer, ?integer)</TT></DD></DL><P><B>Description</B></P><P><TT>last_read_start_line_column(Line, Column)</TT> unifies <TT>Line</TT>
and <TT>Column</TT> with the line number and the column number associated with
the start of the last read predicate. This predicate can be used after
calling one of the following predicates: <TT>read_term/3</TT>,
<TT>read_term/2</TT>, <TT>read/2</TT>, <TT>read/1</TT>
(section&#XA0;<A HREF="#read-term/3">8.14.1</A>), <TT>read_atom/2</TT>, <TT>read_atom/1</TT>,
<TT>read_integer/2</TT>, <TT>read_integer/1</TT>, <TT>read_number/2</TT>,
<TT>read_number/1</TT> (section&#XA0;<A HREF="#read-atom/2">8.14.2</A>) or <TT>read_token/2</TT>,
<TT>read_token/1</TT> (section&#XA0;<A HREF="#read-token/2">8.14.3</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Line</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Line)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Column</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Column)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection 
<TT>write_term/3</TT>,
<TT>write_term/2</TT>,
<TT>write/2</TT>,
<TT>write/1</TT>,
<TT>writeq/2</TT>,
<TT>writeq/1</TT>,<BR>
 <TT>write_canonical/2</TT>,
<TT>write_canonical/1</TT>,
<TT>display/2</TT>,
<TT>display/1</TT>,
<TT>print/2</TT>,<BR>
 <TT>print/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc164">8.14.6</A>&#XA0;&#XA0;
<TT>write_term/3</TT>,
<TT>write_term/2</TT>,
<TT>write/2</TT>,
<TT>write/1</TT>,
<TT>writeq/2</TT>,
<TT>writeq/1</TT>,<BR>
 <TT>write_canonical/2</TT>,
<TT>write_canonical/1</TT>,
<TT>display/2</TT>,
<TT>display/1</TT>,
<TT>print/2</TT>,<BR>
 <TT>print/1</TT></H4><!--SEC END --><P>
<A NAME="write-term/3"></A>












</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
write_term(+stream_or_alias, ?term, +write_option_list)<BR>
write_term(?term, +write_option_list)<BR>
write(+stream_or_alias, ?term)<BR>
write(?term)<BR>
writeq(+stream_or_alias, ?term)<BR>
writeq(?term)<BR>
write_canonical(+stream_or_alias, ?term)<BR>
write_canonical(?term)<BR>
display(+stream_or_alias, ?term)<BR>
display(?term)<BR>
print(+stream_or_alias, ?term)<BR>
print(?term)</TT></DD></DL><P><B>Description</B></P><P><TT>write_term(SorA, Term, Options)</TT> writes
<TT>Term</TT> to the stream associated with the stream-term or alias
<TT>SorA</TT> according to the options given by <TT>Options</TT>.</P><P><B>Write options</B>: <TT>Options</TT> is a list of write options. If this
list contains contradictory options, the rightmost option is the one which
applies. Possible options are:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>quoted(true</TT>/<TT>false)</TT>: if <TT>true</TT> each
atom and functor is quoted if this would be necessary for the term to be
input by <TT>read_term/3</TT>. If <TT>false</TT> no extra quotes are
written. The default value is <TT>false</TT>.</LI><LI CLASS="li-itemize"><TT>ignore_ops(true</TT>/<TT>false)</TT>: if
<TT>true</TT> each compound term is output in functional notation (neither
operator notation nor list notation is used). If <TT>false</TT> operator and
list notations are used. The default value is <TT>false</TT>.</LI><LI CLASS="li-itemize"><TT>numbervars(true</TT>/<TT>false)</TT>: if
<TT>true</TT> a term of the form <TT>&#X2019;$VAR&#X2019;(N)</TT>, where <TT>N</TT> is an
integer, is output as a variable name (see below). If <TT>false</TT>
such a term is output normally (according to the other options). The
default value is <TT>false</TT>.</LI><LI CLASS="li-itemize"><TT>namevars(true</TT>/<TT>false)</TT>: if <TT>true</TT> a
term of the form <TT>&#X2019;$VARNAME&#X2019;(Name)</TT>, where <TT>Name</TT> is an atom 
respecting the syntax of variable names, is output as a variable name (see
below). If <TT>false</TT> such a term is output normally (according to the
other options). The default value is <TT>false</TT>.</LI><LI CLASS="li-itemize"><TT>variable_names(VNL)</TT>: <TT>VNL</TT> is
a list of pairs <TT>Name = Var</TT> where <TT>Var</TT> is a
variable and <TT>Name</TT> is the atom associated with the
name of <TT>Var</TT>. Each variable <TT>Var</TT> is written as atom
<TT>Name</TT> (with <TT>quoted(false)</TT>) iff a term 
<TT>Name = Var</TT> is an element of the list <TT>VNL</TT>. If <TT>Name</TT>
is not atom or does not respect the syntax of variable names the pair is
ignored. If several pairs exist for the same variable name the first one applies.</LI><LI CLASS="li-itemize"><TT>space_args(true</TT>/<TT>false)</TT>: if
<TT>true</TT> an extra space character is emitted after each comma
separating the arguments of a compound term in functional notation or of a
list. If <TT>false</TT> no extra space is emitted. The default value is
<TT>false</TT>.</LI><LI CLASS="li-itemize"><TT>portrayed(true</TT>/<TT>false)</TT>: if <TT>true</TT>
and if there exists a predicate <TT>portray/1</TT>, <TT>write_term/3</TT>
acts as follows: if <TT>Term</TT> is a variable it is simply written. If
<TT>Term</TT> is non-variable then it is passed to <TT>portray/1</TT>. If
this succeeds then it is assumed that <TT>Term</TT> has been output.
Otherwise <TT>write_term/3</TT> outputs the principal functor of
<TT>Term</TT> (<TT>Term</TT> itself if it is atomic) according to other
options and recursively calls <TT>portray/1</TT> on the components of
<TT>Term</TT> (if it is a compound term). With <TT>ignore_ops(false)</TT> a
list is first passed to <TT>portray/1</TT> and only if this call fails each
element of the list is passed to <TT>portray/1</TT> (thus every sub-list is
not passed). The default value is <TT>false</TT>.</LI><LI CLASS="li-itemize"><TT>max_depth(N)</TT>: controls the depth of output for
compound terms. <TT>N</TT> is an integer specifying the depth. The output of
a term whose depth is greater than <TT>N</TT> gives rise to the output of
<TT>...</TT> (3 dots). By default there is no depth limit.</LI><LI CLASS="li-itemize"><TT>priority(N)</TT>: specifies the starting priority
to output the term. This option controls if <TT>Term</TT> should be enclosed
in brackets. <TT>N</TT> is a positive integer &#X2264; 1200. By default
<TT>N</TT> = 1200.</LI></UL><P><B>Variable numbering</B>: when the <TT>numbervars(true)</TT> option is
passed to <TT>write_term/3</TT> any term of the form <TT>&#X2019;$VAR&#X2019;(N)</TT>
where <TT>N</TT> is an integer is output as a variable name consisting of a
capital letter possibly followed by an integer. The capital letter is the
<TT>(I+1)</TT><EM>th</EM> letter of the alphabet and the integer is
<TT>J</TT>, where <TT>I = N mod 26</TT> and <TT>J = N // 26</TT>. The
integer <TT>J</TT> is omitted if it is zero. For example:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><TT>&#X2019;$VAR&#X2019;(0)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>is written as <TT>A</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&#X2019;$VAR&#X2019;(1)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>is written as <TT>B</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>...</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&#X2019;$VAR&#X2019;(25)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>is written as <TT>Z</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&#X2019;$VAR&#X2019;(26)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>is written as <TT>A1</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>&#X2019;$VAR&#X2019;(27)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>is written as <TT>B1</TT></TD></TR>
</TABLE></DD></DL><P><B>Variable naming</B>: when the <TT>namevars(true)</TT> option is passed
to <TT>write_term/3</TT> any term of the form <TT>&#X2019;$VARNAME&#X2019;(Name)</TT>
where <TT>Name</TT> is an atom is output as a variable name consisting of
the characters <TT>Name</TT>. For example: <TT>&#X2019;$VARNAME&#X2019;(&#X2019;A&#X2019;)</TT> is
written as <TT>A</TT> (even in the presence of the <TT>quoted(true)</TT>
option).</P><P><TT>write(SorA, Term)</TT> is equivalent to
<TT>write_term(SorA, Term, [numbervars(true),<BR>
namevars(true)])</TT>.</P><P><TT>writeq(SorA, Term)</TT> is equivalent to
<TT>write_term(SorA, Term, [quoted(true),<BR>
numbervars(true), namevars(true)])</TT>.</P><P><TT>write_canonical(SorA, Term)</TT> is equivalent to
<TT>write_term(SorA, Term, [quoted(true),<BR>
ignore_ops(true), numbervars(false), namevars(false)])</TT>.</P><P><TT>display(SorA, Term)</TT> is equivalent to
<TT>write_term(SorA, Term, [ignore_ops(true),<BR>
 numbervars(false), namevars(false)])</TT>.</P><P><TT>print(SorA, Term)</TT> is equivalent to
<TT>write_term(SorA, Term, [numbervars(false),<BR>
portrayed(true)])</TT>.</P><P><TT>write_term/2</TT>, <TT>write/1</TT>, <TT>writeq/1</TT>,
<TT>write_canonical/1</TT>, <TT>display/1</TT> and <TT>print/1</TT> apply
to the current output stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Options</TT> is a partial list or a list with an element
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Options</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Options)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Options</TT> list is neither a
variable nor a valid write-option</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(write_option, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an input stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(output, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a binary stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(output, binary_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicates except <TT>display/1-2</TT> and <TT>print/1-2</TT> that
are GNU Prolog predicates. <TT>namevars</TT>, <TT>variable_names</TT> <TT>space_args</TT>,
<TT>portrayed</TT>, <TT>max_depth</TT> and <TT>priority</TT>
options are GNU Prolog extensions.</P><!--TOC subsubsection <TT>format/3</TT>,
<TT>format/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc165">8.14.7</A>&#XA0;&#XA0;<TT>format/3</TT>,
<TT>format/2</TT></H4><!--SEC END --><P>
<A NAME="format/3"></A>

</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
format(+stream_or_alias, +character_code_list_or_atom,
+list)<BR>
format(+character_code_list_or_atom, +list)</TT></DD></DL><P><B>Description</B></P><P><TT>format(SorA, Format, Arguments)</TT> writes the <TT>Format</TT> string
replacing each format control sequence <TT>F</TT> by the corresponding
element of <TT>Arguments</TT> (formatted according to <TT>F</TT>) to the
stream associated with the stream-term or alias <TT>SorA</TT>.</P><P><B>Format control sequences</B>: the general format of a control sequence
is <TT>&#X2019;~NC&#X2019;</TT>. The character <TT>C</TT> determines the type of
the control sequence. <TT>N</TT> is an optional numeric argument. An
alternative form of <TT>N</TT> is <TT>&#X2019;*&#X2019;</TT>. <TT>&#X2019;*&#X2019;</TT> implies
that the next argument <TT>Arg</TT> in <TT>Arguments</TT> should be
used as a numeric argument in the control sequence. The use of C
<TT>printf()</TT> formatting sequence (beginning by the character
<TT>%</TT>) is also allowed. The following control sequences are
available:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
Format sequence</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">type of the argument</DIV></TD><TD VALIGN=top ALIGN=left>Description</TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>~Na</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">atom</DIV></TD><TD VALIGN=top ALIGN=left>print the atom without quoting. <TT>N</TT> is minimal number of characters to print using spaces on the right if needed (default: the length of the atom)</TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>~Nc</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">character code</DIV></TD><TD VALIGN=top ALIGN=left>print the character associated with the
code. <TT>N</TT> is the number of times to print the character (default: 1)</TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT> ~Nf</TT>
<BR>
<TT>~Ne ~NE ~Ng ~NG</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">float expression</DIV></TD><TD VALIGN=top ALIGN=left>pass the argument <TT>Arg</TT> and
<TT>N</TT> to the C <TT>printf()</TT>
function as:
<BR>
if <TT>N</TT> is not specified
<TT>printf("%f",Arg)</TT> else
<TT>printf("%.Nf",Arg)</TT>.
<BR>
Similarly for <TT>~Ne</TT>, <TT>~NE</TT>, <TT>~Ng</TT> and <TT>~NG</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>~Nd</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">integer expression</DIV></TD><TD VALIGN=top ALIGN=left>print the argument. <TT>N</TT> is the
number of digits after the decimal point. If <TT>N</TT> is 0 no
decimal point is printed (default: 0)</TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>~ND</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">integer expression</DIV></TD><TD VALIGN=top ALIGN=left>identical to <TT>~Nd</TT> except
that <TT>&#X2019;,&#X2019;</TT> separates groups of three digits to the left of the
decimal point</TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>~Nr</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">integer expression</DIV></TD><TD VALIGN=top ALIGN=left>print the argument according to the
radix <TT>N</TT>. 2 &#X2264; <TT>N</TT> &#X2264; 36 (default: 8). The letters
<TT>a-z</TT> denote digits &gt; 9</TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>~NR</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">integer expression</DIV></TD><TD VALIGN=top ALIGN=left>identical to <TT>~Nr</TT> except
that the letters <TT>A-Z</TT> denote digits &gt; 9</TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>~Ns</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">character code list</DIV></TD><TD VALIGN=top ALIGN=left>print exactly <TT>N</TT> characters
(default: the length of the list)</TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>~NS</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">character list</DIV></TD><TD VALIGN=top ALIGN=left>print exactly <TT>N</TT> characters
(default: the length of the list)</TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>~i</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">term</DIV></TD><TD VALIGN=top ALIGN=left>ignore the current argument</TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>~k</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">term</DIV></TD><TD VALIGN=top ALIGN=left>pass the argument to
<TT>write_canonical/1</TT> (section&#XA0;<A HREF="#write-term/3">8.14.6</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>~p</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">term</DIV></TD><TD VALIGN=top ALIGN=left>pass the argument to <TT>print/1</TT>
(section&#XA0;<A HREF="#write-term/3">8.14.6</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>~q</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">term</DIV></TD><TD VALIGN=top ALIGN=left>pass the argument to <TT>writeq/1</TT>
(section&#XA0;<A HREF="#write-term/3">8.14.6</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>~w</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">term</DIV></TD><TD VALIGN=top ALIGN=left>pass the argument to <TT>write/1</TT>
(section&#XA0;<A HREF="#write-term/3">8.14.6</A>)</TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>~~</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">none</DIV></TD><TD VALIGN=top ALIGN=left>print the character <TT>&#X2019;~&#X2019;</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>~Nn</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">none</DIV></TD><TD VALIGN=top ALIGN=left>print <TT>N</TT> new-line characters (default: 1)</TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>~N</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">none</DIV></TD><TD VALIGN=top ALIGN=left>print a new-line character if not at the beginning
of a line</TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>~?</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">atom</DIV></TD><TD VALIGN=top ALIGN=left>use the argument as a nested format string</TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="center">
<TT>%F</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">atom, integer or float expression</DIV></TD><TD VALIGN=top ALIGN=left>interface to the C
function <TT>printf(3)</TT> for outputting atoms (C string), integers and
floating point numbers. <TT>*</TT> are also allowed.</TD></TR>
</TABLE><P><TT>format/2</TT> applies to the current output stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Format</TT> is a partial list or a list with an element
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Arguments</TT> is a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Format</TT> is neither a partial list nor a list or an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Format)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Arguments</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Arguments)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Format</TT> list is neither a
variable nor a character code</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(character_code, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of Format is not a valid format control
sequence</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(format_control_sequence, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
the <TT>Arguments</TT> list does not contain sufficient elements</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(non_empty_list, [])</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Arguments</TT> list is a variable
while a non-variable term was expected</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Arguments</TT> list is neither
variable nor an atom while an atom was expected</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Arguments</TT> cannot be evaluated
as an arithmetic expression while an integer or a floating point number was
expected</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left>an arithmetic error (section&#XA0;<A HREF="#Evaluation-of-an-arithmetic-expression">8.6.1</A>)</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Arguments</TT> list is neither
variable nor character code while a character code was expected</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(character_code, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an input stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(output, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a binary stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(output, binary_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>portray_clause/2</TT>,
<TT>portray_clause/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc166">8.14.8</A>&#XA0;&#XA0;<TT>portray_clause/2</TT>,
<TT>portray_clause/1</TT></H4><!--SEC END --><P>
<A NAME="portray-clause/2"></A>

</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
portray_clause(+stream_or_alias, +clause)<BR>
portray_clause(+clause)</TT></DD></DL><P><B>Description</B></P><P><TT>portray_clause(SorA, Clause)</TT> pretty prints
<TT>Clause</TT> to the stream associated with the stream-term or alias
<TT>SorA</TT>.
<TT>portray_clause/2</TT> uses the variable binding predicates
<TT>name_singleton_vars/1</TT> (section&#XA0;<A HREF="#name-singleton-vars/1">8.5.1</A>) and
<TT>numbervars/1</TT> (section&#XA0;<A HREF="#bind-variables/2">8.5.3</A>). This predicate is
used by <TT>listing/1</TT> (section&#XA0;<A HREF="#listing/1">8.23.3</A>).</P><P><TT>portray_clause/1</TT> applies to the current output stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Clause</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Clause</TT> is neither a variable nor a callable term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(callable, Clause)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is neither a variable nor a stream-term or alias</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is an input stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(output, stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SorA</TT> is associated with a binary stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(output, binary_stream, SorA)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>get_print_stream/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc167">8.14.9</A>&#XA0;&#XA0;<TT>get_print_stream/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
get_print_stream(?stream)</TT></DD></DL><P><B>Description</B></P><P><TT>get_print_stream(Stream)</TT> unifies <TT>Stream</TT> with the
stream-term associated with the output stream used by <TT>print/2</TT>
(section&#XA0;<A HREF="#write-term/3">8.14.6</A>). The purpose of this predicate is to allow a
user-defined <TT>portray/1</TT> predicate to identify the output stream in
use.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Stream</TT> is neither a variable nor a stream-term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream, Stream)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>op/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc168">8.14.10</A>&#XA0;&#XA0;<TT>op/3</TT></H4><!--SEC END --><P>
<A NAME="op/3:(Term-input/output)"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
op(+integer, +operator_specifier, +atom_or_atom_list)</TT></DD></DL><P><B>Description</B></P><P><TT>op(Priority, OpSpecifier, Operator)</TT> alters the operator table.
<TT>Operator</TT> is declared as an operator with properties defined by
specifier <TT>OpSpecifier</TT> and <TT>Priority</TT>. <TT>Priority</TT> must
be an integer &#X2265; 0 and &#X2264; 1200. If <TT>Priority</TT> is 0 then the
operator properties of <TT>Operator</TT> (if any) are canceled.
<TT>Operator</TT> may also be a list of atoms in which case all of them are
declared to be operators. In general, operators can be removed from
the operator table and their priority or specifier can be changed. However,
it is an error to attempt to change the <TT>&#X2019;,&#X2019;</TT> operator from its
initial status. An atom can have multiple operator definitions (e.g.
prefix and infix like <TT>+</TT>) however an atom cannot have both an
infix and a postfix operator definitions.</P><P><B>Operator specifiers</B>: the following specifiers are available:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP>
Specifier</TD><TD ALIGN=center NOWRAP>Type</TD><TD ALIGN=center NOWRAP>Associativity</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>fx</TT></TD><TD ALIGN=center NOWRAP>prefix</TD><TD ALIGN=center NOWRAP>no</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>fy</TT></TD><TD ALIGN=center NOWRAP>prefix</TD><TD ALIGN=center NOWRAP>yes</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>xf</TT></TD><TD ALIGN=center NOWRAP>postfix</TD><TD ALIGN=center NOWRAP>no</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>yf</TT></TD><TD ALIGN=center NOWRAP>postfix</TD><TD ALIGN=center NOWRAP>yes</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>xfx</TT></TD><TD ALIGN=center NOWRAP>infix</TD><TD ALIGN=center NOWRAP>no</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>yfx</TT></TD><TD ALIGN=center NOWRAP>infix</TD><TD ALIGN=center NOWRAP>left</TD></TR>
<TR><TD ALIGN=center NOWRAP>
<TT>xfy</TT></TD><TD ALIGN=center NOWRAP>infix</TD><TD ALIGN=center NOWRAP>right</TD></TR>
</TABLE><P><B>Prolog predefined operators</B>:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=right NOWRAP>
Priority</TD><TD VALIGN=top ALIGN=center NOWRAP>Specifier</TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">Operators</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>1200</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>xfx</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>:- &#XA0;--&gt;</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>1200</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>fx</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>:-</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>1105</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>xfy</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>|</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>1100</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>xfy</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>;</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>1050</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>xfy</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>-&gt; *-&gt;</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>1000</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>xfy</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>,</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>900</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>fy</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>\+</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>700</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>xfx</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>= &#XA0;\= &#XA0;=.. &#XA0;== &#XA0;\== &#XA0;@&lt;
&#XA0;@=&lt; &#XA0;@&gt; &#XA0;@&gt;= &#XA0;is &#XA0;=:= &#XA0;=\= &#XA0;&lt; &#XA0;=&lt; &#XA0;&gt; &#XA0;&gt;=</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>600</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>xfy</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>:</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>500</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>yfx</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>+ &#XA0;- &#XA0;/\ &#XA0;\/</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>400</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>yfx</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>* &#XA0;/ &#XA0;// &#XA0;rem &#XA0;mod &#XA0;div &#XA0;&lt;&lt;
&#XA0;&gt;&gt;</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>200</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>xfx</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>** &#XA0;^</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>200</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>fy</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>+ &#XA0;- &#XA0;\</TT></DIV></TD></TR>
</TABLE><P><B>FD predefined operators</B>:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=right NOWRAP>
Priority</TD><TD VALIGN=top ALIGN=center NOWRAP>Specifier</TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">Operators</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>750</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>xfy</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>#&lt;=&gt; &#XA0;#\&lt;=&gt;</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>740</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>xfy</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>#==&gt; &#XA0;#\==&gt;</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>730</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>xfy</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>## &#XA0;#\/ &#XA0;#\\/</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>720</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>yfx</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>#/\ &#XA0;#\/\</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>710</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>fy</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>#\</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>700</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>xfx</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>#= &#XA0;#\= &#XA0;#&lt; &#XA0;#=&lt;
&#XA0;#&gt; &#XA0;#&gt;= &#XA0;#=# &#XA0;#\=# &#XA0;#&lt;# &#XA0;#=&lt;# &#XA0;#&gt;#
&#XA0;#&gt;=#</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>500</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>yfx</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>+ &#XA0;-</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>400</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>yfx</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>* &#XA0;/ &#XA0;// &#XA0;rem</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>200</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>xfy</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>**</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=right NOWRAP>
<TT>200</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>fy</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>+ &#XA0;-</TT></DIV></TD></TR>
</TABLE><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Priority</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>OpSpecifier</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Operator</TT> is a partial list or a list with an element
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Priority</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Priority)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>OpSpecifier</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, OpSpecifier)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Operator</TT> is neither a partial list nor a list nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Operator)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Operator</TT> list is neither a
variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Priority</TT> is an integer not &#X2265; 0 and &#X2264; 1200</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(operator_priority, Priority)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>OpSpecifier</TT> is not a valid operator specifier</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(operator_specifier, OpSpecifier)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Operator</TT> (or an element of the
<TT>Operator</TT> list) is <TT>&#X2019;,&#X2019;</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(modify, operator, &#X2019;,&#X2019;)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>OpSpecifier</TT> is a specifier such that <TT>Operator</TT>
would have a postfix and an infix definition. </TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(create, operator, Operator)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Operator</TT> (or an element of the <TT>Operator</TT> list) is
<TT>|</TT> and it would have a prefix or a postfix definition or its
<TT>Priority</TT> would be &#X2264; 1100.</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(create, operator, &#X2019;|&#X2019;)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Operator</TT> (or an element of the <TT>Operator</TT> list) is
<TT>[]</TT> or <TT>{}</TT>.</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(create, operator, Operator)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><P>The ISO reference implies that if a program calls <TT>current_op/3</TT>,
then modifies an operator definition by calling <TT>op/3</TT> and backtracks
into the call to <TT>current_op/3</TT>, then the changes are guaranteed not
to affect that <TT>current_op/3</TT> goal. This is not guaranteed by
GNU Prolog.</P><!--TOC subsubsection <TT>current_op/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc169">8.14.11</A>&#XA0;&#XA0;<TT>current_op/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
current_op(?integer, ?operator_specifier, ?atom)</TT></DD></DL><P><B>Description</B></P><P><TT>current_op(Priority, OpSpecifier, Operator)</TT> succeeds if
<TT>Operator</TT> is an operator with properties defined by specifier
<TT>OpSpecifier</TT> and <TT>Priority</TT>. This predicate is re-executable
on backtracking.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Priority</TT> is neither a variable nor an operator priority</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(operator_priority, Priority)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>OpSpecifier</TT> is neither a variable nor an operator
specifier</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(operator_specifier, OpSpecifier)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Operator</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Operator)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>char_conversion/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc170">8.14.12</A>&#XA0;&#XA0;<TT>char_conversion/2</TT></H4><!--SEC END --><P>
<A NAME="char-conversion/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
char_conversion(+character, +character)</TT></DD></DL><P><B>Description</B></P><P><TT>char_conversion(InChar, OutChar)</TT> alters the character-conversion
mapping. This mapping is used by the following read predicates:
<TT>read_term/3</TT> (section&#XA0;<A HREF="#read-term/3">8.14.1</A>), <TT>read_atom/2</TT>,
<TT>read_integer/2</TT>, <TT>read_number/2</TT> (section&#XA0;<A HREF="#read-atom/2">8.14.2</A>) and
<TT>read_token/2</TT> (section&#XA0;<A HREF="#read-token/2">8.14.3</A>) to replace any occurrence of a
character <TT>InChar</TT> by <TT>OutChar</TT>. However the conversion
mechanism should have been previously activated by switching on the
<TT>char_conversion</TT> Prolog flag (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>). When
<TT>InChar</TT> and <TT>OutChar</TT> are the same, the effect is to remove
any conversion of a character <TT>InChar</TT>.</P><P>Note that the single character read predicates (e.g. <TT>get_char/2</TT>)
never do character conversion. If such behavior is required, it must be
explicitly done using <TT>current_char_conversion/2</TT>
(section&#XA0;<A HREF="#current-char-conversion/2">8.14.13</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>InChar</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>OutChar</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>InChar</TT> is neither a variable nor a character</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(character, InChar)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>OutChar</TT> is neither a variable nor a character</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(character, OutChar)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate. The <TT>type_error(character,&#X2026;)</TT> is a GNU Prolog
behavior, the ISO reference instead defines a
<TT>representation_error(character)</TT> in this case. This seems to be an
error of the ISO reference since, for many other built-in predicates
accepting a character (e.g. <TT>char_code/2</TT>, <TT>put_char/2</TT>), a
<TT>type_error</TT> is raised.</P><P>The ISO reference implies that if a program calls
<TT>current_char_conversion/2</TT>, then modifies the character mapping by
calling <TT>char_conversion/2</TT>, and backtracks into the call to
<TT>current_char_conversion/2</TT> then the changes are guaranteed not to
affect that <TT>current_char_conversion/2</TT> goal. This is not guaranteed
by GNU Prolog.</P><!--TOC subsubsection <TT>current_char_conversion/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc171">8.14.13</A>&#XA0;&#XA0;<TT>current_char_conversion/2</TT></H4><!--SEC END --><P>
<A NAME="current-char-conversion/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
current_char_conversion(?character, ?character)</TT></DD></DL><P><B>Description</B></P><P><TT>current_char_conversion(InChar, OutChar)</TT> succeeds if the
conversion of <TT>InChar</TT> is <TT>OutChar</TT> according to the
character-conversion mapping. In that case, <TT>InChar</TT> and
<TT>OutChar</TT> are different. This predicate is re-executable on
backtracking.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>InChar</TT> is neither a variable nor a character</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(character, InChar)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>OutChar</TT> is neither a variable nor a character</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(character, OutChar)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate. Same remark as for char_conversion/2
(section&#XA0;<A HREF="#char-conversion/2">8.14.12</A>).</P><!--TOC subsection Input/output from/to constant terms-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc172">8.15</A>&#XA0;&#XA0;Input/output from/to constant terms</H3><!--SEC END --><P>
<A NAME="Input/output-from/to-constant-terms"></A>
These built-in predicates enable a Prolog term to be input from or output to
a Prolog constant term (atom, character list or character code list). All
these predicates can be defined using constant term streams
(section&#XA0;<A HREF="#Constant-term-streams">8.11</A>). They are however simpler to use.</P><!--TOC subsubsection <TT>read_term_from_atom/3</TT>,
<TT>read_from_atom/2</TT>,
<TT>read_token_from_atom/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc173">8.15.1</A>&#XA0;&#XA0;<TT>read_term_from_atom/3</TT>,
<TT>read_from_atom/2</TT>,
<TT>read_token_from_atom/2</TT></H4><!--SEC END --><P>
<A NAME="read-term-from-atom/3"></A>


</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
read_term_from_atom(+atom ?term, +read_option_list)<BR>
read_from_atom(+atom, ?term)<BR>
read_token_from_atom(+atom, ?nonvar)</TT></DD></DL><P><B>Description</B></P><P>Like <TT>read_term/3</TT>, <TT>read/2</TT> (section&#XA0;<A HREF="#read-term/3">8.14.1</A>) and
<TT>read_token/2</TT> (section&#XA0;<A HREF="#read-token/2">8.14.3</A>) except that characters are not
read from a text-stream but from <TT>Atom</TT>; the atom given as first
argument.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Atom)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
see associated predicate errors</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left>(section&#XA0;<A HREF="#read-term/3">8.14.1</A>) and (section&#XA0;<A HREF="#read-token/2">8.14.3</A>)</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>read_term_from_chars/3</TT>,
<TT>read_from_chars/2</TT>,
<TT>read_token_from_chars/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc174">8.15.2</A>&#XA0;&#XA0;<TT>read_term_from_chars/3</TT>,
<TT>read_from_chars/2</TT>,
<TT>read_token_from_chars/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
read_term_from_chars(+character_list ?term,
+read_option_list)<BR>
read_from_chars(+character_list, ?term)<BR>
read_token_from_chars(+character_list, ?nonvar)</TT></DD></DL><P><B>Description</B></P><P>Like <TT>read_term/3</TT>, <TT>read/2</TT> (section&#XA0;<A HREF="#read-term/3">8.14.1</A>) and
<TT>read_token/2</TT> (section&#XA0;<A HREF="#read-token/2">8.14.3</A>) except that characters are not
read from a text-stream but from <TT>Chars</TT>; the character list given as
first argument.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Chars</TT> is a partial list or a list with an element
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Chars</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Chars)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Chars</TT> list is neither a
variable nor a character</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(character, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
see associated predicate errors</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left>(section&#XA0;<A HREF="#read-term/3">8.14.1</A>) and (section&#XA0;<A HREF="#read-token/2">8.14.3</A>)</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>read_term_from_codes/3</TT>,
<TT>read_from_codes/2</TT>,
<TT>read_token_from_codes/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc175">8.15.3</A>&#XA0;&#XA0;<TT>read_term_from_codes/3</TT>,
<TT>read_from_codes/2</TT>,
<TT>read_token_from_codes/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
read_term_from_codes(+character_code_list ?term,
+read_option_list)<BR>
read_from_codes(+character_code_list, ?term)<BR>
read_token_from_codes(+character_code_list, ?nonvar)</TT></DD></DL><P><B>Description</B></P><P>Like <TT>read_term/3</TT>, <TT>read/2</TT> (section&#XA0;<A HREF="#read-term/3">8.14.1</A>) and
<TT>read_token/2</TT> (section&#XA0;<A HREF="#read-token/2">8.14.3</A>) except that characters are not
read from a text-stream but from <TT>Codes</TT>; the character code list
given as first argument.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Codes</TT> is a partial list or a list with an element
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Codes</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Codes)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Codes</TT> list is neither a
variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Codes</TT> list is an integer but
not a character code</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(character_code, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
see associated predicate errors</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left>(section&#XA0;<A HREF="#read-term/3">8.14.1</A>) and (section&#XA0;<A HREF="#read-token/2">8.14.3</A>)</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>write_term_to_atom/3</TT>,
<TT>write_to_atom/2</TT>,
<TT>writeq_to_atom/2</TT>,<BR>
 <TT>write_canonical_to_atom/2</TT>,
<TT>display_to_atom/2</TT>,
<TT>print_to_atom/2</TT>,<BR>
 <TT>format_to_atom/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc176">8.15.4</A>&#XA0;&#XA0;<TT>write_term_to_atom/3</TT>,
<TT>write_to_atom/2</TT>,
<TT>writeq_to_atom/2</TT>,<BR>
 <TT>write_canonical_to_atom/2</TT>,
<TT>display_to_atom/2</TT>,
<TT>print_to_atom/2</TT>,<BR>
 <TT>format_to_atom/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
write_term_to_atom(?atom, ?term, +write_option_list)<BR>
write_to_atom(?atom, ?term)<BR>
writeq_to_atom(?atom, ?term)<BR>
write_canonical_to_atom(?atom, ?term)<BR>
display_to_atom(?atom, ?term)<BR>
print_to_atom(?atom, ?term)<BR>
format_to_atom(?atom, +character_code_list_or_atom, +list)</TT></DD></DL><P><B>Description</B></P><P>Similar to <TT>write_term/3</TT>, <TT>write/2</TT>, <TT>writeq/2</TT>,
<TT>write_canonical/2</TT>, <TT>display/2</TT>, <TT>print/2</TT>
(section&#XA0;<A HREF="#write-term/3">8.14.6</A>) and <TT>format/3</TT> (section&#XA0;<A HREF="#format/3">8.14.7</A>) except that
characters are not written onto a text-stream but are collected as an atom
which is then unified with the first argument <TT>Atom</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Atom)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
see associated predicate errors</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left>(section&#XA0;<A HREF="#write-term/3">8.14.6</A>) and (section&#XA0;<A HREF="#format/3">8.14.7</A>)</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>write_term_to_chars/3</TT>,
<TT>write_to_chars/2</TT>,
<TT>writeq_to_chars/2</TT>,<BR>
 <TT>write_canonical_to_chars/2</TT>,
<TT>display_to_chars/2</TT>,
<TT>print_to_chars/2</TT>,<BR>
 <TT>format_to_chars/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc177">8.15.5</A>&#XA0;&#XA0;<TT>write_term_to_chars/3</TT>,
<TT>write_to_chars/2</TT>,
<TT>writeq_to_chars/2</TT>,<BR>
 <TT>write_canonical_to_chars/2</TT>,
<TT>display_to_chars/2</TT>,
<TT>print_to_chars/2</TT>,<BR>
 <TT>format_to_chars/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
write_term_to_chars(?character_list, ?term, +write_option_list)<BR>
write_to_chars(?character_list, ?term)<BR>
writeq_to_chars(?character_list, ?term)<BR>
write_canonical_to_chars(?character_list, ?term)<BR>
display_to_chars(?character_list, ?term)<BR>
print_to_chars(?character_list, ?term)<BR>
format_to_chars(?character_list, +character_code_list_or_atom, +list)</TT></DD></DL><P><B>Description</B></P><P>Similar to <TT>write_term/3</TT>, <TT>write/2</TT>, <TT>writeq/2</TT>,
<TT>write_canonical/2</TT>, <TT>display/2</TT>, <TT>print/2</TT>
(section&#XA0;<A HREF="#write-term/3">8.14.6</A>) and <TT>format/3</TT> (section&#XA0;<A HREF="#format/3">8.14.7</A>) except that
characters are not written onto a text-stream but are collected as a
character list which is then unified with the first argument <TT>Chars</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Chars</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Chars)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
An element <TT>E</TT> of the list <TT>Chars</TT> is neither a
variable nor a one-char atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(character, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
see associated predicate errors</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left>(section&#XA0;<A HREF="#write-term/3">8.14.6</A>) and (section&#XA0;<A HREF="#format/3">8.14.7</A>)</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>write_term_to_codes/3</TT>,
<TT>write_to_codes/2</TT>,
<TT>writeq_to_codes/2</TT>,<BR>
 <TT>write_canonical_to_codes/2</TT>,
<TT>display_to_codes/2</TT>,
<TT>print_to_codes/2</TT>,<BR>
 <TT>format_to_codes/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc178">8.15.6</A>&#XA0;&#XA0;<TT>write_term_to_codes/3</TT>,
<TT>write_to_codes/2</TT>,
<TT>writeq_to_codes/2</TT>,<BR>
 <TT>write_canonical_to_codes/2</TT>,
<TT>display_to_codes/2</TT>,
<TT>print_to_codes/2</TT>,<BR>
 <TT>format_to_codes/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
write_term_to_codes(?character_code_list, ?term, +write_option_list)<BR>
write_to_codes(?character_code_list, ?term)<BR>
writeq_to_codes(?character_code_list, ?term)<BR>
write_canonical_to_codes(?character_code_list, ?term)<BR>
display_to_codes(?character_code_list, ?term)<BR>
print_to_codes(?character_code_list, ?term)<BR>
format_to_codes(?character_code_list, +character_code_list_or_atom,
+list)</TT></DD></DL><P><B>Description</B></P><P>Similar to <TT>write_term/3</TT>, <TT>write/2</TT>, <TT>writeq/2</TT>,
<TT>write_canonical/2</TT>, <TT>display/2</TT>, <TT>print/2</TT>
(section&#XA0;<A HREF="#write-term/3">8.14.6</A>) and <TT>format/3</TT> (section&#XA0;<A HREF="#format/3">8.14.7</A>) except that
characters are not written onto a text-stream but are collected as a
character code list which is then unified with the first argument
<TT>Codes</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Codes</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Codes)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
An element <TT>E</TT> of the list <TT>Codes</TT> is neither a
variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
An element <TT>E</TT> of the list <TT>Codes</TT> is an integer but
not a character code</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(character_code)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
see associated predicate errors</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left>(section&#XA0;<A HREF="#write-term/3">8.14.6</A>) and (section&#XA0;<A HREF="#format/3">8.14.7</A>)</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsection DEC-10 compatibility input/output-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc179">8.16</A>&#XA0;&#XA0;DEC-10 compatibility input/output</H3><!--SEC END --><!--TOC subsubsection Introduction-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc180">8.16.1</A>&#XA0;&#XA0;Introduction</H4><!--SEC END --><P>
The DEC-10 Prolog I/O predicates manipulate streams implicitly since they
only refer to current input/output streams (section&#XA0;<A HREF="#Introduction:(Streams)">8.10.1</A>).
The current input and output streams are initially set to
<TT>user_input</TT> and <TT>user_output</TT> respectively. The predicate
<TT>see/1</TT>
(resp. <TT>tell/1</TT>, <TT>append/1</TT>) can be used for setting the
current input (resp. output) stream to newly opened streams for
particular files. The predicate <TT>seen/0</TT>
(resp. <TT>told/0</TT>) close the current input (resp. output) stream,
and resets it to the standard input (resp. output). The predicate
<TT>seeing/1</TT> (resp. <TT>telling/1</TT>) is used for retrieving
the file name associated with the current input (resp. output)
stream. The file name <TT>user</TT> stands for the standard input or
output, depending on context (<TT>user_input</TT> and
<TT>user_output</TT> can also be used). The DEC-10 Prolog I/O predicates
are only provided for compatibility, they are now obsolete and
their use is discouraged. The predicates for explicit stream manipulation
should be used instead (section&#XA0;<A HREF="#Streams">8.10</A>).</P><!--TOC subsubsection <TT>see/1</TT>,
<TT>tell/1</TT>,
<TT>append/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc181">8.16.2</A>&#XA0;&#XA0;<TT>see/1</TT>,
<TT>tell/1</TT>,
<TT>append/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
see(+source_sink)<BR>
see(+stream)<BR>
tell(+source_sink)<BR>
tell(+stream)<BR>
append(+source_sink)<BR>
append(+stream)</TT></DD></DL><P><B>Description</B></P><P><TT>see(FileName)</TT> sets the current input stream to <TT>FileName</TT>.
If there is a stream opened by <TT>see/1</TT> associated with the same
<TT>FileName</TT> already, then it becomes the current input stream.
Otherwise, <TT>FileName</TT> is opened for reading and becomes the current
input stream.</P><P><TT>tell(FileName)</TT> sets the current output stream to <TT>FileName</TT>.
If there is a stream opened by <TT>tell/1</TT> associated with the same
<TT>FileName</TT> already, then it becomes the current output stream.
Otherwise, <TT>FileName</TT> is opened for writing and becomes the current
output stream.</P><P><TT>append(FileName)</TT> like <TT>tell/1</TT> but
<TT>FileName</TT> is opened for writing + append.</P><P>A stream-term (obtained with any other built-in predicate) can also be
provided as <TT>FileName</TT> to these predicates.</P><P><B>Errors</B></P><P>See errors associated with <TT>open/4</TT> (section&#XA0;<A HREF="#open/4">8.10.6</A>).</P><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>seeing/1</TT>,
<TT>telling/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc182">8.16.3</A>&#XA0;&#XA0;<TT>seeing/1</TT>,
<TT>telling/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
seeing(?source_sink)<BR>
telling(?source_sink)</TT></DD></DL><P><B>Description</B></P><P><TT>seeing(FileName)</TT> succeeds if <TT>FileName</TT> unifies
with the name of the current input file, if it was opened by
<TT>see/1</TT>; else with the current input stream-term, if this is not
<TT>user_input</TT>, otherwise with
<TT>user</TT>.</P><P><TT>telling(FileName)</TT> succeeds if <TT>FileName</TT> unifies with the
name of the current output file, if it was opened by <TT>tell/1</TT> or
<TT>append/1</TT>; else with the current output stream-term, if this is not
<TT>user_output</TT>, otherwise with <TT>user</TT>.</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>seen/0</TT>,
<TT>told/0</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc183">8.16.4</A>&#XA0;&#XA0;<TT>seen/0</TT>,
<TT>told/0</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
seen<BR>
told</TT></DD></DL><P><B>Description</B></P><P><TT>seen</TT> closes the current input, and resets it to
<TT>user_input</TT>.</P><P><TT>told</TT> closes the current output, and resets it to
<TT>user_output</TT>.</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>get0/1</TT>,
<TT>get/1</TT>,
<TT>skip/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc184">8.16.5</A>&#XA0;&#XA0;<TT>get0/1</TT>,
<TT>get/1</TT>,
<TT>skip/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
get0(?in_character_code)<BR>
get(?in_character_code)<BR>
skip(+character_code)</TT></DD></DL><P><B>Description</B></P><P><TT>get0(Code)</TT> succeeds if <TT>Code</TT> unifies with the next
character code read from the current input stream. Thus it is equivalent to
<TT>get_code(Code)</TT> (section&#XA0;<A HREF="#get-char/2">8.12.1</A>).</P><P><TT>get(Code)</TT> succeeds if <TT>Code</TT> unifies with the next character
code read from the current input stream that is not a layout character.</P><P><TT>skip(Code)</TT> skips just past the next character code <TT>Code</TT>
from the current input stream.</P><P><B>Errors</B></P><P>See errors for <TT>get_code/2</TT> (section&#XA0;<A HREF="#get-char/2">8.12.1</A>).</P><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>put/1</TT>,
<TT>tab/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc185">8.16.6</A>&#XA0;&#XA0;<TT>put/1</TT>,
<TT>tab/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
put(+character_code)<BR>
tab(+evaluable)</TT></DD></DL><P><B>Description</B></P><P><TT>put(Code)</TT> writes the character whose code is <TT>Code</TT> onto the
current output stream. It is equivalent to <TT>put_code(Code)</TT>
(section&#XA0;<A HREF="#put-char/2">8.12.5</A>).</P><P><TT>tab(N)</TT> writes <TT>N</TT> spaces onto the current output
stream. <TT>N</TT> may be an arithmetic expression.</P><P><B>Errors</B></P><P>See errors for <TT>put_code/2</TT> (section&#XA0;<A HREF="#put-char/2">8.12.5</A>) and for arithmetic
expressions (section&#XA0;<A HREF="#Evaluation-of-an-arithmetic-expression">8.6.1</A>).</P><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsection Term expansion-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc186">8.17</A>&#XA0;&#XA0;Term expansion</H3><!--SEC END --><P>
<A NAME="Term-expansion"></A></P><!--TOC subsubsection Definite clause grammars-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc187">8.17.1</A>&#XA0;&#XA0;Definite clause grammars</H4><!--SEC END --><P>
<A NAME="DCG"></A>
</P><P>Definite clause grammars are a useful notation to express grammar rules.
However the ISO reference does not include them, so they should be considered
as a system dependent feature. Definite clause grammars are an extension of
context-free grammars. A grammar rule is of the form:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">head<TT> --&gt; </TT>body<TT>.</TT></DD></DL><P><TT>--&gt;</TT> is a predefined infix operator (section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</P><P>Here are some features of definite clause grammars:</P><UL CLASS="itemize"><LI CLASS="li-itemize">a non-terminal symbol may be any callable term.</LI><LI CLASS="li-itemize">a terminal symbol may be any Prolog term and is written as a list. The
empty list represents an empty sequence of terminals.</LI><LI CLASS="li-itemize">a sequence is expressed using the Prolog conjunction operator
<TT>(</TT>(&#X2019;,&#X2019;)/2).</LI><LI CLASS="li-itemize">the head of a grammar rule consists of a non-terminal optionally
followed by a sequence of terminals (i.e. a Prolog list).</LI><LI CLASS="li-itemize">the body of a grammar rule consists of a sequence of non-terminals,
terminals, predicate call, disjunction (using <TT>;/2</TT>), if-then (using
<TT>(-&gt;)/2</TT>) or cut (using <TT>!</TT>).</LI><LI CLASS="li-itemize">a predicate call must be enclosed in curly brackets (using
<TT>{}/1</TT>). This makes it possible to express an extra
condition.</LI></UL><P>A grammar rule is nothing but a &#X201C;syntactic sugar&#X201D; for a Prolog clause. Each
grammar rule accepts as input a list of terminals (tokens), parses a prefix
of this list and gives as output the rest of this list (possibly enlarged).
This rest is generally parsed later. So, each a grammar rule is translated
into a Prolog clause that explicitly the manages the list. Two arguments
are then added: the input list (<TT>Start</TT>) and the output list
(<TT>End</TT>). For instance:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>p --&gt; q.</TT></DD></DL><P>is translated into:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>p(Start, End) :- q(Start, End).</TT></DD></DL><P>Extra arguments can be provided and the body of the rule can contain several
non-terminals. Example:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">p(X, Y) --&gt;
        q(X),
        r(X, Y),
        s(Y).
</PRE></DD></DL><P>is translated into:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">p(X, Y, Start, End) :-
        q(X, Start, A),
        r(X, Y, A, B),
        s(Y, B, End).
</PRE></DD></DL><P>Terminals are translated using unification:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>assign(X,Y) --&gt; left(X), [:=], right(Y), [;].</TT></DD></DL><P>is translated into:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">assign(X,Y,Start,End) :-
        left(X, Start, A),
        A=[:=|B],
        right(Y, B, C),
        C=[;|End].
</PRE></DD></DL><P>Terminals appearing on the left-hand side of a rule are connected to the
output argument of the head.</P><P>It is possible to include a call to a prolog predicate enclosing it in curly
brackets (to distinguish them from non-terminals):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>assign(X,Y) --&gt; left(X), [:=], right(Y0), {Y is Y0 },
[;].</TT></DD></DL><P>is translated into:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">assign(X,Y,Start,End) :-
        left(X, Start, A),
        A=[:=|B],
        right(Y0, B, C),
        Y is Y0,
        C=[;|End].
</PRE></DD></DL><P>Cut, disjunction and if-then(-else) are translated literally (and do not need
to be enclosed in curly brackets).</P><!--TOC subsubsection <TT>expand_term/2</TT>,
<TT>term_expansion/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc188">8.17.2</A>&#XA0;&#XA0;<TT>expand_term/2</TT>,
<TT>term_expansion/2</TT></H4><!--SEC END --><P>
<A NAME="expand-term/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
expand_term(?term, ?term)<BR>
term_expansion(?term, ?term)</TT></DD></DL><P><B>Description</B></P><P><TT>expand_term(Term1, Term2)</TT> succeeds if
<TT>Term2</TT> is a transformation of <TT>Term1</TT>. The transformation
steps are as follows:</P><UL CLASS="itemize"><LI CLASS="li-itemize">if <TT>Term1</TT> is a variable, it is unified with <TT>Term2</TT></LI><LI CLASS="li-itemize">if <TT>term_expansion(Term1, Term2)</TT> succeeds <TT>Term2</TT> is
assumed to be the transformation of <TT>Term1</TT>.</LI><LI CLASS="li-itemize">if <TT>Term1</TT> is a DCG then <TT>Term2</TT> is its translation
(section&#XA0;<A HREF="#DCG">8.17.1</A>).</LI><LI CLASS="li-itemize">otherwise <TT>Term2</TT> is unified with <TT>Term1</TT>.</LI></UL><P><TT>term_expansion(Term1, Term2)</TT> is a hook predicate allowing the user
to define a specific transformation.</P><P>The GNU Prolog compiler (section&#XA0;<A HREF="#The-GNU-Prolog-compiler">4.4</A>) automatically calls
<TT>expand_term/2</TT> on each <TT>Term1</TT> read in. However, in the
current release, only DCG transformation are done by the compiler (i.e.
<TT>term_expansion/2</TT> cannot be used). To use
<TT>term_expansion/2</TT>, it is necessary to call <TT>expand_term/2</TT>
explicitly.</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>phrase/3</TT>,
<TT>phrase/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc189">8.17.3</A>&#XA0;&#XA0;<TT>phrase/3</TT>,
<TT>phrase/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
phrase(?term, ?list, ?list)<BR>
phrase(?term, ?list)</TT></DD></DL><P><B>Description</B></P><P><TT>phrase(Phrase, List, Remainder)</TT> succeeds if the list
<TT>List</TT> is in the language defined by the grammar rule body
<TT>Phrase</TT>. <TT>Remainder</TT> is what remains of the list after a
phrase has been found.</P><P><TT>phrase(Phrase, List)</TT> is equivalent to
<TT>phrase(Phrase, List, [])</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Phrase</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Phrase</TT> is neither a variable nor a callable term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(callable, Phrase)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is neither a list nor a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, List)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Remainder</TT> is neither a list nor a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Remainder)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsection Logic, control and exceptions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc190">8.18</A>&#XA0;&#XA0;Logic, control and exceptions</H3><!--SEC END --><!--TOC subsubsection <TT>abort/0</TT>,
<TT>stop/0</TT>,
<TT>top_level/0</TT>,
<TT>break/0</TT>,
<TT>halt/1</TT>,
<TT>halt/0</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc191">8.18.1</A>&#XA0;&#XA0;<TT>abort/0</TT>,
<TT>stop/0</TT>,
<TT>top_level/0</TT>,
<TT>break/0</TT>,
<TT>halt/1</TT>,
<TT>halt/0</TT></H4><!--SEC END --><P>
<A NAME="abort/0"></A>





</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
abort<BR>
stop<BR>
top_level<BR>
break<BR>
halt(+integer)<BR>
halt</TT></DD></DL><P><B>Description</B></P><P><TT>abort</TT> aborts the current execution. If this execution was initiated
under a top-level the control is given back to the top-level and the
message <TT>{execution aborted}</TT> is displayed. Otherwise,
e.g. execution started by a <TT>initialization/1</TT> directive
(section&#XA0;<A HREF="#initialization/1">7.1.14</A>), <TT>abort/0</TT> is equivalent to
<TT>halt(1)</TT> (see below).</P><P><TT>stop</TT> stops the current execution. If this execution was initiated
under a top-level the control is given back to the
top-level. Otherwise, <TT>stop/0</TT> is equivalent to <TT>halt(0)</TT>
(see below).</P><P><TT>top_level</TT> starts a new recursive top-level (including the
banner display). To end this new top-level simply type the end-of-file
key sequence (<TT>Ctl-D</TT>) or its term representation:
<TT>end_of_file.</TT></P><P><TT>break</TT> invokes a recursive top-level (no banner is displayed). To
end this new level simply type the end-of-file key sequence (<TT>Ctl-D</TT>)
or its term representation: <TT>end_of_file.</TT></P><P><TT>halt(Status)</TT> causes the GNU Prolog process to immediately exit back to
the shell with the return code <TT>Status</TT>.</P><P><TT>halt</TT> is equivalent to <TT>halt(0)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Status</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Status</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Status)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P><TT>halt/1</TT> and <TT>halt/0</TT> are ISO predicates. <TT>abort/0</TT>,
<TT>stop/0</TT>, <TT>top_level/0</TT> and <TT>break/0</TT> are GNU Prolog
predicates.</P><!--TOC subsubsection <TT>false/0</TT>, <TT>once/1</TT>, <TT>(</TT><TT>\</TT><TT>+)/1</TT> - not provable,
<TT>call/2-11</TT>,
	 <TT>call_with_args/1-11</TT>, <TT>call_det/2</TT>, <TT>forall/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc192">8.18.2</A>&#XA0;&#XA0;<TT>false/0</TT>, <TT>once/1</TT>, <TT>(\+)/1</TT> - not provable,
<TT>call/2-11</TT>,
	 <TT>call_with_args/1-11</TT>, <TT>call_det/2</TT>, <TT>forall/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
false<BR>
once(+callable_term)<BR>
\+(+callable_term)<BR>
call(+callable_term, +term,&#X2026;, +term)<BR>
call_with_args(+atom, +term,&#X2026;, +term)<BR>
call_det(+callable_term, ?boolean)<BR>
forall(+callable_term, +callable_term)</TT></DD></DL><P><B>Description</B></P><P><TT>false</TT> always fails and enforces backtracking. It is equivalent to the
<TT>fail/0</TT> control construct (section&#XA0;<A HREF="#true/0">7.2.1</A>).</P><P><TT>once(Goal)</TT> succeeds if <TT>call(Goal)</TT> succeeds. However
<TT>once/1</TT> is not re-executable on backtracking since all alternatives
of <TT>Goal</TT> are cut. <TT>once(Goal)</TT> is equivalent to
<TT>call(Goal), !</TT>.</P><P><TT>\+ Goal</TT> succeeds if <TT>call(Goal)</TT> fails and fails
otherwise. This built-in predicate gives negation by failure.</P><P><TT>call(Closure, Arg1,&#X2026;, ArgN)</TT> calls the goal <TT>call(Goal)</TT>
where <TT>Goal</TT> is constructed by appending <TT>Arg1,&#X2026;, ArgN</TT>
(1 &#X2264; <TT>N</TT> &#X2264; 10) additional arguments to the arguments (if any)
of <TT>Closure</TT>.</P><P><TT>call_with_args(Functor, Arg1,&#X2026;, ArgN)</TT> calls the goal
whose functor is <TT>Functor</TT> and whose arguments are
<TT>Arg1</TT>,&#X2026;, <TT>ArgN</TT> (0 &#X2264; <TT>N</TT> &#X2264; 10).</P><P><TT>call_det(Goal, Deterministic)</TT> succeeds if <TT>call(Goal)</TT>
succeeds and unifies <TT>Deterministic</TT> with <TT>true</TT> if
<TT>Goal</TT> has not created any choice-points, with <TT>false</TT>
otherwise.</P><P><TT>forall(Condition, Action)</TT> succeeds if for all alternative bindings of
<TT>Condition</TT>, <TT>Action</TT> can be proven.
It is equivalent to <TT>\+ (Condition, \+ Action)</TT>.</P><P><TT>\+</TT> is a predefined prefix operator (section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Goal</TT> (or <TT>Condition</TT> or <TT>Action</TT>) is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Goal</TT> (or <TT>Condition</TT> or <TT>Action</TT>) is neither a variable nor a callable term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(callable, Goal)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
The predicate indicator <TT>Pred</TT> of <TT>Goal</TT> does not
correspond to an existing procedure and the value of the <TT>unknown</TT>
Prolog flag is <TT>error</TT> (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(procedure, Pred)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Functor</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Functor</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Functor)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Deterministic</TT> is neither a variable nor a boolean</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(boolean, Deterministic)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
for <TT>call/2-11</TT> the resulting arity of <TT>Goal</TT> (arity of <TT>Closure</TT> + <TT>N</TT>) is an integer &gt; <TT>max_arity</TT> flag (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(max_arity)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P><TT>false/0</TT>, <TT>call/2-8</TT>, <TT>once/1</TT> and <TT>(\+)/1</TT>
are ISO predicates. <TT>call/9-11</TT>, <TT>call_with_args/1-11</TT>,
<TT>call_det/2</TT> and <TT>forall/2</TT> are GNU Prolog predicates.</P><!--TOC subsubsection <TT>repeat/0</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc193">8.18.3</A>&#XA0;&#XA0;<TT>repeat/0</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
repeat</TT></DD></DL><P><B>Description</B></P><P><TT>repeat</TT> generates an infinite sequence of backtracking choices. The
purpose is to repeatedly perform some action on elements which are somehow
generated, e.g. by reading them from a stream, until some test becomes true.
Repeat loops cannot contribute to the logic of the program. They are only
meaningful if the action involves side-effects. The only reason for using
repeat loops instead of a more natural tail-recursive formulation is
efficiency: when the test fails back, the Prolog engine immediately reclaims
any working storage consumed since the call to <TT>repeat/0</TT>.</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>between/3</TT>, <TT>for/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc194">8.18.4</A>&#XA0;&#XA0;<TT>between/3</TT>, <TT>for/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
between(+integer, +integer, ?integer)<BR>
for(?integer, +integer, +integer)</TT></DD></DL><P><B>Description</B></P><P><TT>between(Lower, Upper, Counter)</TT> generates an sequence of backtracking
choices instantiating <TT>Counter</TT> to the values <TT>Lower</TT>,
<TT>Lower+1</TT>,&#X2026;, <TT>Upper</TT>. </P><P><TT>for(Counter, Lower, Upper)</TT> is equivalent to
<TT>between(Lower, Upper, Counter)</TT>. This predicate is deprecated and new
code should use <TT>between/3</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Counter</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Counter)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Lower</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Lower</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Lower)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Upper</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Upper</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Upper)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsection Atomic term processing-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc195">8.19</A>&#XA0;&#XA0;Atomic term processing</H3><!--SEC END --><P>
These built-in predicates enable atomic terms to be processed as a sequence
of characters and character codes. Facilities exist to split and join atoms,
to convert a single character to and from the corresponding character code,
and to convert a number to and from a list of characters and character
codes.</P><!--TOC subsubsection <TT>atom_length/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc196">8.19.1</A>&#XA0;&#XA0;<TT>atom_length/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
atom_length(+atom, ?integer)</TT></DD></DL><P><B>Description</B></P><P><TT>atom_length(Atom, Length)</TT> succeeds if <TT>Length</TT> unifies with
the number of characters of the name of <TT>Atom</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Atom)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Length</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Length)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Length</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, Length)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>atom_concat/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc197">8.19.2</A>&#XA0;&#XA0;<TT>atom_concat/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
atom_concat(+atom, +atom, ?atom)<BR>
atom_concat(?atom, ?atom, +atom)</TT></DD></DL><P><B>Description</B></P><P><TT>atom_concat(Atom1, Atom2, Atom12)</TT> succeeds if the name of
<TT>Atom12</TT> is the concatenation of the name of <TT>Atom1</TT> with the
name of <TT>Atom1</TT>. This predicate is re-executable on backtracking
(e.g. if <TT>Atom12</TT> is instantiated and both <TT>Atom1</TT> and
<TT>Atom2</TT> are variables).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom1</TT> and <TT>Atom12</TT> are variables</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom2</TT> and <TT>Atom12</TT> are variables</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom1</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Atom1)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom2</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Atom2)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom12</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Atom12)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>sub_atom/5</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc198">8.19.3</A>&#XA0;&#XA0;<TT>sub_atom/5</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
sub_atom(+atom, ?integer, ?integer, ?integer, ?atom)</TT></DD></DL><P><B>Description</B></P><P><TT>sub_atom(Atom, Before, Length, After, SubAtom)</TT> succeeds if atom
<TT>Atom</TT> can be split into three atoms, <TT>AtomL</TT>,
<TT>SubAtom</TT> and <TT>AtomR</TT> such that <TT>Before</TT> is the number
of characters of the name of <TT>AtomL</TT>, <TT>Length</TT> is the number
of characters of the name of <TT>SubAtom</TT> and <TT>After</TT> is the
number of characters of the name of <TT>AtomR</TT>. This predicate is
re-executable on backtracking.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Atom)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>SubAtom</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, SubAtom)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Before</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Before)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Length</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Length)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>After</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, After)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Before</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, Before)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Length</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, Length)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>After</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, After)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>char_code/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc199">8.19.4</A>&#XA0;&#XA0;<TT>char_code/2</TT></H4><!--SEC END --><P>
<A NAME="char-code/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
char_code(+character, ?character_code)<BR>
char_code(-character, +character_code)</TT></DD></DL><P><B>Description</B></P><P><TT>char_code(Char, Code)</TT> succeeds if the character code for the
one-char atom <TT>Char</TT> is <TT>Code</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Char</TT> and <TT>Code</TT> are variables</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Char</TT> is neither a variable nor a one-char atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(character, Char)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Code</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Code)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Code</TT> is an integer but not a character code</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(character_code)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>lower_upper/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc200">8.19.5</A>&#XA0;&#XA0;<TT>lower_upper/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
lower_upper(+character, ?character)<BR>
lower_upper(-character, +character)</TT></DD></DL><P><B>Description</B></P><P><TT>lower_upper(Char1, Char2)</TT> succeeds if <TT>Char1</TT> and
<TT>Char2</TT> are one-char atoms and if <TT>Char2</TT> is the upper
conversion of <TT>Char1</TT>. If <TT>Char1</TT> (resp. <TT>Char2</TT>) is a
character that is not a lower (resp. upper) letter then <TT>Char2</TT> is
equal to <TT>Char1</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Char1</TT> and <TT>Char2</TT> are variables</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Char1</TT> is neither a variable nor a one-char atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(character, Char1)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Char2</TT> is neither a variable nor a one-char atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(character, Char2)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>atom_chars/2</TT>,
<TT>atom_codes/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc201">8.19.6</A>&#XA0;&#XA0;<TT>atom_chars/2</TT>,
<TT>atom_codes/2</TT></H4><!--SEC END --><P>
<A NAME="atom-chars/2"></A>

</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
atom_chars(+atom, ?character_list)<BR>
atom_chars(-atom, +character_list)<BR>
atom_codes(+atom, ?character_code_list)<BR>
atom_codes(-atom, +character_code_list)</TT></DD></DL><P><B>Description</B></P><P><TT>atom_chars(Atom, Chars)</TT> succeeds if <TT>Chars</TT>
is the list of one-char atoms whose names are the successive characters of
the name of <TT>Atom</TT>.</P><P><TT>atom_codes(Atom, Codes)</TT> is similar to
<TT>atom_chars/2</TT> but deals with a list of character codes.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is a variable and <TT>Chars</TT> (or <TT>Codes</TT>)
is a partial list or a list with an element which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Atom)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Chars</TT> is neither a list nor a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Chars)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Codes</TT> is neither a list nor a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Codes)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
An element <TT>E</TT> of the list <TT>Chars</TT> is neither a
variable nor a one-char atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(character, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
An element <TT>E</TT> of the list <TT>Codes</TT> is neither a
variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
An element <TT>E</TT> of the list <TT>Codes</TT> is an integer but
not a character code</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(character_code)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicates. The ISO reference only causes a <TT>type_error(list,
Chars)</TT> if <TT>Atom</TT> is a variable and <TT>Chars</TT> is neither a list
nor a partial list. GNU Prolog always checks if <TT>Chars</TT> is a list.
Similarly for <TT>Codes</TT>. The <TT>type_error(integer, E)</TT> when an
element <TT>E</TT> of the <TT>Codes</TT> is not an integer is a GNU Prolog
extension. This seems to be an omission in the ISO reference since this
error is detected for many other built-in predicates accepting a character
code (e.g. <TT>char_code/2</TT>, <TT>put_code/2</TT>).</P><!--TOC subsubsection <TT>number_atom/2</TT>,
<TT>number_chars/2</TT>,
<TT>number_codes/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc202">8.19.7</A>&#XA0;&#XA0;<TT>number_atom/2</TT>,
<TT>number_chars/2</TT>,
<TT>number_codes/2</TT></H4><!--SEC END --><P>
<A NAME="number-atom/2"></A>


</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
number_atom(+number, ?atom)<BR>
number_atom(-number, +atom)<BR>
number_chars(+number, ?character_list)<BR>
number_chars(-number, +character_list)<BR>
number_codes(+number, ?character_code_list)<BR>
number_codes(-number, +character_code_list)</TT></DD></DL><P><B>Description</B></P><P><TT>number_atom(Number, Atom)</TT> succeeds if
<TT>Atom</TT> is an atom whose name corresponds to the characters of
<TT>Number</TT>.</P><P><TT>number_chars(Number, Chars)</TT> is similar to
<TT>number_atom/2</TT> but deals with a list of characters.</P><P><TT>number_codes(Number, Codes)</TT> is similar to
<TT>number_atom/2</TT> but deals with a list of character codes.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Number</TT> and <TT>Atom</TT> are variables</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Number</TT> is a variable and <TT>Chars</TT> (or
<TT>Codes</TT>) is a partial list or a list with an element which is a
variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Number</TT> is neither a variable nor an number</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(number, Number)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Atom)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Chars</TT> is neither a list nor a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Chars)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Codes</TT> is neither a list nor a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Codes)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
An element <TT>E</TT> of the list <TT>Chars</TT> is neither a
variable nor a one-char atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(character, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
An element <TT>E</TT> of the list <TT>Codes</TT> is neither a
variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
An element <TT>E</TT> of the list <TT>Codes</TT> is an integer but
not a character code</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(character_code)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Number</TT> is a variable, <TT>Atom</TT> (or <TT>Chars</TT> or
<TT>Codes</TT>) cannot be parsed as a number and the value of the
<TT>syntax_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>syntax_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P><TT>number_atom/2</TT> is a GNU Prolog predicate. <TT>number_chars/2</TT>
and <TT>number_codes/2</TT> are ISO predicates.</P><P>GNU Prolog only raises an error about an element <TT>E</TT> of the
<TT>Chars</TT> (or <TT>Codes</TT>) list when <TT>Number</TT> is a variable
while the ISO reference always check this. This seems an error since
the list itself is only checked if <TT>Number</TT> is a variable.</P><P>The <TT>type_error(integer, E)</TT> when an element <TT>E</TT> of the
<TT>Codes</TT> is not an integer is a GNU Prolog extension. This seems to be
an omission in the ISO reference since this error is detected for many other
built-in predicates accepting a character code (e.g. <TT>char_code/2</TT>,
<TT>put_code/2</TT>).</P><!--TOC subsubsection <TT>name/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc203">8.19.8</A>&#XA0;&#XA0;<TT>name/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
name(+atomic, ?character_code_list)<BR>
name(-atomic, +character_code_list)</TT></DD></DL><P><B>Description</B></P><P><TT>name(Constant, Codes)</TT> succeeds if <TT>Codes</TT> is a list whose
elements are the character codes corresponding to the successive characters
of <TT>Constant</TT> (a number or an atom). However, there atoms are for
which <TT>name(Constant, Codes)</TT> is true, but which will not be
constructed if <TT>name/2</TT> is called with <TT>Constant</TT>
uninstantiated, e.g. the atom <TT>&#X2019;1024&#X2019;</TT>. For this reason the use of
<TT>name/2</TT> is discouraged and should be limited to compatibility
purposes. It is preferable to use atom_codes/2 (section&#XA0;<A HREF="#atom-chars/2">8.19.6</A>)
or number_chars/2 (section&#XA0;<A HREF="#number-atom/2">8.19.7</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Constant</TT> is a variable and <TT>Codes</TT> is a partial
list or a list with an element which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Constant</TT> is neither a variable nor an atomic term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atomic, Constant)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Constant</TT> is a variable and <TT>Codes</TT> is neither a list
nor a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Codes)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Constant</TT> is a variable and an element <TT>E</TT> of the
list <TT>Codes</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Constant</TT> is a variable and an element <TT>E</TT> of the
list <TT>Codes</TT> is an integer but not a character code</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>representation_error(character_code)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>atom_hash/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc204">8.19.9</A>&#XA0;&#XA0;<TT>atom_hash/2</TT></H4><!--SEC END --><P>
<A NAME="atom-hash/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
atom_hash(+atom, ?integer)<BR>
atom_hash(?atom, +integer)</TT></DD></DL><P><B>Description</B></P><P><TT>atom_hash(Atom, Hash)</TT> succeeds if <TT>Hash</TT> is the internal
key associated with <TT>Atom</TT> (an existing atom). The internal key of an
atom is a unique integer &#X2265; 0 and &lt; to the <TT>max_atom</TT>
Prolog flag (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> and <TT>Hash</TT> are both variables</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Atom)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Hash</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Hash)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Hash</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, Hash)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>new_atom/3</TT>,
<TT>new_atom/2</TT>,
<TT>new_atom/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc205">8.19.10</A>&#XA0;&#XA0;<TT>new_atom/3</TT>,
<TT>new_atom/2</TT>,
<TT>new_atom/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
new_atom(+atom, +integer, -atom)<BR>
new_atom(+atom, -atom)<BR>
new_atom(-atom)</TT></DD></DL><P><B>Description</B></P><P><TT>new_atom(Prefix, Hash, Atom)</TT> unifies <TT>Atom</TT> with a new atom
whose name begins with the characters of the name of <TT>Prefix</TT> and
whose internal key is <TT>Hash</TT> (section&#XA0;<A HREF="#atom-hash/2">8.19.9</A>). This predicate is
then a symbol generator. It is guaranteed that <TT>Atom</TT> does not exist
before the invocation of <TT>new_atom/3</TT>. The characters appended to
<TT>Prefix</TT> to form <TT>Atom</TT> are in: <TT>A</TT>-<TT>Z</TT> (capital
letter), <TT>a</TT>-<TT>z</TT> (small letter), <TT>0</TT>-<TT>9</TT>
(digit), <TT>#</TT>, <TT>$</TT>, <TT>&amp;</TT>, <TT>_</TT>, <TT>@</TT>.</P><P><TT>new_atom/2</TT> is similar to <TT>new_atom/3</TT>, but the atom
generated can have any (free) internal key.</P><P><TT>new_atom/1</TT> is similar to <TT>new_atom(atom_, Atom)</TT>, i.e.
the generated atom begins with <TT>atom_</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Prefix</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Hash</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Prefix</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Prefix)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Hash</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Hash)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Hash</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, Hash)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(variable, Atom)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>current_atom/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc206">8.19.11</A>&#XA0;&#XA0;<TT>current_atom/1</TT></H4><!--SEC END --><P>
<A NAME="current-atom/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
current_atom(?atom)</TT></DD></DL><P><B>Description</B></P><P><TT>current_atom(Atom)</TT> succeeds if there exists an atom that unifies
with <TT>Atom</TT>. All atoms are found except those beginning with a
<TT>&#X2019;$&#X2019;</TT> (system atoms). This predicate is re-executable on
backtracking.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Atom)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>atom_property/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc207">8.19.12</A>&#XA0;&#XA0;<TT>atom_property/2</TT></H4><!--SEC END --><P>
<A NAME="atom-property/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
atom_property(?atom, ?atom_property)</TT></DD></DL><P><B>Description</B></P><P><TT>atom_property(Atom, Property)</TT> succeeds if
<TT>current_atom(Atom)</TT> succeeds (section&#XA0;<A HREF="#current-atom/2">8.19.11</A>) and if
<TT>Property</TT> unifies with one of the properties of the atom. This
predicate is re-executable on backtracking.</P><P><B>Atom properties</B>:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>length(Length)</TT>: <TT>Length</TT> is the length of the
name of the atom.</LI><LI CLASS="li-itemize"><TT>hash(Hash)</TT>: <TT>Hash</TT> is the internal key of the
atom (section&#XA0;<A HREF="#atom-hash/2">8.19.9</A>).</LI><LI CLASS="li-itemize"><TT>prefix_op</TT>: if there is a prefix operator currently defined
with this name.</LI><LI CLASS="li-itemize"><TT>infix_op</TT>: if there is an infix operator currently defined
with this name.</LI><LI CLASS="li-itemize"><TT>postfix_op</TT>: if there is a postfix operator currently defined
with this name.</LI><LI CLASS="li-itemize"><TT>needs_quotes</TT>: if the atom must be quoted to be read later.</LI><LI CLASS="li-itemize"><TT>needs_scan</TT>: if the atom must be scanned when output to be
read later (e.g. contains special characters that must be output with a
<TT>\</TT> escape sequence).</LI></UL><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Atom</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Atom)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Property</TT> is neither a variable nor a n atom property term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(atom_property, Property)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Property</TT> = <TT>length(E)</TT> or <TT>hash(E)</TT> and
<TT>E</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsection List processing-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc208">8.20</A>&#XA0;&#XA0;List processing</H3><!--SEC END --><P>These predicates manipulate lists. They are bootstrapped predicates (i.e.
written in Prolog) and no error cases are tested (for the moment). However,
since they are written in Prolog using other built-in predicates, some
errors can occur due to those built-in predicates.</P><!--TOC subsubsection <TT>append/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc209">8.20.1</A>&#XA0;&#XA0;<TT>append/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
append(?list, ?list, ?list)</TT></DD></DL><P><B>Description</B></P><P><TT>append(List1, List2, List12)</TT> succeeds if the concatenation of the
list <TT>List1</TT> and the list <TT>List2</TT> is the list <TT>List12</TT>.
This predicate is re-executable on backtracking (e.g. if <TT>List12</TT> is
instantiated and both <TT>List1</TT> and <TT>List2</TT> are variable).</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>member/2</TT>,
<TT>memberchk/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc210">8.20.2</A>&#XA0;&#XA0;<TT>member/2</TT>,
<TT>memberchk/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
member(?term, ?list)<BR>
memberchk(?term, ?list)</TT></DD></DL><P><B>Description</B></P><P><TT>member(Element, List)</TT> succeeds if <TT>Element</TT> belongs to the
<TT>List</TT>. This predicate is re-executable on backtracking and can be
thus used to enumerate the elements of <TT>List</TT>.</P><P><TT>memberchk/2</TT> is similar to <TT>member/2</TT> but only succeeds once.</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>reverse/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc211">8.20.3</A>&#XA0;&#XA0;<TT>reverse/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
reverse(?list, ?list)</TT></DD></DL><P><B>Description</B></P><P><TT>reverse(List1, List2)</TT> succeeds if <TT>List2</TT> unifies with the
list <TT>List1</TT> in reverse order.</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>delete/3</TT>,
<TT>select/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc212">8.20.4</A>&#XA0;&#XA0;<TT>delete/3</TT>,
<TT>select/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
delete(?list, ?term, ?list)<BR>
select(?term, ?list, ?list)</TT></DD></DL><P><B>Description</B></P><P><TT>delete(List1, Element, List2)</TT> removes all occurrences of
<TT>Element</TT> in <TT>List1</TT> to provide <TT>List2</TT>. A strict term
equality is required, cf. <TT>(==)/2</TT> (section&#XA0;<A HREF="#(==)/2">8.3.2</A>).</P><P><TT>select(Element, List1, List2)</TT> removes one occurrence of
<TT>Element</TT> in <TT>List1</TT> to provide <TT>List2</TT>. This predicate
is re-executable on backtracking.</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>permutation/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc213">8.20.5</A>&#XA0;&#XA0;<TT>permutation/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
permutation(?list, ?list)</TT></DD></DL><P><B>Description</B></P><P><TT>permutation(List1, List2)</TT> succeeds if <TT>List2</TT>
is a permutation of the elements of <TT>List1</TT>. This predicate is
re-executable on backtracking.</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>prefix/2</TT>,
<TT>suffix/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc214">8.20.6</A>&#XA0;&#XA0;<TT>prefix/2</TT>,
<TT>suffix/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
prefix(?list, ?list)<BR>
suffix(?list, ?list)</TT></DD></DL><P><B>Description</B></P><P><TT>prefix(Prefix, List)</TT> succeeds if <TT>Prefix</TT> is a prefix of
<TT>List</TT>. This predicate is re-executable on backtracking.</P><P><TT>suffix(Suffix, List)</TT> succeeds if <TT>Suffix</TT> is a suffix of
<TT>List</TT>. This predicate is re-executable on backtracking.</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>sublist/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc215">8.20.7</A>&#XA0;&#XA0;<TT>sublist/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
sublist(?list, ?list)</TT></DD></DL><P><B>Description</B></P><P><TT>sublist(List1, List2)</TT> succeeds if <TT>List1</TT> is a sub-list of
<TT>List2</TT>. This predicate is re-executable on backtracking.</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>last/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc216">8.20.8</A>&#XA0;&#XA0;<TT>last/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
last(?list, ?term)</TT></DD></DL><P><B>Description</B></P><P><TT>last(List, Element)</TT> succeeds if <TT>Element</TT> is the last element
of <TT>List</TT>.</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>length/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc217">8.20.9</A>&#XA0;&#XA0;<TT>length/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
length(?list, ?integer)</TT></DD></DL><P><B>Description</B></P><P><TT>length(List, Length)</TT> succeeds if <TT>Length</TT> is the length of
<TT>List</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Length</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, Length)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>nth/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc218">8.20.10</A>&#XA0;&#XA0;<TT>nth/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
nth(?integer, ?list, ?term)</TT></DD></DL><P><B>Description</B></P><P><TT>nth(N, List, Element)</TT> succeeds if the <TT>N</TT><EM>th</EM>
argument of <TT>List</TT> is <TT>Element</TT>.</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>max_list/2</TT>,
<TT>min_list/2</TT>,
<TT>sum_list/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc219">8.20.11</A>&#XA0;&#XA0;<TT>max_list/2</TT>,
<TT>min_list/2</TT>,
<TT>sum_list/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
min_list(+list, ?number)<BR>
max_list(+list, ?number)<BR>
sum_list(+list, ?number)</TT></DD></DL><P><B>Description</B></P><P><TT>min_list(List, Min)</TT> succeeds if <TT>Min</TT> is the
smallest number in <TT>List</TT>.</P><P><TT>max_list(List, Max)</TT> succeeds if <TT>Max</TT> is the
largest number in <TT>List</TT>.</P><P><TT>sum_list(List, Sum)</TT> succeeds if <TT>Sum</TT> is the
sum of all the elements in <TT>List</TT>.</P><P><TT>List</TT> must be a list of arithmetic evaluable terms
(section&#XA0;<A HREF="#Evaluation-of-an-arithmetic-expression">8.6.1</A>).</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>maplist/2-8</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc220">8.20.12</A>&#XA0;&#XA0;<TT>maplist/2-8</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
maplist(+callable_term, +list, &#X2026;, +list)</TT></DD></DL><P><B>Description</B></P><P><TT>maplist(Goal, List)</TT> succeeds if <TT>Goal</TT> can succesfully be
applied on all elements of <TT>List</TT>.</P><P><TT>maplist(Goal, List1, List2)</TT> succeeds if <TT>Goal</TT> can succesfully be
applied to all pairs of elements of <TT>List1</TT> and <TT>List2</TT>.</P><P><TT>maplist(Goal, List1, List2, List3)</TT> succeeds if <TT>Goal</TT> can succesfully be
applied to all triples of elements of <TT>List1</TT>..<TT>List3</TT>.</P><P><TT>maplist(Goal, List1, List2, &#X2026;, List<I>N</I>)</TT> succeeds if <TT>Goal</TT> can succesfully be
applied to all <I>N</I>-uples (<I>N</I> &#X2264; 8) of elements of <TT>List1</TT>..<TT>List<I>N</I></TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an error occurs executing a directive</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left>see <TT>call/1</TT> errors (section&#XA0;<A HREF="#call/1">7.2.3</A>)</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>sort/2</TT>,
<TT>msort/2</TT>,
<TT>keysort/2</TT>
<TT>sort/1</TT>,
<TT>msort/1</TT>,
<TT>keysort/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc221">8.20.13</A>&#XA0;&#XA0;<TT>sort/2</TT>,
<TT>msort/2</TT>,
<TT>keysort/2</TT>
<TT>sort/1</TT>,
<TT>msort/1</TT>,
<TT>keysort/1</TT></H4><!--SEC END --><P>
<A NAME="sort/2"></A>





</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
sort(+list, ?list)<BR>
msort(+list, ?list)<BR>
keysort(+list, ?list)<BR>
sort(+list)<BR>
msort(+list)<BR>
keysort(+list)</TT></DD></DL><P><B>Description</B></P><P><TT>sort(List1, List2)</TT> succeeds if <TT>List2</TT> is the
sorted list corresponding to <TT>List1</TT> where duplicate elements are
merged.</P><P><TT>msort/2</TT> is similar to <TT>sort/2</TT> except that duplicate elements
are not merged.</P><P><TT>keysort(List1, List2)</TT> succeeds if <TT>List2</TT> is the
sorted list of <TT>List1</TT> according to the keys. The list <TT>List1</TT>
consists of pairs (items of the form <TT>Key-Value</TT>). These items are sorted
according to the value of <TT>Key</TT> yielding the <TT>List2</TT>. Duplicate
keys are not merged. This predicate is stable, i.e. if <TT>K-A</TT> occurs
before <TT>K-B</TT> in the input, then <TT>K-A</TT> will occur before
<TT>K-B</TT> in the output.</P><P><TT>sort/1</TT>, <TT>msort/1</TT> and <TT>keysort/1</TT> are similar to
<TT>sort/2</TT>, <TT>msort/2</TT> and <TT>keysort/2</TT> but achieve a sort
in-place destructing the original <TT>List1</TT> (this in-place assignment is
not undone at backtracking). The sorted list occupies the same memory space
as the original list (saving thus memory consumption).</P><P>The time complexity of these sorts is <I>O</I>(<I>N</I>&#XA0;<I>log</I>&#XA0;<I>N</I>), <I>N</I> being the length of
the list to sort.</P><P>These predicates refer to the standard ordering of terms
(section&#XA0;<A HREF="#Standard-total-ordering-of-terms">8.3.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List1</TT> is a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List1</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, List1)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List2</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, List2)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
for <TT>keysort/2</TT>: an element of <TT>List1</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
for <TT>keysort/2</TT>: an element <TT>E</TT> of <TT>List1</TT> is neither a variable nor a pair</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(pair, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
for <TT>keysort/2</TT>: an element <TT>E</TT> of <TT>List2</TT> is neither a variable nor a pair</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(pair, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P><TT>sort/2</TT> and <TT>keysort/2</TT> are ISO predicates.</P><P><TT>sort/1</TT>, <TT>keysort/1</TT> and <TT>msort/1-2</TT> are GNU Prolog predicates.</P><!--TOC subsection Global variables-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc222">8.21</A>&#XA0;&#XA0;Global variables</H3><!--SEC END --><!--TOC subsubsection Introduction-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc223">8.21.1</A>&#XA0;&#XA0;Introduction</H4><!--SEC END --><P>
<A NAME="Global-variables"></A></P><P>GNU Prolog provides a simple and powerful way to assign and read global
variables. A global variable is associated with each atom, its initial value is
the integer 0. A global variable can store 3 kinds of objects:</P><UL CLASS="itemize"><LI CLASS="li-itemize">a copy of a term (the assignment can be made backtrackable or not).</LI><LI CLASS="li-itemize">a link to a term (the assignment is always backtrackable).</LI><LI CLASS="li-itemize">an array of objects (recursively).</LI></UL><P>The space necessary for copies and arrays is dynamically allocated and
recovered as soon as possible. For instance, when an atom is associated with a
global variable whose current value is an array, the space for this array is
recovered (unless the assignment is to be undone when backtracking occurs).</P><P>When a link to a term is associated with a global variable, the reference to
this term is stored and thus the original term is returned when the content
of the variable is read.</P><P><B>Global variable naming convention</B>: a global variable is referenced
by an atom.</P><P>If the variable contains an array, an index (ranging from 0) can be provided
using a compound term whose principal functor is the corresponding atom and
the argument is the index. In case of a multi-dimensional array, each index
is given as the arguments of the compound term.</P><P>If the variable contains a term (link or copy), it is possible to only
reference a sub-term by giving its argument number (also called argument
selector). Such a sub-term is specified using a compound term whose
principal functor is <TT>-/2</TT> and whose first argument is a global
variable name and the second argument is the argument number (from 1). This
can be applied recursively to specify a sub-term of any depth. In case of a
list, a argument number I represents the Ith element of the list. In the
rest of this section we use the operator notation since <TT>-</TT> is a
predefined infix operator (section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</P><P>In the following, <I><TT>GVarName</TT></I> represents a reference to a global
variable and its syntax is as follows:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><I><TT>GVarName</TT></I></TD><TD ALIGN=left NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I><TT>atom</TT></I></TD><TD ALIGN=left NOWRAP>whole content of a variable</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><TT><I>atom</I>(<I>Integer</I>,</TT>&#X2026;<TT>,<I>Integer</I>)</TT></TD><TD ALIGN=left NOWRAP>element of an array</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><TT><I>GVarName</I>-<I>Integer</I></TT></TD><TD ALIGN=left NOWRAP>sub-term selection</TD></TR>
<TR><TD ALIGN=left NOWRAP><I><TT>Integer</TT></I></TD><TD ALIGN=left NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I><TT>integer</TT></I></TD><TD ALIGN=left NOWRAP>immediate value</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP><I><TT>GVarName</TT></I></TD><TD ALIGN=left NOWRAP>indirect value</TD></TR>
</TABLE>
</DD></DL><P>When a <I><TT>GVarName</TT></I> is used as an index or an argument number
(i.e. indirection), the value of this variable must be an integer.</P><P>Here are some examples of the naming convention:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><TT>a</TT></TD><TD ALIGN=left NOWRAP>the content of variable associated with <TT>a</TT> (any kind)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>t(1)</TT></TD><TD ALIGN=left NOWRAP>the 2nd element of the array associated with <TT>t</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>t(k)</TT></TD><TD ALIGN=left NOWRAP>if the value associated with <TT>k</TT> is I, the Ith element of the array associated with <TT>t</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>a-1-2</TT></TD><TD ALIGN=left NOWRAP>if the value associated with <TT>a</TT> is <TT>f(g(a,b,c),2)</TT>, the sub-term <TT>b</TT></TD></TR>
</TABLE><P>Here are the errors associated with global variable names and common to all
predicates.</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>GVarName</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>GVarName</TT> is neither a variable nor a callable term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(callable, GVarName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>GVarName</TT> contains an invalid argument number
(or <TT>GVarName</TT> is an array)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(g_argument_selector, GVarName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>GVarName</TT> contains an invalid index
(or <TT>GVarName</TT> is not an array)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(g_array_index, GVarName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>GVarName</TT> is used as an indirect index or argument selector
and is not an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, GVarName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Arrays</B>: the predicates <TT>g_assign/2</TT>, <TT>g_assignb/2</TT>
and <TT>g_link/2</TT> (section&#XA0;<A HREF="#g-assign/2">8.21.2</A>) can be used to create an
array. They recognize some terms as values. For instance, a compound term
with principal functor <TT>g_array</TT> is used to define an array of fixed
size. There are 3 forms for the term <TT>g_array</TT>:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>g_array(Size)</TT>: if <TT>Size</TT> is an integer &gt; 0 then
defines an array of <TT>Size</TT> elements which are all initialized with
the integer <TT>0</TT>.</LI><LI CLASS="li-itemize"><TT>g_array(Size, Initial)</TT>: as above but the elements are
initialized with the term <TT>Initial</TT> instead of 0. <TT>Initial</TT>
can contain other array definitions allowing thus for multi-dimensional
arrays.</LI><LI CLASS="li-itemize"><TT>g_array(List)</TT>: as above if <TT>List</TT> is a list of length
<TT>Size</TT> except that the elements of the array are initialized
according to the elements of <TT>List</TT> (which can contain other array
definitions).</LI></UL><P>An array can be extended explicitly using a compound term with principal
functor <TT>g_array_extend</TT> which accept the same 3 forms detailed
above. In that case, the existing elements of the array are not
initialized. If <TT>g_array_extend</TT> is used with an object which is not
an array it is similar to <TT>g_array</TT>.</P><P>Finally, an array can be <I>automatically</I> expanded when needed. The
programmer does not need to explicitly control the expansion of an automatic
array. An array is expanded as soon as an index is outside the current size
of this array. Such an array is defined using a compound term with principal
functor <TT>g_array_auto</TT>:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>g_array_auto(Size)</TT>: if <TT>Size</TT> is an integer &gt; 0
then defines an automatic array whose initial size is <TT>Size</TT>. All
elements are initialized with the integer <TT>0</TT>. Elements
created during implicit expansions will be initialized with <TT>0</TT>.</LI><LI CLASS="li-itemize"><TT>g_array_auto(Size, Initial)</TT>: as above but the elements are
initialized with the term <TT>Initial</TT> instead of 0. <TT>Initial</TT> can
contain other array definitions allowing thus for multi-dimensional
arrays. Elements created during implicit expansions will be initialized with
<TT>Initial</TT>.</LI><LI CLASS="li-itemize"><TT>g_array_auto(List)</TT>: as above if <TT>List</TT> is a list of
length <TT>Size</TT> except that the elements of the array are initialized
according to the elements of <TT>List</TT> (which can contain other array
definitions). Elements created during implicit expansions will be initialized
with <TT>0</TT>.</LI></UL><P>In any case, when an array is read, a term of the form
<TT>g_array([Elem0,..., ElemSize-1])</TT> is returned.</P><P>Some examples using global variables are presented later (section&#XA0;<A HREF="#Examples">8.21.7</A>).</P><!--TOC subsubsection <TT>g_assign/2</TT>,
<TT>g_assignb/2</TT>,
<TT>g_link/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc224">8.21.2</A>&#XA0;&#XA0;<TT>g_assign/2</TT>,
<TT>g_assignb/2</TT>,
<TT>g_link/2</TT></H4><!--SEC END --><P>
<A NAME="g-assign/2"></A>


</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
g_assign(+callable_term, ?term)<BR>
g_assignb(+callable_term, ?term)<BR>
g_link(+callable_term, ?term)</TT></DD></DL><P><B>Description</B></P><P><TT>g_assign(GVarName, Value)</TT> assigns a copy of the term
<TT>Value</TT> to <TT>GVarName</TT>. This assignment is not undone when
backtracking occurs.</P><P><TT>g_assignb/2</TT> is similar to <TT>g_assign/2</TT> but the assignment
is undone at backtracking.</P><P><TT>g_link(GVarName, Value)</TT> makes a link between <TT>GVarName</TT> to
the term <TT>Value</TT>. This allows the user to give a name to any Prolog
term (in particular non-ground terms). Such an assignment is always undone
when backtracking occurs (since the term may no longer exist). If
<TT>Value</TT> is an atom or an integer, <TT>g_link/2</TT> and
<TT>g_assignb/2</TT> have the same behavior. Since <TT>g_link/2</TT> only
handles links to existing terms it does not require extra memory space and
is not expensive in terms of execution time.</P><P>NB: argument selectors can only be used with g_assign/2 (i.e. when using
an argument selector inside an assignment, this one must not be
backtrackable).</P><P><B>Errors</B></P><P>See common errors detailed in the introduction (section&#XA0;<A HREF="#Global-variables">8.21.1</A>)</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>GVarName</TT> contains an argument selector and the assignment
is backtrackable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(g_argument_selector, GVarName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>g_read/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc225">8.21.3</A>&#XA0;&#XA0;<TT>g_read/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
g_read(+callable_term, ?term)</TT></DD></DL><P><B>Description</B></P><P><TT>g_read(GVarName, Value)</TT> unifies <TT>Value</TT> with the term
assigned to <TT>GVarName</TT>.</P><P><B>Errors</B></P><P>See common errors detailed in the introduction (section&#XA0;<A HREF="#Global-variables">8.21.1</A>)</P><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>g_array_size/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc226">8.21.4</A>&#XA0;&#XA0;<TT>g_array_size/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
g_array_size(+callable_term, ?integer)</TT></DD></DL><P><B>Description</B></P><P><TT>g_array_size(GVarName, Value)</TT> unifies <TT>Size</TT> with the
dimension (an integer &gt; 0) of the array assigned to <TT>GVarName</TT>.
Fails if <TT>GVarName</TT> is not an array.</P><P><B>Errors</B></P><P>See common errors detailed in the introduction (section&#XA0;<A HREF="#Global-variables">8.21.1</A>)</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Size</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Size)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>g_inc/3</TT>,
<TT>g_inc/2</TT>,
<TT>g_inco/2</TT>,
<TT>g_inc/1</TT>,
<TT>g_dec/3</TT>,
<TT>g_dec/2</TT>,
<TT>g_deco/2</TT>,
<TT>g_dec/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc227">8.21.5</A>&#XA0;&#XA0;<TT>g_inc/3</TT>,
<TT>g_inc/2</TT>,
<TT>g_inco/2</TT>,
<TT>g_inc/1</TT>,
<TT>g_dec/3</TT>,
<TT>g_dec/2</TT>,
<TT>g_deco/2</TT>,
<TT>g_dec/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
g_inc(+callable_term, ?integer, ?integer)<BR>
g_inc(+callable_term, ?integer)<BR>
g_inco(+callable_term, ?integer)<BR>
g_inc(+callable_term)<BR>
g_dec(+callable_term, ?integer, ?integer)<BR>
g_dec(+callable_term, ?integer)<BR>
g_deco(+callable_term, ?integer)<BR>
g_dec(+callable_term)</TT></DD></DL><P><B>Description</B></P><P><TT>g_inc(GVarName, Old, New)</TT> unifies <TT>Old</TT> with the
integer assigned to <TT>GVarName</TT>, increments <TT>GVarName</TT> and
then unifies <TT>New</TT> with the incremented value.</P><P><TT>g_inc(GVarName, New)</TT> is equivalent to
<TT>g_inc(GVarName, _, New)</TT>.</P><P><TT>g_inco(GVarName, Old)</TT> is equivalent to
<TT>g_inc(GVarName, Old, _)</TT>.</P><P><TT>g_inc(GVarName)</TT> is equivalent to <TT>g_inc(GVarName, _, _)</TT>.</P><P>Predicates <TT>g_dec</TT> are similar but decrement the content of
<TT>GVarName</TT> instead.</P><P><B>Errors</B></P><P>See common errors detailed in the introduction (section&#XA0;<A HREF="#Global-variables">8.21.1</A>)</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Old</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Old)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>New</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, New)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>GVarName</TT> stores an array</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, g_array)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>GVarName</TT> stores a term <TT>T</TT> which is not an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, T)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>g_set_bit/2</TT>,
<TT>g_reset_bit/2</TT>,
<TT>g_test_set_bit/2</TT>,
<TT>g_test_reset_bit/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc228">8.21.6</A>&#XA0;&#XA0;<TT>g_set_bit/2</TT>,
<TT>g_reset_bit/2</TT>,
<TT>g_test_set_bit/2</TT>,
<TT>g_test_reset_bit/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
g_set_bit(+callable_term, +integer)<BR>
g_reset_bit(+callable_term, +integer)<BR>
g_test_set_bit(+callable_term, +integer)<BR>
g_test_reset_bit(+callable_term, +integer)</TT></DD></DL><P><B>Description</B></P><P><TT>g_set_bit(GVarName, Bit)</TT> sets to 1 the bit number specified by
<TT>Bit</TT> of the integer assigned to <TT>GVarName</TT> to 1. Bit numbers
range from 0 to the maximum number allowed for integers (this is architecture dependent). If <TT>Bit</TT> is greater than this limit,
the modulo with this limit is taken.</P><P><TT>g_reset_bit(GVarName, Bit)</TT> is similar to <TT>g_set_bit/2</TT> but
sets the specified bit to 0.</P><P><TT>g_test_set_bit/2</TT> succeeds if the specified bit is set to 1.</P><P><TT>g_test_reset_bit/2</TT> succeeds if the specified bit is set to 0.</P><P><B>Errors</B></P><P>See common errors detailed in the introduction (section&#XA0;<A HREF="#Global-variables">8.21.1</A>)</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Bit</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Bit</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Bit)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Bit</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, Bit)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>GVarName</TT> stores an array</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, g_array)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>GVarName</TT> stores a term <TT>T</TT> which is not an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, T)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection Examples-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc229">8.21.7</A>&#XA0;&#XA0;Examples</H4><!--SEC END --><P>
<A NAME="Examples"></A></P><P><B>Simulating <TT>g_inc/3</TT></B>: this predicate behaves like:
global variable:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">my_g_inc(Var, Old, New) :-
        g_read(Var, Old),
        N is Value + 1,
        g_assign(Var, X),
 New = N.
</PRE></DD></DL><P>The query: <TT>my_g_inc(c, X, _)</TT> will succeed unifying <TT>X</TT> with
<TT>0</TT>, another call to <TT>my_g_inc(a, Y, _)</TT> will then unify
<TT>Y</TT> with <TT>1</TT>, and so on.</P><P><B>Difference between <TT>g_assign/2</TT> and <TT>g_assignb/2</TT></B>:
<TT>g_assign/2</TT> does not undo its assignment when backtracking occurs
whereas <TT>g_assignb/2</TT> undoes it.</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
</TT><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>test(Old) :-</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>&#XA0;&#XA0;</TT></TD><TD VALIGN=top ALIGN=left NOWRAP><TT>testb(Old) :-</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;g_assign(x,1),</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>&#XA0;&#XA0;</TT></TD><TD VALIGN=top ALIGN=left NOWRAP><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;g_assign(x,1),</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;(&#XA0;&#XA0;&#XA0;g_read(x, Old),</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>&#XA0;&#XA0;</TT></TD><TD VALIGN=top ALIGN=left NOWRAP><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;(&#XA0;&#XA0;&#XA0;g_read(x, Old),</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;<I>g_assign</I>(x, 2)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>&#XA0;&#XA0;</TT></TD><TD VALIGN=top ALIGN=left NOWRAP><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;<I>g_assignb</I>(x, 2)</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;;&#XA0;&#XA0;&#XA0;g_read(x,&#XA0;Old),</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>&#XA0;&#XA0;</TT></TD><TD VALIGN=top ALIGN=left NOWRAP><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;;&#XA0;&#XA0;&#XA0;g_read(x, Old),</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;g_assign(x, 3)</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>&#XA0;&#XA0;</TT></TD><TD VALIGN=top ALIGN=left NOWRAP><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;g_assign(x, 3)</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;).</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>&#XA0;&#XA0;</TT></TD><TD VALIGN=top ALIGN=left NOWRAP><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;).</TT></TD></TR>
</TABLE><TT>
</TT></DD></DL><P>The query <TT>test(Old)</TT> will succeed unifying <TT>Old</TT> with
<TT>1</TT> and on backtracking with <TT>2</TT> (i.e. the assignment of the
value <TT>2</TT> has not been undone). The query <TT>testb(Old)</TT> will
succeed unifying <TT>Old</TT> with <TT>1</TT> and on backtracking with
<TT>1</TT> (i.e. the assignment of the value <TT>2</TT> has been undone).</P><P><B>Difference between <TT>g_assign/2</TT> and <TT>g_link/2</TT></B>:
<TT>g_assign/2</TT> (and <TT>g_assignb/2</TT>) creates a copy of the term
whereas <TT>g_link/2</TT> does not. <TT>g_link/2</TT> can be used to avoid
passing big data structures (e.g. dictionaries,&#X2026;) as arguments to
predicates.</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
</TT><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><TT>test(B) :-</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>&#XA0;&#XA0;</TT></TD><TD VALIGN=top ALIGN=left NOWRAP><TT>test(B) :-</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;<I>g_assign</I>(b, f(X)),</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>&#XA0;&#XA0;</TT></TD><TD VALIGN=top ALIGN=left NOWRAP><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;<I>g_link</I>(b, f(X)),</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;X = 12,</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>&#XA0;&#XA0;</TT></TD><TD VALIGN=top ALIGN=left NOWRAP><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;X = 12,</TT></TD></TR>
<TR><TD VALIGN=top ALIGN=left><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;g_read(b, B).</TT></TD><TD VALIGN=top ALIGN=center NOWRAP><TT>&#XA0;&#XA0;</TT></TD><TD VALIGN=top ALIGN=left NOWRAP><TT>&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;&#XA0;g_read(b, B).</TT></TD></TR>
</TABLE><TT>
</TT></DD></DL><P>The query <TT>test(B)</TT> will succeed unifying <TT>B</TT> with
<TT>f(_)</TT> (<TT>g_assign/2</TT> assigns a copy of the value). The query
<TT>test(B)</TT> will succeed unifying <TT>B</TT> with <TT>f(12)</TT>
(<TT>g_link/2</TT> assigns a pointer to the term).</P><P><B>Simple array definition</B>: here are some queries to show how arrays
can be handled:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">| ?- g_assign(w, g_array(3)), g_read(w, X).

X = g_array([0,0,0])

| ?- g_assign(w(0), 16), g_assign(w(1), 32), g_assign(w(2), 64), g_read(w, X).

X = g_array([16,32,64])
</PRE></DD></DL><P>this is equivalent to:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">| ?- g_assign(k, g_array([16,32,64])), g_read(k, X).

X = g_array([16,32,64])

| ?- g_assign(k, g_array(3,null)), g_read(k, X), g_array_size(k, S).

S = 3
X = g_array([null,null,null])
</PRE></DD></DL><P><B>2-D array definition</B>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">| ?- g_assign(w, g_array(2, g_array(3))), g_read(w, X).

X = g_array([g_array([0,0,0]),g_array([0,0,0])])

| ?- (   for(I,0,1), for(J,0,2), K is I*3+J, g_assign(w(I,J), K),
         fail
     ;   g_read(w, X)
     ).

X = g_array([g_array([0,1,2]),g_array([3,4,5])])

| ?- g_read(w(1),X).

X = g_array([3,4,5])
</PRE></DD></DL><P><B>Hybrid array</B>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">| ?- g_assign(w,g_array([1,2,g_array([a,b,c]), g_array(2,z),5])), g_read(w, X).

X = g_array([1,2,g_array([a,b,c]), g_array([z,z]),5])

| ?- g_read(w(1), X), g_read(w(2,1), Y), g_read(w(3,1), Z).

X = 2
Y = b
Z = z

| ?- g_read(w(1,2),X).
uncaught exception: error(domain_error(g_array_index,w(1,2)),g_read/2)
</PRE></DD></DL><P><B>Array extension</B>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">| ?- g_assign(a, g_array([10,20,30])), g_read(a, X).

X = g_array([10,20,30])

| ?- g_assign(a, g_array_extend(5,null)), g_read(a, X).

X = g_array([10,20,30,null,null])

| ?- g_assign(a, g_array([10,20,30])), g_read(a, X).

X = g_array([10,20,30])

| ?- g_assign(a, g_array_extend([1,2,3,4,5,6])), g_read(a, X).

X = g_array([10,20,30,4,5,6])
</PRE></DD></DL><P><B>Automatic array</B>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">| ?- g_assign(t, g_array_auto(3)), g_assign(t(1), foo), g_read(t,X).

X = g_array([0,foo,0])

| ?- g_assign(t(5), bar), g_read(t,X).

X = g_array([0,foo,0,0,0,bar,0,0])

| ?- g_assign(t, g_array_auto(2, g_array(2))), g_assign(t(1,1), foo),
     g_read(t,X).

X = g_array([g_array([0,0]),g_array([0,foo])])

| ?- g_assign(t(3,0), bar), g_read(t,X).

X = g_array([g_array([0,0]),g_array([0,foo]),g_array([0,0]),g_array([bar,0])])

| ?- g_assign(t(3,4), bar), g_read(t,X).
uncaught exception: error(domain_error(g_array_index,t(3,4)),g_assign/2)

| ?- g_assign(t, g_array_auto(2, g_array_auto(2))), g_assign(t(1,1), foo),
     g_read(t,X).

X = g_array([g_array([0,0]),g_array([0,foo])])

| ?- g_assign(t(3,3), bar), g_read(t,X).

X = g_array([g_array([0,0]),g_array([0,foo]),g_array([0,0]),
    g_array([0,0,0,bar])])

| ?- g_assign(t, g_array_auto(2, g_array_auto(2, null))), g_read(t(2,3), U),
     g_read(t, X).

U = null
X = g_array([g_array([null,null]),g_array([null,null]),
             g_array([null,null,null,null]),g_array([null,null])])
</PRE></DD></DL><!--TOC subsection Prolog state-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc230">8.22</A>&#XA0;&#XA0;Prolog state</H3><!--SEC END --><!--TOC subsubsection <TT>set_prolog_flag/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc231">8.22.1</A>&#XA0;&#XA0;<TT>set_prolog_flag/2</TT></H4><!--SEC END --><P>
<A NAME="set-prolog-flag/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
set_prolog_flag(+flag, +term)</TT></DD></DL><P><B>Description</B></P><P><TT>set_prolog_flag(Flag, Value)</TT> sets the value
of the Prolog flag <TT>Flag</TT> to <TT>Value</TT>.</P><P>
<B>Prolog flags</B>: a Prolog flag is an atom
which is associated with a value that is either implementation defined
or defined by the user. Each flag has a permitted range of values; any
other value is a <TT>domain_error</TT>. The following two tables
present available flags, the possible values, a description and if
they are ISO or an extension. The first table presents unchangeable
flags while the second one the changeable flags. For flags whose
default values is machine independent, this value is
<U>underlined</U>.</P><P><B>Unchangeable flags</B>:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
Flag</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Values</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">Description</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">ISO</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>bounded</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"><U><TT>true</TT></U> / <TT>false</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">are integers
bounded ?</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Y</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>max_integer</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">an integer</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">greatest integer</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Y</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>min_integer</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">an integer</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">smallest integer</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Y</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>integer_rounding_function</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"><TT>toward_zero</TT>
<BR>
<TT>down</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"> <TT><I>rnd</I>(X)</TT> = integer part of <TT>X</TT>
<BR>
<TT><I>rnd</I>(X)</TT> = &#X230A;<TT>X&#X230B;</TT>
(section&#XA0;<A HREF="#Evaluation-of-an-arithmetic-expression">8.6.1</A>)</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Y</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>max_arity</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">an integer</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">maximum arity for compound terms (255)</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Y</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>max_atom</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">an integer</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">maximum number of atoms</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>max_unget</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">an integer</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">maximum number of successive ungets</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>prolog_name</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">an atom</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">name of the Prolog system</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>prolog_version</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">an atom</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">version number of the Prolog system</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>prolog_date</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">an atom</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">date of the Prolog system</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>prolog_copyright</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">an atom</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">copyright message of the Prolog
system</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>dialect</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">an atom</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">fixed to <TT>gprolog</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>home</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">an atom</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">GNU Prolog home directory</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>host_os</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">an atom</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">Operating System identifier</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>host_vendor</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">an atom</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">Operating System vendor</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>host_cpu</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">an atom</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">processor identifier</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>host</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">an atom</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">a combination of the OS-vendor-cpu</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>arch</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">an atom</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">a combination of the OS-cpu</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>version</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">an integer</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><I>Major</I> * 10000 + <I>Minor</I> * 100 + <I>Patch</I></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>version_data</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">a structure</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>gprolog(Major,Minor,Patch,Extra)</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>unix</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"><TT>true</TT> / <TT>false</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>true</TT> if the underlying OS is unix-like</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
</TABLE><P><B>Changeable flags</B>:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
Flag</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Values</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">Description</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">ISO</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>char_conversion</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"><TT>on</TT> / <U><TT>off</TT></U></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">is
character conversion activated ?</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Y</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>debug</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"><TT>on</TT> / <U><TT>off</TT></U></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">is the debugger
activated ?</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">Y</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>singleton_warning</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"><U><TT>on</TT></U> / <TT>off</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">warn
about named singleton variables ?</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>suspicious_warning</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"><U><TT>on</TT></U> / <TT>off</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">warn
about suspicious predicate ?</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>multifile_warning</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"><U><TT>on</TT></U> / <TT>off</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">warn
about unsupported multifile directive ?</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
<TT>strict_iso</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"><U><TT>on</TT></U> / <TT>off</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">strict ISO
behavior ?</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center">N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
&#XA0;
<BR>
<TT>double_quotes</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"> &#XA0;
<BR>
<TT>atom</TT>
<BR>
<TT>chars</TT>
<BR>
<U><TT>codes</TT></U>
<BR>
<TT>atom_no_escape</TT>
<BR>
<TT>chars_no_escape</TT>
<BR>
<TT>codes_no_escape</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"> a double quoted constant is returned as:
<BR>
an atom
<BR>
a list of characters
<BR>
a list of character codes
<BR>
as <TT>atom</TT> but ignore escape sequences
<BR>
as <TT>chars</TT> but ignore escape sequences
<BR>
as <TT>code</TT> but ignore escape sequences</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"> &#XA0;
<BR>
Y
<BR>
&#XA0;
<BR>
&#XA0;
<BR>
N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
&#XA0;
<BR>
<TT>back_quotes</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"> &#XA0;
<BR>
<TT>atom</TT>
<BR>
<TT>chars</TT>
<BR>
<TT>codes</TT>
<BR>
<U><TT>atom_no_escape</TT></U>
<BR>
<TT>chars_no_escape</TT>
<BR>
<TT>codes_no_escape</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"> a back quoted constant is returned as:
<BR>
an atom
<BR>
a list of characters
<BR>
a list of character codes
<BR>
as <TT>atom</TT> but ignore escape sequences
<BR>
as <TT>chars</TT> but ignore escape sequences
<BR>
as <TT>code</TT> but ignore escape sequences</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"> &#XA0;
<BR>
N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
&#XA0;
<BR>
<TT>unknown</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"> &#XA0;
<BR>
<U><TT>error</TT></U>
<BR>
<TT>warning</TT>
<BR>
<TT>fail</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"> a predicate calls an unknown procedure:
<BR>
an <TT>existence_error</TT> is raised
<BR>
a message is displayed then fails
<BR>
quietly fails</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"> &#XA0;
<BR>
Y</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
&#XA0;
<BR>
<TT>syntax_error</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"> &#XA0;
<BR>
<U><TT>error</TT></U>
<BR>
<TT>warning</TT>
<BR>
<TT>fail</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"> a predicate causes a syntax error:
<BR>
a <TT>syntax_error</TT> is raised
<BR>
a message is displayed then fails
<BR>
quietly fails</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"> &#XA0;
<BR>
N</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">
&#XA0;
<BR>
<TT>os_error</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"> &#XA0;
<BR>
<U><TT>error</TT></U>
<BR>
<TT>warning</TT>
<BR>
<TT>fail</TT></DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"> a predicate causes an O.S. error:
<BR>
a <TT>system_error</TT> is raised
<BR>
a message is displayed then fails
<BR>
quietly fails</DIV></TD><TD VALIGN=top ALIGN=left><DIV CLASS="center"> &#XA0;
<BR>
N</DIV></TD></TR>
</TABLE><P>The <TT>strict_iso</TT> flag is introduced to allow a compatibility with
other Prolog systems. When turned off the following relaxations apply:</P><UL CLASS="itemize"><LI CLASS="li-itemize">built-in predicates are found by <TT>current_predicate/1</TT>
(section&#XA0;<A HREF="#current-predicate/1">8.8.1</A>).</LI><LI CLASS="li-itemize">the term parser (<TT>read/1</TT> and friends) is more indulgent, e.g. <TT>0&#X2019;&#X2019;</TT> is
accepted and returns 39, the escape sequence <TT>\s</TT> (space) and
<TT>\e</TT> (escape) are accepted.</LI><LI CLASS="li-itemize">the following arithmetic rounding functions: <TT>ceiling</TT>, <TT>floor</TT>, <TT>round</TT>, <TT>truncate</TT> also accept integers (section&#XA0;<A HREF="#Evaluation-of-an-arithmetic-expression">8.6.1</A>).</LI></UL><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Flag</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Value</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Flag</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Flag)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Flag</TT> is an atom but not a valid flag</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(prolog_flag, Flag)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Value</TT> is inappropriate for Flag</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(flag_value, Flag+Value)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Value</TT> is appropriate for <TT>Flag</TT> but flag
<TT>Flag</TT> is not modifiable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(modify, flag, Flag)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate. All ISO flags are implemented.</P><!--TOC subsubsection <TT>current_prolog_flag/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc232">8.22.2</A>&#XA0;&#XA0;<TT>current_prolog_flag/2</TT></H4><!--SEC END --><P>
<A NAME="current-prolog-flag/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
current_prolog_flag(?flag, ?term)</TT></DD></DL><P><B>Description</B></P><P><TT>current_prolog_flag(Flag, Value)</TT>
succeeds if there exists a Prolog flag that unifies with
<TT>Flag</TT> and whose value unifies with <TT>Value</TT>. This predicate
is re-executable on backtracking.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Flag</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Flag)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Flag</TT> is an atom but not a valid flag</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(prolog_flag, Flag)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>ISO predicate.</P><!--TOC subsubsection <TT>set_bip_name/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc233">8.22.3</A>&#XA0;&#XA0;<TT>set_bip_name/2</TT></H4><!--SEC END --><P>
<A NAME="set-bip-name/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
set_bip_name(+atom, +arity)</TT></DD></DL><P><B>Description</B></P><P><TT>set_bip_name(Functor, Arity)</TT> initializes the context of the error
(section&#XA0;<A HREF="#General-format-and-error-context">6.3.1</A>) with <TT>Functor</TT> and
<TT>Arity</TT> (if <TT>Arity</TT> &lt; 0 only <TT>Functor</TT> is
significant).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Functor</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Arity</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Functor</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Functor)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Arity</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Arity)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>current_bip_name/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc234">8.22.4</A>&#XA0;&#XA0;<TT>current_bip_name/2</TT></H4><!--SEC END --><P>
<A NAME="current-bip-name/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
current_bip_name(?atom, ?arity)</TT></DD></DL><P><B>Description</B></P><P><TT>current_bip_name(Functor, Arity)</TT> succeeds if <TT>Functor</TT> and
<TT>Arity</TT> correspond to the context of the error (section&#XA0;<A HREF="#General-format-and-error-context">6.3.1</A>) (if <TT>Arity</TT> &lt; 0 only <TT>Functor</TT> is
significant).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Functor</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Functor)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Arity</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Arity)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>write_pl_state_file/1</TT>,
<TT>read_pl_state_file/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc235">8.22.5</A>&#XA0;&#XA0;<TT>write_pl_state_file/1</TT>,
<TT>read_pl_state_file/1</TT></H4><!--SEC END --><P>
<A NAME="write-pl-state-file/1"></A>

</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
write_pl_state_file(+source_sink)<BR>
read_pl_state_file(+source_sink)</TT></DD></DL><P><B>Description</B></P><P><TT>write_pl_state_file(FileName)</TT> writes onto <TT>FileName</TT> all
information that influences the parsing of a term (section&#XA0;<A HREF="#Term-input/output">8.14</A>). This allows a sub-process written in Prolog to read this
file and then process any Prolog term as done by the parent process. This
file can also be passed as argument of the <TT>--pl-state</TT> option when
invoking <TT>gplc</TT> (section&#XA0;<A HREF="#Using-the-compiler">4.4.3</A>). More precisely the
following elements are saved:</P><UL CLASS="itemize"><LI CLASS="li-itemize">all operator definitions (section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</LI><LI CLASS="li-itemize">the character conversion table (section&#XA0;<A HREF="#char-conversion/2">8.14.12</A>).</LI><LI CLASS="li-itemize">the value of <TT>char_conversion</TT>, <TT>double_quotes</TT>, <TT>back_quotes</TT>, <TT>singleton_warning</TT>, <TT>suspicious_warning</TT> and <TT>multifile_warning</TT> Prolog flags
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>).</LI></UL><P><TT>read_pl_state_file(FileName)</TT> reads (restores) from
<TT>FileName</TT> all information previously saved by
<TT>write_pl_state_file/1.</TT></P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>FileName</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>FileName</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, FileName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsection Program state-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc236">8.23</A>&#XA0;&#XA0;Program state</H3><!--SEC END --><!--TOC subsubsection <TT>consult/1</TT>,
<TT>&#X2019;.&#X2019;/2</TT> - program consult-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc237">8.23.1</A>&#XA0;&#XA0;<TT>consult/1</TT>,
<TT>&#X2019;.&#X2019;/2</TT> - program consult</H4><!--SEC END --><P>
<A NAME="consult/1"></A>

</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
consult(+atom_or_atom_list)<BR>
&#X2019;.&#X2019;(+atom, +atom_list)</TT></DD></DL><P><B>Description</B></P><P><TT>consult(Files)</TT> compiles and loads into memory each file
of the list <TT>Files</TT>. Each file is compiled for byte-code using the
GNU Prolog compiler (section&#XA0;<A HREF="#The-GNU-Prolog-compiler">4.4</A>) then loaded using
<TT>load/1</TT> (section&#XA0;<A HREF="#load/1">8.23.2</A>). It is possible to specify <TT>user</TT> as a
file name to directly enter the program from the terminal. <TT>Files</TT> can
be also a single file name (i.e. an atom). Refer to the section concerning
the consult of a Prolog program for more information
(section&#XA0;<A HREF="#Consulting-a-Prolog-program">4.2.3</A>).</P><P>The final file name of a file is computed using the predicates
<TT>prolog_file_name/2</TT> (section&#XA0;<A HREF="#prolog-file-name/2">8.26.3</A>) and
<TT>absolute_file_name/2</TT> (section&#XA0;<A HREF="#absolute-file-name/2">8.26.1</A>).</P><P><TT>[ File | Files ]</TT>, i.e. <TT>&#X2019;.&#X2019;(File, Files)</TT> is
equivalent to <TT>consult([ File | Files ])</TT>.</P><P>Since version 1.4.0, with the introduction of shebang support,
<TT>consult/1</TT> ignores the first line of a Prolog source file which
directly begins with <TT>#</TT>. See
(section&#XA0;<A HREF="#Scripting-Prolog">4.2.4</A>) for more information about
shebang support and PrologScript.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Files</TT> is a partial list or a list with an element
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Files</TT> is neither a partial list nor a list nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Files)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Files</TT> list is neither a
variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Files</TT> list is an atom but not
a valid pathname</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(os_path, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Files</TT> list is a valid
pathname but does not correspond to an existing source</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(source_sink, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an error occurs executing a directive</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left>see <TT>call/1</TT> errors (section&#XA0;<A HREF="#call/1">7.2.3</A>)</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>load/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc238">8.23.2</A>&#XA0;&#XA0;<TT>load/1</TT></H4><!--SEC END --><P>
<A NAME="load/1"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
load(+atom_or_atom_list)</TT></DD></DL><P><B>Description</B></P><P><TT>load(Files)</TT> loads into memory each file of the list
<TT>Files</TT>. Each file must have been previously compiled for byte-code
using the GNU Prolog compiler (section&#XA0;<A HREF="#The-GNU-Prolog-compiler">4.4</A>).
<TT>Files</TT> can be also a single file name (i.e. an atom).</P><P>The final file name of a file is computed using the predicates
<TT>absolute_file_name/2</TT> (section&#XA0;<A HREF="#absolute-file-name/2">8.26.1</A>). If no
suffix is given <TT>&#X2019;.wbc&#X2019;</TT> is appended to the file name.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Files</TT> is a partial list or a list with an element
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Files</TT> is neither a partial list nor a list nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Files)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Files</TT> list is neither a
variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Files</TT> list is an atom but not
a valid pathname</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(os_path, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Files</TT> list is a valid
pathname but does not correspond to an existing source</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(source_sink, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an error occurs executing a directive</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left>see <TT>call/1</TT> errors (section&#XA0;<A HREF="#call/1">7.2.3</A>)</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>listing/1</TT>,
<TT>listing/0</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc239">8.23.3</A>&#XA0;&#XA0;<TT>listing/1</TT>,
<TT>listing/0</TT></H4><!--SEC END --><P>
<A NAME="listing/1"></A>

</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
listing(+predicate_indicator)<BR>
listing(+atom)<BR>
listing</TT></DD></DL><P><B>Description</B></P><P><TT>listing(Pred)</TT> lists the clauses of the consulted predicate whose
predicate indicator is <TT>Pred</TT>. <TT>Pred</TT> can also be a single
atom in which case all predicates whose name is <TT>Pred</TT> are listed (of
any arity). This predicate uses <TT>portray_clause/2</TT>
(section&#XA0;<A HREF="#portray-clause/2">8.14.8</A>) to output the clauses.</P><P><TT>listing</TT> lists all clauses of all consulted predicates.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pred</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pred</TT> is neither a variable nor predicate indicator or an
atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(predicate_indicator, Pred)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsection System statistics-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc240">8.24</A>&#XA0;&#XA0;System statistics</H3><!--SEC END --><!--TOC subsubsection <TT>statistics/0</TT>,
<TT>statistics/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc241">8.24.1</A>&#XA0;&#XA0;<TT>statistics/0</TT>,
<TT>statistics/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
statistics<BR>
statistics(?atom, ?list)</TT></DD></DL><P><B>Description</B></P><P><TT>statistics</TT> displays statistics about memory usage and run times.</P><P><TT>statistics(Key, Value)</TT> unifies <TT>Value</TT> with the current
value of the statistics key <TT>Key</TT>. <TT>Value</TT> a list of two
elements. Times are in milliseconds, sizes of areas in bytes.</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP>
Key</TD><TD ALIGN=left NOWRAP>Description</TD><TD ALIGN=left NOWRAP>Value</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>user_time</TT></TD><TD ALIGN=left NOWRAP>user CPU time</TD><TD ALIGN=left NOWRAP><TT>[SinceStart, SinceLast]</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>system_time</TT></TD><TD ALIGN=left NOWRAP>system CPU time</TD><TD ALIGN=left NOWRAP><TT>[SinceStart, SinceLast]</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>cpu_time</TT></TD><TD ALIGN=left NOWRAP>total CPU time (user + system)</TD><TD ALIGN=left NOWRAP><TT>[SinceStart,
SinceLast]</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>real_time</TT></TD><TD ALIGN=left NOWRAP>absolute time</TD><TD ALIGN=left NOWRAP><TT>[SinceStart, SinceLast]</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>local_stack</TT></TD><TD ALIGN=left NOWRAP>local stack sizes (control, environments, choices)</TD><TD ALIGN=left NOWRAP><TT>[UsedSize, FreeSize]</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>global_stack</TT></TD><TD ALIGN=left NOWRAP>global stack sizes (compound terms)</TD><TD ALIGN=left NOWRAP><TT>[UsedSize, FreeSize]</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>trail_stack</TT></TD><TD ALIGN=left NOWRAP>trail stack sizes (variable bindings to undo)</TD><TD ALIGN=left NOWRAP><TT>[UsedSize, FreeSize]</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>cstr_stack</TT></TD><TD ALIGN=left NOWRAP>constraint trail sizes (finite domain constraints)</TD><TD ALIGN=left NOWRAP><TT>[UsedSize, FreeSize]</TT></TD></TR>
</TABLE><P>Note that the key <TT>runtime</TT> is recognized as <TT>user_time</TT> for
compatibility purpose.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Key</TT> is neither a variable nor a valid key</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(statistics_key, Key)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Value</TT> is neither a variable nor a list of two elements</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(statistics_value, Value)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Value</TT> is a list of two elements and an element <TT>E</TT>
is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>user_time/1</TT>,
<TT>system_time/1</TT>,
<TT>cpu_time/1</TT>,
<TT>real_time/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc242">8.24.2</A>&#XA0;&#XA0;<TT>user_time/1</TT>,
<TT>system_time/1</TT>,
<TT>cpu_time/1</TT>,
<TT>real_time/1</TT></H4><!--SEC END --><P>
<A NAME="user-time/1"></A>



</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
user_time(?integer)<BR>
system_time(?integer)<BR>
cpu_time(?integer)<BR>
real_time(?integer)</TT></DD></DL><P><B>Description</B></P><P><TT>user_time(Time)</TT> unifies <TT>Time</TT> with the user
CPU time elapsed since the start of Prolog.</P><P><TT>system_time(Time)</TT> unifies <TT>Time</TT> with the
system CPU time elapsed since the start of Prolog.</P><P><TT>cpu_time(Time)</TT> unifies <TT>Time</TT> with the CPU
time (user + system) elapsed since the start of Prolog.</P><P><TT>real_time(Time)</TT> unifies <TT>Time</TT> with the
absolute time elapsed since the start of Prolog.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Time</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Time)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsection Random number generator-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc243">8.25</A>&#XA0;&#XA0;Random number generator</H3><!--SEC END --><!--TOC subsubsection <TT>set_seed/1</TT>,
<TT>randomize/0</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc244">8.25.1</A>&#XA0;&#XA0;<TT>set_seed/1</TT>,
<TT>randomize/0</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
set_seed(+integer)<BR>
randomize</TT></DD></DL><P><B>Description</B></P><P><TT>set_seed(Seed)</TT> reinitializes the random number generator seed with
<TT>Seed</TT>.</P><P><TT>randomize</TT> reinitializes the random number generator. This
predicates calls <TT>set_seed/1</TT> with a random value depending on the
absolute time.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Seed</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Seed</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Seed)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Seed</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, Seed)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>get_seed/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc245">8.25.2</A>&#XA0;&#XA0;<TT>get_seed/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
get_seed(?integer)</TT></DD></DL><P><B>Description</B></P><P><TT>get_seed(Seed)</TT> unifies <TT>Seed</TT> with the current random
number generator seed.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Seed</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Seed)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Seed</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, Seed)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>random/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc246">8.25.3</A>&#XA0;&#XA0;<TT>random/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
random(-float)</TT></DD></DL><P><B>Description</B></P><P><TT>random(Number)</TT> unifies <TT>Number</TT> with a random floating point
number such that 0.0 &#X2264; <TT>Number</TT> &lt; 1.0.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Number</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(variable, Number)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>random/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc247">8.25.4</A>&#XA0;&#XA0;<TT>random/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
random(+number, +number, -number)</TT></DD></DL><P><B>Description</B></P><P><TT>random(Base, Max, Number)</TT> unifies <TT>Number</TT> with a random
number such that <TT>Base</TT> &#X2264; <TT>Number</TT> &lt; <TT>Max</TT>. If
both <TT>Base</TT> and <TT>Max</TT> are integers <TT>Number</TT> will be an
integer, otherwise <TT>Number</TT> will be a floating point number.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Base</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Base</TT> is neither a variable nor a number</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(number, Base)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Max</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Max</TT> is neither a variable nor a number</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(number, Max)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Number</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(variable, Number)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsection File name processing-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc248">8.26</A>&#XA0;&#XA0;File name processing</H3><!--SEC END --><!--TOC subsubsection <TT>absolute_file_name/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc249">8.26.1</A>&#XA0;&#XA0;<TT>absolute_file_name/2</TT></H4><!--SEC END --><P>
<A NAME="absolute-file-name/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
absolute_file_name(+atom, atom)</TT></DD></DL><P><B>Description</B></P><P><TT>absolute_file_name(File1, File2)</TT> succeeds if <TT>File2</TT> is
the absolute pathname associated with the relative file name <TT>File1</TT>.
<TT>File1</TT> can contain <TT>$<I>VAR_NAME</I></TT> sub-strings. When
such a sub-string is encountered, it is expanded with the value of the
environment variable whose name is <I><TT>VAR_NAME</TT></I> if exists
(otherwise no expansion is done). <TT>File1</TT> can also begin with a
sub-string <TT>~<I>USER_NAME</I>/</TT>, this is expanded as the home
directory of the user <I><TT>USER_NAME</TT></I>. If
<I><TT>USER_NAME</TT></I> does not exist <TT>File1</TT> is an invalid
pathname. If no <I><TT>USER_NAME</TT></I> is given (i.e. <TT>File1</TT>
begins with <TT>~/</TT>) the <TT>~</TT> character is expanded as the
value of the environment variable <TT>HOME</TT>. If the <TT>HOME</TT>
variable is not defined <TT>File1</TT> is an invalid pathname. Relative
references to the current directory (<TT>/./</TT> sub-string) and to the
parent directory (<TT>/../</TT> sub-strings) are removed and no longer
appear in <TT>File2</TT>. <TT>File1</TT> is also invalid if it contains too
many <TT>/../</TT> consecutive sub-strings (i.e. parent directory relative
references). Finally if <TT>File1</TT> is <TT>user</TT> then <TT>File2</TT>
is also unified with <TT>user</TT> to allow this predicate to be called on
Prolog file names (since <TT>user</TT> in DEC-10 input/output predicates
denotes the current input/output stream).</P><P>Under Windows the following applies: 
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
an alternate recognized form for <TT>$<I>VAR_NAME</I></TT> is
<TT>%<I>VAR_NAME</I>%</TT>. </LI><LI CLASS="li-itemize">when <TT>~</TT> is expanded, if the <TT>HOME</TT> variable is not defined, <TT>~</TT> is expanded using <TT>HOMEDIR</TT> and
<TT>HOMEPATH</TT> (if <TT>HOMEPATH</TT> is not defined then <TT>File1</TT>
is an invalid pathname).
</LI></UL><P>Most predicates using a file name implicitly call this predicate to obtain
the desired file, e.g. <TT>open/4</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>File1</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>File1</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, File1)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>File2</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, File2)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>File1</TT> is an atom but not a valid pathname</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(os_path, File1)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>decompose_file_name/4</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc250">8.26.2</A>&#XA0;&#XA0;<TT>decompose_file_name/4</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
decompose_file_name(+atom, ?atom, ?atom, ?atom)</TT></DD></DL><P><B>Description</B></P><P><TT>decompose_file_name(File, Directory, Prefix, Suffix)</TT> decomposes
the pathname <TT>File</TT> and extracts the <TT>Directory</TT> part
(characters before the last <TT>/</TT>), the <TT>Prefix</TT> part
(characters after the last <TT>/</TT> and before the last <TT>.</TT> or
until the end if there is no suffix) and the <TT>Suffix</TT> part
(characters from the last <TT>.</TT> to the end of the string).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>File</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>File</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, File)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Directory</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Directory)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Prefix</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Prefix)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Suffix</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Suffix)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>prolog_file_name/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc251">8.26.3</A>&#XA0;&#XA0;<TT>prolog_file_name/2</TT></H4><!--SEC END --><P>
<A NAME="prolog-file-name/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
prolog_file_name(+atom, ?atom)</TT></DD></DL><P><B>Description</B></P><P><TT>prolog_file_name(File1, File2)</TT> unifies <TT>File2</TT> with the
Prolog file name associated with <TT>File1</TT>. More precisely <TT>File2</TT>
is computed as follows:</P><UL CLASS="itemize"><LI CLASS="li-itemize">if <TT>File1</TT> has a suffix or if it is <TT>user</TT> then
<TT>File2</TT> is unified with <TT>File1</TT>.</LI><LI CLASS="li-itemize">else if the file whose name is <TT>File1</TT> + <TT>&#X2019;.pl&#X2019;</TT> exists
then <TT>File2</TT> is unified with this name.</LI><LI CLASS="li-itemize">else if the file whose name is <TT>File1</TT> + <TT>&#X2019;.pro&#X2019;</TT> exists
then <TT>File2</TT> is unified with this name.</LI><LI CLASS="li-itemize">else <TT>File2</TT> is unified with the name <TT>File1</TT> +
<TT>&#X2019;.pl&#X2019;</TT>.</LI></UL><P>This predicate uses <TT>absolute_file_name/2</TT> to check the existence
of a file (section&#XA0;<A HREF="#absolute-file-name/2">8.26.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>File1</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>File1</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, File1)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>File2</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, File2)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>File1</TT> is an atom but not a valid pathname</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(os_path, File1)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsection Operating system interface-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc252">8.27</A>&#XA0;&#XA0;Operating system interface</H3><!--SEC END --><!--TOC subsubsection <TT>argument_counter/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc253">8.27.1</A>&#XA0;&#XA0;<TT>argument_counter/1</TT></H4><!--SEC END --><P>
<A NAME="argument-counter/1"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
argument_counter(?integer)</TT></DD></DL><P><B>Description</B></P><P><TT>argument_counter(Counter)</TT> succeeds if <TT>Counter</TT> is the
number of arguments of the command-line. Since the first argument is always
the name of the running program, <TT>Counter</TT> is always &#X2265; 1. See
(section&#XA0;<A HREF="#The-GNU-Prolog-interactive-interpreter">4.2</A>) for more information about
command-line arguments retrieved under the top_level.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Counter</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Counter)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>argument_value/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc254">8.27.2</A>&#XA0;&#XA0;<TT>argument_value/2</TT></H4><!--SEC END --><P>
<A NAME="argument-value/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
argument_value(+integer, ?atom)</TT></DD></DL><P><B>Description</B></P><P><TT>argument_value(N, Arg)</TT> succeeds if the <TT>N</TT><EM>th</EM>
argument on the command-line unifies with <TT>Arg</TT>. The first argument
is always the name of the running program and its number is 0. The number of
arguments on the command-line can be obtained using
<TT>argument_counter/1</TT> (section&#XA0;<A HREF="#argument-counter/1">8.27.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>N</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>N</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, N)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>N</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, N)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Arg</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Arg)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>argument_list/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc255">8.27.3</A>&#XA0;&#XA0;<TT>argument_list/1</TT></H4><!--SEC END --><P>
<A NAME="argument-list/1"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
argument_list(?list)</TT></DD></DL><P><B>Description</B></P><P><TT>argument_list(Args)</TT> succeeds if <TT>Args</TT> unifies with the
list of atoms associated with each argument on the command-line other than the
first argument (the name of the running program).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Args</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Args)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>environ/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc256">8.27.4</A>&#XA0;&#XA0;<TT>environ/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
environ(?atom, ?atom)</TT></DD></DL><P><B>Description</B></P><P><TT>environ(Name, Value)</TT> succeeds if <TT>Name</TT> is the name of an
environment variable whose value is <TT>Value</TT>. This predicate is
re-executable on backtracking.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Name</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Name)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Value</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Value)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>make_directory/1</TT>,
<TT>delete_directory/1</TT>,
<TT>change_directory/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc257">8.27.5</A>&#XA0;&#XA0;<TT>make_directory/1</TT>,
<TT>delete_directory/1</TT>,
<TT>change_directory/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
make_directory(+atom)<BR>
delete_directory(+atom)<BR>
change_directory(+atom)</TT></DD></DL><P><B>Description</B></P><P><TT>make_directory(PathName)</TT> creates the directory whose pathname is
<TT>PathName</TT>.</P><P><TT>delete_directory(PathName)</TT> removes the directory whose pathname is
<TT>PathName</TT>.</P><P><TT>change_directory(PathName)</TT> sets the current directory to the
directory whose pathname is <TT>PathName</TT>.</P><P>See <TT>absolute_file_name/2</TT> for information about the syntax of
<TT>PathName</TT> (section&#XA0;<A HREF="#absolute-file-name/2">8.26.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, PathName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is an atom but not a valid pathname</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(os_path, PathName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>working_directory/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc258">8.27.6</A>&#XA0;&#XA0;<TT>working_directory/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
working_directory(?atom)</TT></DD></DL><P><B>Description</B></P><P><TT>working_directory(PathName)</TT> succeeds if <TT>PathName</TT> is the
pathname of the current directory.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, PathName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>directory_files/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc259">8.27.7</A>&#XA0;&#XA0;<TT>directory_files/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
directory_files(+atom, ?list)</TT></DD></DL><P><B>Description</B></P><P><TT>directory_files(PathName, Files)</TT> succeeds if <TT>Files</TT> is the
list of all entries (files, sub-directories,&#X2026;) in the directory whose
pathname is <TT>PathName</TT>. See <TT>absolute_file_name/2</TT> for
information about the syntax of <TT>PathName</TT>
(section&#XA0;<A HREF="#absolute-file-name/2">8.26.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, PathName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is an atom but not a valid pathname</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(os_path, PathName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Files</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Files)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>rename_file/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc260">8.27.8</A>&#XA0;&#XA0;<TT>rename_file/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
rename_file(+atom, +atom)</TT></DD></DL><P><B>Description</B></P><P><TT>rename_file(PathName1, PathName2)</TT> renames the file or directory
whose pathname is <TT>PathName1</TT> to <TT>PathName2</TT>. See
<TT>absolute_file_name/2</TT> for information about the syntax of
<TT>PathName1</TT> and <TT>PathName2</TT> (section&#XA0;<A HREF="#absolute-file-name/2">8.26.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName1</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName1</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, PathName1)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName1</TT> is an atom but not a valid pathname</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(os_path, PathName1)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName2</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName2</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, PathName2)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName2</TT> is an atom but not a valid pathname</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(os_path, PathName2)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>delete_file/1</TT>,
<TT>unlink/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc261">8.27.9</A>&#XA0;&#XA0;<TT>delete_file/1</TT>,
<TT>unlink/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
delete_file(PathName)<BR>
unlink(PathName)</TT></DD></DL><P><B>Description</B></P><P><TT>delete_file(PathName)</TT> removes the existing file whose pathname is
<TT>PathName</TT>.</P><P><TT>unlink/1</TT> is similar to <TT>delete_file/1</TT> except that it never
causes a <TT>system_error</TT> (e.g. if <TT>PathName</TT> does not refer to
an existing file).</P><P>See <TT>absolute_file_name/2</TT> for information about the syntax of
<TT>PathName</TT> (section&#XA0;<A HREF="#absolute-file-name/2">8.26.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, PathName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is an atom but not a valid pathname</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(os_path, PathName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>file_permission/2</TT>,
<TT>file_exists/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc262">8.27.10</A>&#XA0;&#XA0;<TT>file_permission/2</TT>,
<TT>file_exists/1</TT></H4><!--SEC END --><P>
<A NAME="file-permission/2"></A>

</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
file_permission(+atom, +atom)<BR>
file_permission(+atom, +atom_list)<BR>
file_exists(+atom)</TT></DD></DL><P><B>Description</B></P><P><TT>file_permission(PathName, Permission)</TT> succeeds if
<TT>PathName</TT> is the pathname of an existing file (or directory) whose
permissions include <TT>Permission</TT>.</P><P><B>File permissions</B>: <TT>Permission</TT> can be a single permission or
a list of permissions. A permission is an atom among:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>read</TT>: the file or directory can be read.</LI><LI CLASS="li-itemize"><TT>write</TT>: the file or directory can be written.</LI><LI CLASS="li-itemize"><TT>execute</TT>: the file can be executed.</LI><LI CLASS="li-itemize"><TT>search</TT>: the directory can be searched.</LI></UL><P>If <TT>PathName</TT> does not exists or if its permissions do not include
<TT>Permission</TT> this predicate fails.</P><P><TT>file_exists(PathName)</TT> is equivalent to
<TT>file_permission(PathName, [])</TT>, i.e. it succeeds if
<TT>PathName</TT> is the pathname of an existing file (or directory).</P><P>See <TT>absolute_file_name/2</TT> for information about the syntax of
<TT>PathName</TT> (section&#XA0;<A HREF="#absolute-file-name/2">8.26.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, PathName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is an atom but not a valid pathname</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(os_path, PathName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Permission</TT> is a partial list or a list with an element
which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Permission</TT> is neither an atom nor partial list or a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Permission)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Permission</TT> list is neither a
variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Permission</TT> is an atom but not
a valid permission</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(os_file_permission, Permission)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>file_property/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc263">8.27.11</A>&#XA0;&#XA0;<TT>file_property/2</TT></H4><!--SEC END --><P>
<A NAME="file-property/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
file_property(+atom, ?os_file_property)</TT></DD></DL><P><B>Description</B></P><P><TT>file_property(PathName, Property)</TT> succeeds if <TT>PathName</TT> is
the pathname of an existing file (or directory) and if <TT>Property</TT>
unifies with one of the properties of the file. This predicate is
re-executable on backtracking.</P><P><B>File properties</B>:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>absolute_file_name(File)</TT>:
<TT>File</TT> is the absolute file name of <TT>PathName</TT>
(section&#XA0;<A HREF="#absolute-file-name/2">8.26.1</A>).</LI><LI CLASS="li-itemize"><TT>real_file_name(File)</TT>: <TT>File</TT> is
the real file name of <TT>PathName</TT> (follows symbolic links).</LI><LI CLASS="li-itemize"><TT>type(Type)</TT>: <TT>Type</TT> is the type of
<TT>PathName</TT>. Possible values are: <TT>regular</TT>,
<TT>directory</TT>, <TT>fifo</TT>, <TT>socket</TT>,
<TT>character_device</TT>, <TT>block_device</TT> or <TT>unknown</TT>.</LI><LI CLASS="li-itemize"><TT>size(Size)</TT>: <TT>Size</TT> is the size (in bytes) of
<TT>PathName</TT>.</LI><LI CLASS="li-itemize"><TT>permission(Permission)</TT>: <TT>Permission</TT> is a
permission of <TT>PathName</TT> (section&#XA0;<A HREF="#file-permission/2">8.27.10</A>).</LI><LI CLASS="li-itemize"><TT>last_modification(DT)</TT>: <TT>DT</TT> is
the last modification date and time (section&#XA0;<A HREF="#date-time/1">8.27.14</A>).</LI></UL><P>See <TT>absolute_file_name/2</TT> for information about the syntax of
<TT>PathName</TT> (section&#XA0;<A HREF="#absolute-file-name/2">8.26.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, PathName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is an atom but not a valid pathname</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(os_path, PathName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Property</TT> is neither a variable nor a file property term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(os_file_property, Property)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Property</TT> = <TT>absolute_file_name(E)</TT>,
<TT>real_file_name(E)</TT>, <TT>type(E)</TT> or <TT>permission(E)</TT> and
<TT>E</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Property</TT> = <TT>last_modification(DateTime)</TT> and
<TT>DateTime</TT> is neither a variable nor a compound term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(compound, DateTime)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Property</TT> = <TT>last_modification(DateTime)</TT> and
<TT>DateTime</TT> is a compound term but not a structure <TT>dt/6</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(date_time, DateTime)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Property</TT> = <TT>size(E)</TT> or
<TT>last_modification(DateTime)</TT> and <TT>DateTime</TT> is a structure
<TT>dt/6</TT> but an element <TT>E</TT> is neither a variable nor an
integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>temporary_name/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc264">8.27.12</A>&#XA0;&#XA0;<TT>temporary_name/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
temporary_name(+atom, ?atom)</TT></DD></DL><P><B>Description</B></P><P><TT>temporary_name(Template, PathName)</TT> creates a unique file name
<TT>PathName</TT> whose pathname begins by <TT>Template</TT>.
<TT>Template</TT> should contain a pathname with six trailing
<TT>X</TT><EM>s</EM>. <TT>PathName</TT> is <TT>Template</TT> with the six
<TT>X</TT><EM>s</EM> replaced with a letter and the process identifier. This
predicate is an interface to the C Unix function <TT>mktemp(3)</TT>.</P><P>See <TT>absolute_file_name/2</TT> for information about the syntax of
<TT>Template</TT> (section&#XA0;<A HREF="#absolute-file-name/2">8.26.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Template</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Template</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Template)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Template</TT> is an atom but not a valid pathname</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(os_path, Template)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, PathName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>temporary_file/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc265">8.27.13</A>&#XA0;&#XA0;<TT>temporary_file/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
temporary_file(+atom, +atom, ?atom)</TT></DD></DL><P><B>Description</B></P><P><TT>temporary_file(Directory, Prefix, PathName)</TT> creates a unique file
name <TT>PathName</TT> whose pathname begins by <TT>Directory/Prefix</TT>.
If <TT>Directory</TT> is the empty atom <TT>&#X2019;&#X2019;</TT> a standard temporary
directory will be used (e.g. <TT>/tmp</TT>). <TT>Prefix</TT> can be the
empty atom <TT>&#X2019;&#X2019;</TT>. This predicate is an interface to the C Unix
function <TT>tempnam(3)</TT>.</P><P>See <TT>absolute_file_name/2</TT> for information about the syntax of
<TT>Directory</TT> (section&#XA0;<A HREF="#absolute-file-name/2">8.26.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Directory</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Directory</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Directory)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Directory</TT> is an atom but not a valid pathname</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(os_path, Directory)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Prefix</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Prefix</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Prefix)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>PathName</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, PathName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>date_time/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc266">8.27.14</A>&#XA0;&#XA0;<TT>date_time/1</TT></H4><!--SEC END --><P>
<A NAME="date-time/1"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
date_time(?compound)</TT></DD></DL><P><B>Description</B></P><P><TT>date_time(DateTime)</TT> unifies <TT>DateTime</TT> with a compound term
containing the current date and time. <TT>DateTime</TT> is a structure
<TT>dt(Year, Month, Day, Hour, Minute, Second)</TT>. Each sub-argument of
the term <TT>dt/6</TT> is an integer.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>DateTime</TT> is neither a variable nor a compound term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(compound, DateTime)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>DateTime</TT> is a compound term but not a structure
<TT>dt/6</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(date_time, DateTime)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>DateTime</TT> is a structure <TT>dt/6</TT> and an element
<TT>E</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>host_name/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc267">8.27.15</A>&#XA0;&#XA0;<TT>host_name/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
host_name(?atom)</TT></DD></DL><P><B>Description</B></P><P><TT>host_name(HostName)</TT> unifies <TT>HostName</TT> with the name of the
host machine executing the current GNU Prolog process. If the sockets are
available (section&#XA0;<A HREF="#Introduction:(Sockets-input/output)">8.28.1</A>), the name returned
will be fully qualified. In that case, <TT>host_name/1</TT> will also
succeed if <TT>HostName</TT> is instantiated to the unqualified name (or an
alias) of the machine.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>HostName</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, HostName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>os_version/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc268">8.27.16</A>&#XA0;&#XA0;<TT>os_version/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
os_version(?atom)</TT></DD></DL><P><B>Description</B></P><P><TT>os_version(OSVersion)</TT> unifies <TT>OSVersion</TT> with the
operating system version of the machine executing the current GNU Prolog
process.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>OSVersion</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, OSVersion)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>architecture/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc269">8.27.17</A>&#XA0;&#XA0;<TT>architecture/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
architecture(?atom)</TT></DD></DL><P><B>Description</B></P><P><TT>architecture(Architecture)</TT> unifies <TT>Architecture</TT> with the
name of the machine executing the current GNU Prolog process.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Architecture</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Architecture)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>shell/2</TT>,
<TT>shell/1</TT>,
<TT>shell/0</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc270">8.27.18</A>&#XA0;&#XA0;<TT>shell/2</TT>,
<TT>shell/1</TT>,
<TT>shell/0</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
shell(+atom, ?integer)<BR>
shell(+atom)<BR>
shell</TT></DD></DL><P><B>Description</B></P><P><TT>shell(Command, Status)</TT> invokes a new shell (named by the
<TT>SHELL</TT> environment variable) passing <TT>Command</TT> for execution
and unifies <TT>Status</TT> with the result of the execution. If
<TT>Command</TT> is the empty atom <TT>&#X2019;&#X2019;</TT> a new interactive shell is
executed. The control is returned to Prolog upon termination of the called
process.</P><P><TT>shell(Command)</TT> is equivalent to <TT>shell(Command, 0)</TT>.</P><P><TT>shell</TT> is equivalent to <TT>shell(&#X2019;&#X2019;, 0)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Command</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Command</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Command)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Status</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Status)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>system/2</TT>,
<TT>system/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc271">8.27.19</A>&#XA0;&#XA0;<TT>system/2</TT>,
<TT>system/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
system(+atom, ?integer)<BR>
system(+atom)</TT></DD></DL><P><B>Description</B></P><P><TT>system(Command, Status)</TT> invokes a new default shell passing
<TT>Command</TT> for execution and unifies <TT>Status</TT> with the result
of the execution. The control is returned to Prolog upon termination of the
shell process. This predicate is an interface to the C Unix function
<TT>system(3)</TT>.</P><P><TT>system(Command)</TT> is equivalent to <TT>system(Command, 0)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Command</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Command</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Command)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Status</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Status)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>spawn/3</TT>,
<TT>spawn/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc272">8.27.20</A>&#XA0;&#XA0;<TT>spawn/3</TT>,
<TT>spawn/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
spawn(+atom, +atom_list, ?integer)<BR>
spawn(+atom, +atom_list)</TT></DD></DL><P><B>Description</B></P><P><TT>spawn(Command, Arguments, Status)</TT> executes <TT>Command</TT> passing
as arguments of the command-line each element of the list <TT>Arguments</TT>
and unifies <TT>Status</TT> with the result of the execution. The control is
returned to Prolog upon termination of the command.</P><P><TT>spawn(Command, Arguments)</TT> is equivalent to <TT>spawn(Command,
Arguments, 0)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Command</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Command</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Command)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Arguments</TT> is a partial list or a list with an element
which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Arguments</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Arguments)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Arguments</TT> list is neither a
variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Status</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Status)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>popen/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc273">8.27.21</A>&#XA0;&#XA0;<TT>popen/3</TT></H4><!--SEC END --><P>
<A NAME="popen/3"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
popen(+atom, +io_mode, -stream)</TT></DD></DL><P><B>Description</B></P><P><TT>popen(Command, Mode, Stream)</TT> invokes a new default shell (by
creating a pipe) passing <TT>Command</TT> for execution and associates a
stream either to the standard input or the standard output of the created
process. if <TT>Mode</TT> is <TT>read</TT> (resp. <TT>write</TT>) an input
(resp. output) stream is created and <TT>Stream</TT> is unified with the
stream-term associated. Writing to the stream writes to the standard input
of the command while reading from the stream reads the command&#X2019;s standard
output. The stream must be closed using <TT>close/2</TT> (section&#XA0;<A HREF="#close/2">8.10.7</A>).
This predicate is an interface to the C Unix function <TT>popen(3)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Command</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Command</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Command)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Mode</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Mode</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Mode)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Mode</TT> is an atom but neither <TT>read</TT> nor
<TT>write</TT>.</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(io_mode, Mode)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Stream</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(variable, Stream)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>exec/5</TT>,
<TT>exec/4</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc274">8.27.22</A>&#XA0;&#XA0;<TT>exec/5</TT>,
<TT>exec/4</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
exec(+atom, -stream, -stream, -stream, -integer)<BR>
exec(+atom, -stream, -stream, -stream)</TT></DD></DL><P><B>Description</B></P><P><TT>exec(Command, StreamIn, StreamOut, StreamErr, Pid)</TT> invokes a new
default shell passing <TT>Command</TT> for execution and associates streams
to standard streams of the created process. <TT>StreamIn</TT> is unified
with the stream-term associated with the standard input stream of
<TT>Command</TT> (it is an output stream). <TT>StreamOut</TT> is unified
with the stream-term associated with the standard output stream of
<TT>Command</TT> (it is an input stream). <TT>StreamErr</TT> is unified with
the stream-term associated with the standard error stream of <TT>Command</TT>
(it is an input stream). <TT>Pid</TT> is unified with the process identifier
of the new process. This information is only useful if it is necessary to
obtain the status of the execution using <TT>wait/2</TT> (section&#XA0;<A HREF="#wait/2">8.27.25</A>).
Until a call to <TT>wait/2</TT> is done the process remains in the system
processes table (as a zombie process if terminated). For this reason, if the
status is not needed it is preferable to use <TT>exec/4</TT>.</P><P><TT>exec/4</TT> is similar to <TT>exec/5</TT> but the process is removed
from system processes as soon as it is terminated.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Command</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Command</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Command)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>StreamIn</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>uninstantiation_error(StreamIn)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>StreamOut</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>uninstantiation_error(StreamOut)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>StreamErr</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>uninstantiation_error(StreamErr)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pid</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>uninstantiation_error(Pid)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>fork_prolog/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc275">8.27.23</A>&#XA0;&#XA0;<TT>fork_prolog/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fork_prolog(-integer)</TT></DD></DL><P><B>Description</B></P><P><TT>fork_prolog(Pid)</TT> creates a child process that differs from the parent
process only in its PID. In the parent process <TT>Pid</TT> is unified with
the PID of the child while in the child process <TT>Pid</TT> is unified with
0. In the parent process, the status of the child process can be obtained
using <TT>wait/2</TT> (section&#XA0;<A HREF="#wait/2">8.27.25</A>). Until a call to <TT>wait/2</TT> is done
the child process remains in the system processes table (as a zombie process
if terminated). This predicate is an interface to the C Unix function
<TT>fork(2)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pid</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>uninstantiation_error(Pid)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>create_pipe/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc276">8.27.24</A>&#XA0;&#XA0;<TT>create_pipe/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
create_pipe(-stream, -stream)</TT></DD></DL><P><B>Description</B></P><P><TT>create_pipe(StreamIn, StreamOut)</TT> creates a pair of streams
pointing to a pipe inode. <TT>StreamIn</TT> is unified with the stream-term
associated with the input side of the pipe and <TT>StreamOut</TT> is unified
with the stream-term associated with output side. This predicate is an
interface to the C Unix function <TT>pipe(2)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>StreamIn</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>uninstantiation_error(StreamIn)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>StreamOut</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>uninstantiation_error(StreamOut)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>wait/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc277">8.27.25</A>&#XA0;&#XA0;<TT>wait/2</TT></H4><!--SEC END --><P>
<A NAME="wait/2"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
wait(+integer, ?integer)</TT></DD></DL><P><B>Description</B></P><P><TT>wait(Pid, Status)</TT> waits for the child process whose identifier is
<TT>Pid</TT> to terminate. <TT>Status</TT> is then unified with the exit
status. This predicate is an interface to the C Unix function
<TT>waitpid(2)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pid</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pid</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Pid)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Status</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Status)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>prolog_pid/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc278">8.27.26</A>&#XA0;&#XA0;<TT>prolog_pid/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
prolog_pid(?integer)</TT></DD></DL><P><B>Description</B></P><P><TT>prolog_pid(Pid)</TT> unifies <TT>Pid</TT> with the process identifier
of the current GNU Prolog process.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pid</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Pid)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>send_signal/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc279">8.27.27</A>&#XA0;&#XA0;<TT>send_signal/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
send_signal(+integer, +integer)<BR>
send_signal(+integer, +atom)</TT></DD></DL><P><B>Description</B></P><P><TT>send_signal(Pid, Signal)</TT> sends <TT>Signal</TT> to the process whose
identifier is <TT>Pid.</TT> <TT>Signal</TT> can be specified directly as an
integer or symbolically as an atom. Allowed atoms depend on the machine (e.g.
<TT>&#X2019;SIGINT&#X2019;</TT>, <TT>&#X2019;SIGQUIT&#X2019;</TT>, <TT>&#X2019;SIGKILL&#X2019;</TT>,
<TT>&#X2019;SIGUSR1&#X2019;</TT>, <TT>&#X2019;SIGUSR2&#X2019;</TT>, <TT>&#X2019;SIGALRM&#X2019;</TT>,&#X2026;). This
predicate is an interface to the C Unix function <TT>kill(2)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pid</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Pid</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Pid)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Signal</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Signal</TT> is neither a variable nor an integer or an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Signal)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>sleep/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc280">8.27.28</A>&#XA0;&#XA0;<TT>sleep/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
sleep(+number)</TT></DD></DL><P><B>Description</B></P><P><TT>sleep(Seconds)</TT> puts the GNU Prolog process to sleep for
<TT>Second</TT>s seconds. <TT>Seconds</TT> can be an integer or a floating
point number (in which case it can be &lt; 1). This predicate is an interface
to the C Unix function <TT>usleep(3)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Seconds</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Seconds</TT> is neither a variable nor a number</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(number, Seconds)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Seconds</TT> is a number &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, Seconds)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>select/5</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc281">8.27.29</A>&#XA0;&#XA0;<TT>select/5</TT></H4><!--SEC END --><P>
<A NAME="select/5"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
select(+list, ?list, +list, ?list, +number)</TT></DD></DL><P><B>Description</B></P><P><TT>select(Reads, ReadyReads, Writes, ReadyWrites, TimeOut)</TT> waits for a
number of streams (or file descriptors) to change status.
<TT>ReadyReads</TT> is unified with the list of elements listed in
<TT>Reads</TT> that have characters available for reading. Similarly
<TT>ReadyWrites</TT> is unified with the list of elements of <TT>Writes</TT>
that are ok for immediate writing. The elements of <TT>Reads</TT> and
<TT>Writes</TT> are either stream-terms or aliases or integers considered as
file descriptors, e.g. for sockets (section&#XA0;<A HREF="#Sockets-input/output">8.28</A>). Streams
that must be tested with <TT>select/5</TT> should not be buffered. This can
be done at the opening using <TT>open/4</TT> (section&#XA0;<A HREF="#open/4">8.10.6</A>) or later using
<TT>set_stream_buffering/2</TT> (section&#XA0;<A HREF="#set-stream-buffering/2">8.10.27</A>).
<TT>TimeOut</TT> is an upper bound on the amount of time (in milliseconds)
elapsed before <TT>select/5</TT> returns. If <TT>TimeOut</TT> &#X2264; 0 (no
timeout) <TT>select/5</TT> waits until something is available (either or
reading or for writing) and thus can block indefinitely. This predicate is
an interface to the C Unix function <TT>select(2)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Reads</TT> (or <TT>Writes</TT>) is a partial list or a list
with an element <TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Reads</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Reads)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Writes</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Writes)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>ReadyReads</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, ReadyReads)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>ReadyWrites</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, ReadyWrites)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Reads</TT> (or <TT>Writes</TT>)
list is neither a stream-term or alias nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(stream_or_alias, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Reads</TT> (or <TT>Writes</TT>)
list is not a selectable item</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(selectable_item, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Reads</TT> (or <TT>Writes</TT>)
list is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Reads</TT> (or <TT>Writes</TT>)
list is a stream-tern or alias not associated with an open stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(stream, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Reads</TT> list is associated with
an output stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(input, stream, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Writes</TT> list is associated with
an input stream</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>permission_error(output, stream, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>TimeOut</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>TimeOut</TT> is neither a variable nor a number</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(number, TimeOut)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsection Sockets input/output-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc282">8.28</A>&#XA0;&#XA0;Sockets input/output</H3><!--SEC END --><P>
<A NAME="Sockets-input/output"></A></P><!--TOC subsubsection Introduction-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc283">8.28.1</A>&#XA0;&#XA0;Introduction</H4><!--SEC END --><P>
<A NAME="Introduction:(Sockets-input/output)"></A>
This set of predicates provides a way to manipulate sockets. The predicates
are straightforward interfaces to the corresponding BSD-type socket
functions. This facility is available if the sockets part of GNU Prolog has
been installed. A reader familiar with BSD sockets will understand them
immediately otherwise a study of sockets is needed.</P><P>The domain is either the atom <TT>&#X2019;AF_INET&#X2019;</TT> or <TT>&#X2019;AF_UNIX&#X2019;</TT>
corresponding to the same domains in BSD-type sockets.</P><P>An address is either of the form <TT>&#X2019;AF_INET&#X2019;(HostName, Port)</TT> or
<TT>&#X2019;AF_UNIX&#X2019;(SocketName)</TT>. <TT>HostName</TT> is an atom denoting a
machine name, <TT>Port</TT> is a port number and <TT>SocketName</TT> is an
atom denoting a socket.</P><P>By default, streams associated with sockets are <TT>block</TT> buffered. The
predicate <TT>set_stream_buffering/2</TT> (section&#XA0;<A HREF="#set-stream-buffering/2">8.10.27</A>)
can be used to change this mode. They are also text streams by default. Use
<TT>set_stream_type/2</TT> (section&#XA0;<A HREF="#set-stream-type/2">8.10.25</A>) to change the type
if binary streams are needed.</P><!--TOC subsubsection <TT>socket/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc284">8.28.2</A>&#XA0;&#XA0;<TT>socket/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
socket(+socket_domain, -integer)</TT></DD></DL><P><B>Description</B></P><P><TT>socket(Domain, Socket)</TT> creates a socket whose domain is
<TT>Domain</TT> (section&#XA0;<A HREF="#Sockets-input/output">8.28</A>) and unifies <TT>Socket</TT>
with the descriptor identifying the socket. This predicate is an interface
to the C Unix function <TT>socket(2)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Domain</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Domain</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Domain)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Domain</TT> is an atom but not a valid socket domain</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(socket_domain, Domain)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Socket</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>uninstantiation_error(Socket)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>socket_close/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc285">8.28.3</A>&#XA0;&#XA0;<TT>socket_close/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
socket_close(+integer)</TT></DD></DL><P><B>Description</B></P><P><TT>socket_close(Socket)</TT> closes the socket whose descriptor is
<TT>Socket</TT>. This predicate should not be used if <TT>Socket</TT> has
given rise to a stream, e.g. by <TT>socket_connect/4</TT>
(section&#XA0;<A HREF="#socket-connect/4">8.28.5</A>). In that case simply use <TT>close/2</TT>
(section&#XA0;<A HREF="#close/2">8.10.7</A>) on the associated stream.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Socket</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Socket</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Socket)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>socket_bind/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc286">8.28.4</A>&#XA0;&#XA0;<TT>socket_bind/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
socket_bind(+integer, +socket_address)</TT></DD></DL><P><B>Description</B></P><P><TT>socket_bind(Socket, Address)</TT> binds the socket whose descriptor is
<TT>Socket</TT> to the address specified by <TT>Address</TT>
(section&#XA0;<A HREF="#Sockets-input/output">8.28</A>). If <TT>Address</TT> if of the form
<TT>&#X2019;AF_INET&#X2019;(HostName, Port)</TT> and if <TT>HostName</TT> is
uninstantiated then it is unified with the current machine name. If
<TT>Port</TT> is uninstantiated, it is unified to a port number picked by
the operating system. This predicate is an interface to the C Unix function
<TT>bind(2)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Socket</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Socket</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Socket)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Address</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Address</TT> is neither a variable nor a valid address</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(socket_address, Address)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Address</TT> = <TT>&#X2019;AF_UNIX&#X2019;(E)</TT> and <TT>E</TT> is a
variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Address</TT> = <TT>&#X2019;AF_UNIX&#X2019;(E)</TT> or <TT>&#X2019;AF_INET&#X2019;(E,
_)</TT> and <TT>E</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Address</TT> = <TT>&#X2019;AF_UNIX&#X2019;(E)</TT> and <TT>E</TT> is an atom
but not a valid pathname</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(os_path, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Address</TT> = <TT>&#X2019;AF_INET&#X2019;(_, E)</TT> and <TT>E</TT> is
neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>socket_connect/4</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc287">8.28.5</A>&#XA0;&#XA0;<TT>socket_connect/4</TT></H4><!--SEC END --><P>
<A NAME="socket-connect/4"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
socket_connect(+integer, +socket_address, -stream, -stream)</TT></DD></DL><P><B>Description</B></P><P><TT>socket_connect(Socket, Address, StreamIn, StreamOut)</TT> connects the
socket whose descriptor is <TT>Socket</TT> to the address specified by
<TT>Address</TT> (section&#XA0;<A HREF="#Sockets-input/output">8.28</A>). <TT>StreamIn</TT> is
unified with a stream-term associated with the input of the connection (it is
an input stream). Reading from this stream gets data from the socket.
<TT>StreamOut</TT> is unified with a stream-term associated with the output of
the connection (it is an output stream). Writing to this stream sends data
to the socket. The use of <TT>select/5</TT> can be useful
(section&#XA0;<A HREF="#select/5">8.27.29</A>). This predicate is an interface to the C Unix function
<TT>connect(2)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Socket</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Socket</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Socket)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Address</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Address</TT> is neither a variable nor a valid address</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(socket_address, Address)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Address</TT> = <TT>&#X2019;AF_UNIX&#X2019;(E)</TT> or <TT>&#X2019;AF_INET&#X2019;(E,
_)</TT> or <TT>Address</TT> = <TT>&#X2019;AF_INET&#X2019;(_, E)</TT> and <TT>E</TT> is a
variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Address</TT> = <TT>&#X2019;AF_UNIX&#X2019;(E)</TT> or <TT>&#X2019;AF_INET&#X2019;(E,
_)</TT> and <TT>E</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Address</TT> = <TT>&#X2019;AF_UNIX&#X2019;(E)</TT> and <TT>E</TT> is an atom
but not a valid pathname</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(os_path, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Address</TT> = <TT>&#X2019;AF_INET&#X2019;(_, E)</TT> and <TT>E</TT> is
neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>StreamIn</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>uninstantiation_error(StreamIn)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>StreamOut</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>uninstantiation_error(StreamOut)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>socket_listen/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc288">8.28.6</A>&#XA0;&#XA0;<TT>socket_listen/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
socket_listen(+integer, +integer)</TT></DD></DL><P><B>Description</B></P><P><TT>socket_listen(Socket, Length)</TT> defines the socket whose descriptor
is <TT>Socket</TT> to have a maximum backlog queue of <TT>Length</TT>
pending connections. This predicate is an interface to the C Unix function
<TT>listen(2)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Socket</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Socket</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Socket)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Length</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Length</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Length)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>socket_accept/4</TT>,
<TT>socket_accept/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc289">8.28.7</A>&#XA0;&#XA0;<TT>socket_accept/4</TT>,
<TT>socket_accept/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
socket_accept(+integer, -atom, -stream, -stream)<BR>
socket_accept(+integer, -stream, -stream)</TT></DD></DL><P><B>Description</B></P><P><TT>socket_accept(Socket, Client, StreamIn, StreamOut)</TT> extracts the
first connection to the socket whose descriptor is <TT>Socket</TT>. If the
domain is <TT>&#X2019;AF_INET&#X2019;</TT>, <TT>Client</TT> is unified with an atom whose
name is the Internet host address in numbers-and-dots notation of the
connecting machine. <TT>StreamIn</TT> is unified with a stream-term
associated with the input of the connection (it is an input stream). Reading
from this stream gets data from the socket. <TT>StreamOut</TT> is unified
with a stream-term associated with the output of the connection (it is an
output stream). Writing to this stream sends data to the socket. The use of
<TT>select/5</TT> can be useful (section&#XA0;<A HREF="#select/5">8.27.29</A>). This predicate is an
interface to the C Unix function <TT>accept(2)</TT>.</P><P><TT>socket_accept(Socket, StreamIn, StreamOut)</TT> is equivalent to
<TT>socket_accept(Socket, _,<BR>
 StreamIn, StreamOut)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Socket</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Socket</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Socket)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Client</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>uninstantiation_error(Client)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>StreamIn</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>uninstantiation_error(StreamIn)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>StreamOut</TT> is not a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>uninstantiation_error(StreamOut)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an operating system error occurs and the value of the
<TT>os_error</TT> Prolog flag is <TT>error</TT>
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>system_error(<I>atom explaining the error</I>)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>hostname_address/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc290">8.28.8</A>&#XA0;&#XA0;<TT>hostname_address/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
hostname_address(+atom, ?atom)<BR>
hostname_address(?atom, +atom)</TT></DD></DL><P><B>Description</B></P><P><TT>hostname_address(HostName, HostAddress)</TT> succeeds if the Internet
host address in numbers-and-dots notation of <TT>HostName</TT> is
<TT>HostAddress</TT>. <TT>Hostname</TT> can be given as a fully qualified
name, or an unqualified name or an alias of the machine. The predicate will
fail if the machine name or address cannot be resolved.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>HostName</TT> and <TT>HostAddress</TT> are variables</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>HostName</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, HostName)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>HostAddress</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, HostAddress)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Address</TT> is neither a variable nor a valid address</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(socket_address, Address)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsection Linedit management-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc291">8.29</A>&#XA0;&#XA0;Linedit management</H3><!--SEC END --><P>
The following predicates are only available if the <TT>linedit</TT> part of
GNU Prolog has been installed.</P><!--TOC subsubsection <TT>get_linedit_prompt/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc292">8.29.1</A>&#XA0;&#XA0;<TT>get_linedit_prompt/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
get_linedit_prompt(?atom)</TT></DD></DL><P><B>Description</B></P><P><TT>get_linedit_prompt(Prompt)</TT> succeeds if <TT>Prompt</TT> is the
current <TT>linedit</TT> prompt, e.g. the top-level prompt is
<TT>&#X2019;| ?-&#X2019;</TT>. By default all other reads have an empty prompt.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Prompt</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Pred)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>set_linedit_prompt/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc293">8.29.2</A>&#XA0;&#XA0;<TT>set_linedit_prompt/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
set_linedit_prompt(+atom)</TT></DD></DL><P><B>Description</B></P><P><TT>set_linedit_prompt(Prompt)</TT> sets the current <TT>linedit</TT>
prompt to <TT>Prompt</TT>. This prompt will be displayed for reads from a
terminal (except for top-level reads).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Prompt</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Prompt</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Pred)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>add_linedit_completion/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc294">8.29.3</A>&#XA0;&#XA0;<TT>add_linedit_completion/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
add_linedit_completion(+atom)</TT></DD></DL><P><B>Description</B></P><P><TT>add_linedit_completion(Word)</TT> adds <TT>Word</TT> in the list of
completion words maintained by <TT>linedit</TT>
(section&#XA0;<A HREF="#The-line-editor">4.2.6</A>). Only words containing letters, digits and
the underscore character are added (if <TT>Word</TT> does not respect
this restriction the predicate fails).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Word</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Word</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Word)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>find_linedit_completion/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc295">8.29.4</A>&#XA0;&#XA0;<TT>find_linedit_completion/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
find_linedit_completion(+atom, ?atom)</TT></DD></DL><P><B>Description</B></P><P><TT>find_linedit_completion(Prefix, Word)</TT> succeeds if <TT>Word</TT>
is a word beginning by <TT>Prefix</TT> and belongs to the list of
completion words maintained by <TT>linedit</TT>
(section&#XA0;<A HREF="#The-line-editor">4.2.6</A>). This predicate is re-executable on backtracking.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Prefix</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Prefix</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Prefix)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Word</TT> is neither a variable nor an atom</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(atom, Word)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsection Source reader facility-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc296">8.30</A>&#XA0;&#XA0;Source reader facility</H3><!--SEC END --><!--TOC subsubsection Introduction-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc297">8.30.1</A>&#XA0;&#XA0;Introduction</H4><!--SEC END --><P>To be written...</P><!--TOC subsubsection <TT>sr_open/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc298">8.30.2</A>&#XA0;&#XA0;<TT>sr_open/3</TT></H4><!--SEC END --><!--TOC subsubsection <TT>sr_change_options/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc299">8.30.3</A>&#XA0;&#XA0;<TT>sr_change_options/2</TT></H4><!--SEC END --><!--TOC subsubsection <TT>sr_close/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc300">8.30.4</A>&#XA0;&#XA0;<TT>sr_close/1</TT></H4><!--SEC END --><!--TOC subsubsection <TT>sr_read_term/4</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc301">8.30.5</A>&#XA0;&#XA0;<TT>sr_read_term/4</TT></H4><!--SEC END --><!--TOC subsubsection <TT>sr_current_descriptor/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc302">8.30.6</A>&#XA0;&#XA0;<TT>sr_current_descriptor/1</TT></H4><!--SEC END --><!--TOC subsubsection <TT>sr_get_stream/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc303">8.30.7</A>&#XA0;&#XA0;<TT>sr_get_stream/2</TT></H4><!--SEC END --><!--TOC subsubsection <TT>sr_get_module/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc304">8.30.8</A>&#XA0;&#XA0;<TT>sr_get_module/3</TT></H4><!--SEC END --><!--TOC subsubsection <TT>sr_get_file_name/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc305">8.30.9</A>&#XA0;&#XA0;<TT>sr_get_file_name/2</TT></H4><!--SEC END --><!--TOC subsubsection <TT>sr_get_position/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc306">8.30.10</A>&#XA0;&#XA0;<TT>sr_get_position/3</TT></H4><!--SEC END --><!--TOC subsubsection <TT>sr_get_include_list/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc307">8.30.11</A>&#XA0;&#XA0;<TT>sr_get_include_list/2</TT></H4><!--SEC END --><!--TOC subsubsection <TT>sr_get_include_stream_list/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc308">8.30.12</A>&#XA0;&#XA0;<TT>sr_get_include_stream_list/2</TT></H4><!--SEC END --><!--TOC subsubsection <TT>sr_get_size_counters/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc309">8.30.13</A>&#XA0;&#XA0;<TT>sr_get_size_counters/3</TT></H4><!--SEC END --><!--TOC subsubsection <TT>sr_get_error_counters/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc310">8.30.14</A>&#XA0;&#XA0;<TT>sr_get_error_counters/3</TT></H4><!--SEC END --><!--TOC subsubsection <TT>sr_set_error_counters/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc311">8.30.15</A>&#XA0;&#XA0;<TT>sr_set_error_counters/3</TT></H4><!--SEC END --><!--TOC subsubsection <TT>sr_error_from_exception/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc312">8.30.16</A>&#XA0;&#XA0;<TT>sr_error_from_exception/2</TT></H4><!--SEC END --><!--TOC subsubsection <TT>sr_write_message/8</TT>,
<TT>sr_write_message/6</TT>,
<TT>sr_write_message/4</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc313">8.30.17</A>&#XA0;&#XA0;<TT>sr_write_message/8</TT>,
<TT>sr_write_message/6</TT>,
<TT>sr_write_message/4</TT></H4><!--SEC END --><!--TOC subsubsection <TT>sr_write_error/6</TT>,
<TT>sr_write_error/4</TT>,
<TT>sr_write_error/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc314">8.30.18</A>&#XA0;&#XA0;<TT>sr_write_error/6</TT>,
<TT>sr_write_error/4</TT>,
<TT>sr_write_error/2</TT></H4><!--SEC END --><!--CUT END -->
<!--TOC section Finite domain solver and built-in predicates-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc315">9</A>&#XA0;&#XA0;Finite domain solver and built-in predicates</H2><!--SEC END --><!--CUT DEF subsection 1 --><!--TOC subsection Introduction-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc316">9.1</A>&#XA0;&#XA0;Introduction</H3><!--SEC END --><P>
<A NAME="Intro-FD"></A>
The finite domain (FD) constraint solver extends Prolog with constraints over
FD. This facility is available if the FD part of GNU Prolog has been
installed. The solver is an instance of the Constraint Logic Programming
scheme introduced by Jaffar and Lassez in 1987
[<A HREF="#Jaffar-Lassez87">7</A>]. Constraints on FD are solved using propagation
techniques, in particular arc-consistency (AC). The interested reader can
refer to &#X201C;Constraint Satisfaction in Logic Programming&#X201D; of P. Van
Hentenryck (1989) [<A HREF="#pvh89">8</A>]. The solver is based on the <TT>clp(FD)</TT>
solver [<A HREF="#long-clp-fd">4</A>]. The GNU Prolog FD solver offers arithmetic
constraints, boolean constraints, reified constraints and symbolic
constraints on an new kind of variables: Finite Domain variables.</P><!--TOC subsubsection Finite Domain variables-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc317">9.1.1</A>&#XA0;&#XA0;Finite Domain variables</H4><!--SEC END --><P>
<A NAME="Finite-Domain-variables"></A>
A new type of data is introduced: FD variables which can only take values in
their domains. The initial domain of an FD variable is
<TT>0..fd_max_integer</TT> where <TT>fd_max_integer</TT> represents the
greatest value that any FD variable can take. The predicate
<TT>fd_max_integer/1</TT> returns this value which may be different from
the <TT>max_integer</TT> Prolog flag
(section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>). The domain of an FD variable <TT>X</TT> is
reduced step by step by constraints in a monotonic way: when a value
has been removed from the domain of <TT>X</TT> it will never reappear
in the domain of <TT>X</TT>. An FD variable is fully compatible with
both Prolog integers and Prolog variables. Namely, when an FD
variable is expected by an FD constraint it is possible to pass a
Prolog integer (considered as an FD variable whose domain is a
singleton) or a Prolog variable (immediately bound to an initial range
<TT>0..fd_max_integer</TT>). This avoids the need for specific type
declaration. Although it is not necessary to declare the initial domain of an
FD variable (since it will be bound <TT>0..fd_max_integer</TT> when
appearing for the fist time in a constraint) it is advantageous to do so and
thus reduce as soon as possible the size of its domain: particularly because
GNU Prolog, for efficiency reasons, does not check for overflows. For instance,
without any preliminary domain definitions for <TT>X</TT>, <TT>Y</TT> and
<TT>Z</TT>, the non-linear constraint <TT>X*Y#=Z</TT> will fail due to an
overflow when computing the upper bound of the domain of <TT>Z</TT>:
<TT>fd_max_integer &#XD7; fd_max_integer</TT>. This overflow causes a
negative result for the upper bound and the constraint then fails.</P><P>There are two internal representations for an FD variable:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><B>interval representation</B>: only the <EM>min</EM> and the
<EM>max</EM> of the variable are maintained. In this representation it is
possible to store values included in <TT>0..fd_max_integer</TT>.</LI><LI CLASS="li-itemize"><B>sparse representation</B>: an additional bit-vector is used to
store the set of possible values for the variable (i.e. the domain). In
this representation it is possible to store values included in
<TT>0..vector_max</TT>. By default <TT>vector_max</TT> is set to 127.
This value can be redefined via an environment variable <TT>VECTORMAX</TT>
or via the built-in predicate <TT>fd_set_vector_max/1</TT>
(section&#XA0;<A HREF="#fd-set-vector-max/1">9.2.3</A>). The predicate <TT>fd_vector_max/1</TT>
returns the current value of <TT>vector_max</TT>
(section&#XA0;<A HREF="#fd-max-integer/1">9.2.1</A>).</LI></UL><P>
The initial representation for an FD variable <TT>X</TT> is always an
interval representation and is switched to a sparse representation when a
&#X201C;hole&#X201D; appears in the domain (e.g. due to an inequality constraint). Once a
variable uses a sparse representation it will not switch back to an interval
representation even if there are no longer holes in its domain. When this
switching occurs some values in the domain of <TT>X</TT> can be lost since
<TT>vector_max</TT> is less than <TT>fd_max_integer</TT>. We say that
&#X201C;<TT>X</TT> is extra-constrained&#X201D; since
<TT>X</TT> is constrained by the solver to the domain
<TT>0..vector_max</TT> (via an imaginary constraint
<TT>X #=&lt; <I>vector_max</I></TT>). An <TT>extra_cstr</TT> is
associated with each FD variable to indicate that values have been lost due to
the switch to a sparse representation. This flag is updated on every
operations. The domain of an extra-constrained FD variable is output followed
by the <TT>@</TT> symbol. When a constraint fails on a extra-constrained
variable a message <TT>Warning: Vector too small - maybe lost solutions
(FD Var:<I>N</I>)</TT> is displayed (<I><TT>N</TT></I> is the address of the involved
variable).</P><P>Example 1 (<TT>vector_max</TT> = <TT>127</TT>):</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP>
Constraint on <TT>X</TT></TD><TD ALIGN=left NOWRAP>Domain of <TT>X</TT></TD><TD ALIGN=center NOWRAP><TT>extra_cstr</TT></TD><TD ALIGN=left NOWRAP>Lost values</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>X #=&lt; 512</TT></TD><TD ALIGN=left NOWRAP><TT>0..512</TT></TD><TD ALIGN=center NOWRAP><TT>off</TT></TD><TD ALIGN=left NOWRAP>none</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>X #\= 10</TT></TD><TD ALIGN=left NOWRAP><TT>0..9:11..127</TT></TD><TD ALIGN=center NOWRAP><TT>on</TT></TD><TD ALIGN=left NOWRAP><TT>128..512</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>X #=&lt; 100</TT></TD><TD ALIGN=left NOWRAP><TT>0..9:11..100</TT></TD><TD ALIGN=center NOWRAP><TT>off</TT></TD><TD ALIGN=left NOWRAP>none</TD></TR>
</TABLE><P>In this example, when the constraint <TT>X #\= 10</TT> is posted some
values are lost, the <TT>extra_cstr</TT> is then switched on. However,
posting the constraint <TT>X #=&lt; 100</TT> will turn off the flag (no
values are lost).</P><P>Example 2:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP>
Constraint on <TT>X</TT></TD><TD ALIGN=left NOWRAP>Domain of <TT>X</TT></TD><TD ALIGN=center NOWRAP><TT>extra_cstr</TT></TD><TD ALIGN=left NOWRAP>Lost values</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>X #=&lt; 512</TT></TD><TD ALIGN=left NOWRAP><TT>0..512</TT></TD><TD ALIGN=center NOWRAP><TT>off</TT></TD><TD ALIGN=left NOWRAP>none</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>X #\= 10</TT></TD><TD ALIGN=left NOWRAP><TT>0..9:11..127</TT></TD><TD ALIGN=center NOWRAP><TT>on</TT></TD><TD ALIGN=left NOWRAP><TT>128..512</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>X #&gt;= 256</TT></TD><TD ALIGN=left NOWRAP><TT>Warning: Vector too small&#X2026;</TT></TD><TD ALIGN=center NOWRAP><TT>on</TT></TD><TD ALIGN=left NOWRAP><TT>128..512</TT></TD></TR>
</TABLE><P>In this example, the constraint <TT>X #&gt;= 256</TT> fails due to the lost
of <TT>128..512</TT> so a message is displayed onto the terminal. The
solution would consist in increasing the size of the vector either by setting
the environment variable <TT>VECTORMAX</TT> (e.g. to <TT>512</TT>) or using
<TT>fd_set_vector_max(512)</TT>.</P><P>Finally, bit-vectors are not dynamic, i.e. all vectors have the same size
(<TT>0..vector_max</TT>). So the use of <TT>fd_set_vector_max/1</TT> is
limited to the initial definition of vector sizes and must occur before any
constraint. As seen before, the solver tries to display a message when a
failure occurs due to a too short <TT>vector_max</TT>. Unfortunately, in
some cases it cannot detect the lost of values and no message is emitted. So
the user should always take care to this parameter to be sure that it is
large to encode any vector.</P><!--TOC subsection FD variable parameters-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc318">9.2</A>&#XA0;&#XA0;FD variable parameters</H3><!--SEC END --><!--TOC subsubsection <TT>fd_max_integer/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc319">9.2.1</A>&#XA0;&#XA0;<TT>fd_max_integer/1</TT></H4><!--SEC END --><P>
<A NAME="fd-max-integer/1"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_max_integer(?integer)</TT></DD></DL><P><B>Description</B></P><P><TT>fd_max_integer(N)</TT> succeeds if <TT>N</TT> is the current value of
<TT>fd_max_integer</TT> (section&#XA0;<A HREF="#Intro-FD">9.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>N</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, N)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>fd_vector_max/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc320">9.2.2</A>&#XA0;&#XA0;<TT>fd_vector_max/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_vector_max(?integer)</TT></DD></DL><P><B>Description</B></P><P><TT>fd_vector_max(N)</TT> succeeds if <TT>N</TT> is the current value of
<TT>vector_max</TT> (section&#XA0;<A HREF="#Intro-FD">9.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>N</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, N)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>fd_set_vector_max/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc321">9.2.3</A>&#XA0;&#XA0;<TT>fd_set_vector_max/1</TT></H4><!--SEC END --><P>
<A NAME="fd-set-vector-max/1"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_set_vector_max(+integer)</TT></DD></DL><P><B>Description</B></P><P><TT>fd_set_vector_max(N)</TT> initializes <TT>vector_max</TT> based on
the value <TT>N</TT> (section&#XA0;<A HREF="#Intro-FD">9.1</A>). More precisely, on 32 bit
machines, <TT>vector_max</TT> is set to the smallest value of
<TT>(32*k)-</TT>1 which is &#X2265; <TT>N</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>N</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>N</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, N)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>N</TT> is an integer &lt; 0</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(not_less_than_zero, N)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsection Initial value constraints-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc322">9.3</A>&#XA0;&#XA0;Initial value constraints</H3><!--SEC END --><!--TOC subsubsection <TT>fd_domain/3</TT>,
<TT>fd_domain_bool/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc323">9.3.1</A>&#XA0;&#XA0;<TT>fd_domain/3</TT>,
<TT>fd_domain_bool/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_domain(+fd_variable_list_or_fd_variable, +integer,
+integer)<BR>
fd_domain(?fd_variable, +integer, +integer)<BR>
fd_domain_bool(+fd_variable_list)<BR>
fd_domain_bool(?fd_variable)</TT></DD></DL><P><B>Description</B></P><P><TT>fd_domain(Vars, Lower, Upper)</TT> constraints each element <TT>X</TT>
of <TT>Vars</TT> to take a value in <TT>Lower..Upper</TT>. This
predicate is generally used to set the initial domain of variables to an
interval. <TT>Vars</TT> can be also a single FD variable (or a single Prolog
variable).</P><P><TT>fd_domain_bool(Vars)</TT> is equivalent to <TT>fd_domain(Vars, 0,
1)</TT> and is used to declare boolean FD variables.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Vars</TT> is not a variable but is a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Vars</TT> is neither a variable nor an FD variable nor an
integer nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Vars)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Vars</TT> list is neither a
variable nor an FD variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Lower</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Lower</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Lower)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Upper</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Upper</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Upper)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>fd_domain/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc324">9.3.2</A>&#XA0;&#XA0;<TT>fd_domain/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_domain(+fd_variable_list, +integer_list)<BR>
fd_domain(?fd_variable, +integer_list)</TT></DD></DL><P><B>Description</B></P><P><TT>fd_domain(Vars, Values)</TT> constraints each element <TT>X</TT> of the
list <TT>Vars</TT> to take a value in the list <TT>Values</TT>. This
predicate is generally used to set the initial domain of variables to a set
of values. The domain of each variable of <TT>Vars</TT> uses a sparse
representation. <TT>Vars</TT> can be also a single FD variable (or a single
Prolog variable).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Vars</TT> is not a variable but is a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Vars</TT> is neither a variable nor an FD variable nor an
integer nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Vars)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Vars</TT> list is neither a
variable nor an FD variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Values</TT> is a partial list or a list with an element
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Values</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Values)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Values</TT> list is neither a
variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsection Type testing-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc325">9.4</A>&#XA0;&#XA0;Type testing</H3><!--SEC END --><!--TOC subsubsection <TT>fd_var/1</TT>, <TT>non_fd_var/1</TT>,
<TT>generic_var/1</TT>,
<TT>non_generic_var/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc326">9.4.1</A>&#XA0;&#XA0;<TT>fd_var/1</TT>, <TT>non_fd_var/1</TT>,
<TT>generic_var/1</TT>,
<TT>non_generic_var/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_var(?term)<BR>
non_fd_var(?term)<BR>
generic_var(?term)<BR>
non_generic_var(?term)</TT></DD></DL><P><B>Description</B></P><P><TT>fd_var(Term)</TT> succeeds if <TT>Term</TT> is currently an
FD variable.</P><P><TT>non_fd_var(Term)</TT> succeeds if <TT>Term</TT> is
currently not an FD variable (opposite of <TT>fd_var/1</TT>).</P><P><TT>generic_var(Term)</TT> succeeds if <TT>Term</TT> is
either a Prolog variable or an FD variable.</P><P><TT>non_generic_var(Term)</TT> succeeds if
<TT>Term</TT> is neither a Prolog variable nor an FD variable
(opposite of <TT>generic_var/1</TT>).</P><P><B>Errors</B></P><P>None.</P><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsection FD variable information-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc327">9.5</A>&#XA0;&#XA0;FD variable information</H3><!--SEC END --><P>
These predicate allow the user to get some information about FD variables.
They are not constraints, they only return the current state of a variable.</P><!--TOC subsubsection <TT>fd_min/2</TT>,
<TT>fd_max/2</TT>,
<TT>fd_size/2</TT>,
<TT>fd_dom/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc328">9.5.1</A>&#XA0;&#XA0;<TT>fd_min/2</TT>,
<TT>fd_max/2</TT>,
<TT>fd_size/2</TT>,
<TT>fd_dom/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_min(+fd_variable, ?integer)<BR>
fd_max(+fd_variable, ?integer)<BR>
fd_size(+fd_variable, ?integer)<BR>
fd_dom(+fd_variable, ?integer_list)</TT></DD></DL><P><B>Description</B></P><P><TT>fd_min(X, N)</TT> succeeds if <TT>N</TT> is the minimal value of the
current domain of <TT>X</TT>.</P><P><TT>fd_max(X, N)</TT> succeeds if <TT>N</TT> is the maximal value of the
current domain of <TT>X</TT>.</P><P><TT>fd_size(X, N)</TT> succeeds if <TT>N</TT> is the number of elements of
the current domain of <TT>X</TT>.</P><P><TT>fd_dom(X, Values)</TT> succeeds if <TT>Values</TT> is the list of
values of the current domain of <TT>X</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>X</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>X</TT> is neither an FD variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, X)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>N</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, N)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Vars</TT> list is neither a
variable nor an FD variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Values</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Values)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>fd_has_extra_cstr/1</TT>,
<TT>fd_has_vector/1</TT>,
<TT>fd_use_vector/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc329">9.5.2</A>&#XA0;&#XA0;<TT>fd_has_extra_cstr/1</TT>,
<TT>fd_has_vector/1</TT>,
<TT>fd_use_vector/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_has_extra_cstr(+fd_variable)<BR>
fd_has_vector(+fd_variable)<BR>
fd_use_vector(+fd_variable)</TT></DD></DL><P><B>Description</B></P><P><TT>fd_has_extra_cstr(X)</TT> succeeds if the <TT>extra_cstr</TT>
of <TT>X</TT> is currently on (section&#XA0;<A HREF="#Intro-FD">9.1</A>).</P><P><TT>fd_has_vector(X)</TT> succeeds if the current domain of <TT>X</TT>
uses a sparse representation (section&#XA0;<A HREF="#Intro-FD">9.1</A>).</P><P><TT>fd_use_vector(X)</TT> enforces a sparse representation for the domain
of <TT>X</TT> (section&#XA0;<A HREF="#Intro-FD">9.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>X</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>X</TT> is neither an FD variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, X)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsection Arithmetic constraints-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc330">9.6</A>&#XA0;&#XA0;Arithmetic constraints</H3><!--SEC END --><!--TOC subsubsection FD arithmetic expressions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc331">9.6.1</A>&#XA0;&#XA0;FD arithmetic expressions</H4><!--SEC END --><P>
<A NAME="FD-arithmetic-expressions"></A>
An FD arithmetic expression is a Prolog term built from integers, variables
(Prolog or FD variables), and functors (or operators) that represent
arithmetic functions. The following table details the components of an FD
arithmetic expression:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD VALIGN=top ALIGN=left NOWRAP>
FD Expression</TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">Result</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
Prolog variable</TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">domain <TT>0..fd_max_integer</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
FD variable <TT>X</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">domain of <TT>X</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
integer number <TT>N</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">domain <TT>N..N</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>+ E</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">same as <TT>E</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>- E</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">opposite of <TT>E</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 + E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">sum of <TT>E1</TT> and <TT>E2</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 - E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">subtraction of <TT>E2</TT> from <TT>E1</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 * E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">multiplication of <TT>E1</TT> by <TT>E2</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 / E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">integer division of <TT>E1</TT> by <TT>E2</TT> (only
succeeds if the remainder is 0)</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 ** E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft"><TT>E1</TT> raised to the power of <TT>E2
</TT>(<TT>E1</TT> or <TT>E2</TT> must be an integer)</DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>min(E1,E2)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">minimum of <TT>E1</TT> and <TT>E2</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>max(E1,E2)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">maximum of <TT>E1</TT> and <TT>E2</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>dist(E1,E2)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">distance, i.e. |<TT>E1 - E2|</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 // E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">quotient of the integer division of <TT>E1</TT> by
<TT>E2</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>E1 rem E2</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">remainder of the integer division of <TT>E1</TT> by
<TT>E2</TT></DIV></TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP>
<TT>quot_rem(E1,E2,R)</TT></TD><TD VALIGN=top ALIGN=left><DIV CLASS="flushleft">quotient of the integer division of
<TT>E1</TT> by <TT>E2</TT>
<BR>
(<TT>R</TT> is the remainder of the integer division of <TT>E1</TT> by
<TT>E2</TT>)</DIV></TD></TR>
</TABLE><P>FD expressions are not restricted to be linear. However non-linear
constraints usually yield less constraint propagation than linear
constraints.</P><P><TT>+</TT>, <TT>-</TT>, <TT>*</TT>, <TT>/</TT>, <TT>//</TT>, <TT>rem</TT>
and <TT>**</TT> are predefined infix operators. <TT>+</TT> and <TT>-</TT>
are predefined prefix operators (section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
a sub-expression is of the form <TT>_ ** E</TT> and <TT>E</TT> is
a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
a sub-expression <TT>E</TT> is neither a variable nor an integer
nor an FD arithmetic functor</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_evaluable, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an expression is too complex</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>resource_error(too_big_fd_constraint)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><!--TOC subsubsection Partial AC: <TT>(#=)/2</TT> - constraint equal,
<TT>(#</TT><TT>\</TT><TT>=)/2</TT> - constraint not equal,<BR>
 <TT>(#</TT><TT>&lt;</TT><TT>)/2</TT> - constraint less than,
<TT>(#=</TT><TT>&lt;</TT><TT>)/2</TT> - constraint less than or equal,<BR>
 <TT>(#</TT><TT>&gt;</TT><TT>)/2</TT> - constraint greater than,
<TT>(#</TT><TT>&gt;</TT><TT>=)/2</TT> - constraint greater than or equal-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc332">9.6.2</A>&#XA0;&#XA0;Partial AC: <TT>(#=)/2</TT> - constraint equal,
<TT>(#\=)/2</TT> - constraint not equal,<BR>
 <TT>(#&lt;)/2</TT> - constraint less than,
<TT>(#=&lt;)/2</TT> - constraint less than or equal,<BR>
 <TT>(#&gt;)/2</TT> - constraint greater than,
<TT>(#&gt;=)/2</TT> - constraint greater than or equal</H4><!--SEC END --><P>
<A NAME="Partial-AC:-(:=)/2"></A>





</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
#=(?fd_evaluable, ?fd_evaluable)<BR>
#\=(?fd_evaluable, ?fd_evaluable)<BR>
#&lt;(?fd_evaluable, ?fd_evaluable)<BR>
#=&lt;(?fd_evaluable, ?fd_evaluable)<BR>
#&gt;(?fd_evaluable, ?fd_evaluable)<BR>
#&gt;=(?fd_evaluable, ?fd_evaluable)</TT></DD></DL><P><B>Description</B></P><P><TT>FdExpr1 #= FdExpr2</TT> constrains <TT>FdExpr1</TT> to be
equal to <TT>FdExpr2</TT>.</P><P><TT>FdExpr1 #\= FdExpr2</TT> constrains <TT>FdExpr1</TT>
to be different from <TT>FdExpr2</TT>.</P><P><TT>FdExpr1 #&lt; FdExpr2</TT> constrains <TT>FdExpr1</TT> to
be less than <TT>FdExpr2</TT>.</P><P><TT>FdExpr1 #=&lt; FdExpr2</TT> constrains <TT>FdExpr1</TT>
to be less than or equal to <TT>FdExpr2</TT>.</P><P><TT>FdExpr1 #&gt; FdExpr2</TT> constrains <TT>FdExpr1</TT> to
be greater than <TT>FdExpr2</TT>.</P><P><TT>FdExpr1 #&gt;= FdExpr2</TT> constrains <TT>FdExpr1</TT>
to be greater than or equal to <TT>FdExpr2</TT>.</P><P><TT>FdExpr1</TT> and <TT>FdExpr2</TT> are arithmetic FD expressions
(section&#XA0;<A HREF="#FD-arithmetic-expressions">9.6.1</A>).</P><P><TT>#=</TT>, <TT>#\=</TT>, <TT>#&lt;</TT>, <TT>#=&lt;</TT>,
<TT>#&gt;</TT> and <TT>#&gt;=</TT> are predefined infix operators
(section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</P><P>These predicates post arithmetic constraints that are managed by the solver
using a partial arc-consistency algorithm to reduce the domain of involved
variables. In this scheme only the bounds of the domain of variables are
updated. This leads to less propagation than full arc-consistency techniques
(section&#XA0;<A HREF="#Full-AC:-(:=:)/2">9.6.3</A>) but is generally more efficient for
arithmetic. These arithmetic constraints can be reified (section&#XA0;<A HREF="#Boolean-and-reified-constraints">9.7</A>).</P><P><B>Errors</B></P><P>Refer to the syntax of arithmetic FD expressions for possible errors
(section&#XA0;<A HREF="#FD-arithmetic-expressions">9.6.1</A>).</P><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection Full AC: <TT>(#=#)/2</TT> - constraint equal,
<TT>(#</TT><TT>\</TT><TT>=#)/2</TT> - constraint not equal,<BR>
 <TT>(#</TT><TT>&lt;</TT><TT>#)/2</TT> - constraint less than,
<TT>(#=</TT><TT>&lt;</TT><TT>#)/2</TT> - constraint less than or equal,<BR>
 <TT>(#</TT><TT>&gt;</TT><TT>#)/2</TT> - constraint greater than,
<TT>(#</TT><TT>&gt;</TT><TT>=#)/2</TT> - constraint greater than or equal-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc333">9.6.3</A>&#XA0;&#XA0;Full AC: <TT>(#=#)/2</TT> - constraint equal,
<TT>(#\=#)/2</TT> - constraint not equal,<BR>
 <TT>(#&lt;#)/2</TT> - constraint less than,
<TT>(#=&lt;#)/2</TT> - constraint less than or equal,<BR>
 <TT>(#&gt;#)/2</TT> - constraint greater than,
<TT>(#&gt;=#)/2</TT> - constraint greater than or equal</H4><!--SEC END --><P>
<A NAME="Full-AC:-(:=:)/2"></A>





</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
#=#(?fd_evaluable, ?fd_evaluable)<BR>
#\=#(?fd_evaluable, ?fd_evaluable)<BR>
#&lt;#(?fd_evaluable, ?fd_evaluable)<BR>
#=&lt;#(?fd_evaluable, ?fd_evaluable)<BR>
#&gt;#(?fd_evaluable, ?fd_evaluable)<BR>
#&gt;=#(?fd_evaluable, ?fd_evaluable)</TT></DD></DL><P><B>Description</B></P><P><TT>FdExpr1 #=# FdExpr2</TT> constrains <TT>FdExpr1</TT> to
be equal to <TT>FdExpr2</TT>.</P><P><TT>FdExpr1 #\=# FdExpr2</TT> constrains <TT>FdExpr1</TT> to be
different from <TT>FdExpr2</TT>.</P><P><TT>FdExpr1 #&lt;# FdExpr2</TT> constrains <TT>FdExpr1</TT>
to be less than <TT>FdExpr2</TT>.</P><P><TT>FdExpr1 #=&lt;# FdExpr2</TT> constrains <TT>FdExpr1</TT> to be
less than or equal to <TT>FdExpr2</TT>.</P><P><TT>FdExpr1 #&gt;# FdExpr2</TT> constrains <TT>FdExpr1</TT>
to be greater than <TT>FdExpr2</TT>.</P><P><TT>FdExpr1 #&gt;=# FdExpr2</TT> constrains <TT>FdExpr1</TT> to be
greater than or equal to <TT>FdExpr2</TT>.</P><P><TT>FdExpr1</TT> and <TT>FdExpr2</TT> are arithmetic FD expressions
(section&#XA0;<A HREF="#FD-arithmetic-expressions">9.6.1</A>).</P><P><TT>#=#</TT>, <TT>#\=#</TT>, <TT>#&lt;#</TT>,
<TT>#=&lt;#</TT>, <TT>#&gt;#</TT> and <TT>#&gt;=#</TT> are
predefined infix operators (section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</P><P>These predicates post arithmetic constraints that are managed by the solver
using a full arc-consistency algorithm to reduce the domain of involved
variables. In this scheme the full domain of variables is updated. This
leads to more propagation than partial arc-consistency techniques (section&#XA0;<A HREF="#FD-arithmetic-expressions">9.6.1</A>) but is generally less efficient for arithmetic.
These arithmetic constraints can be reified (section&#XA0;<A HREF="#Boolean-FD-expressions">9.7.1</A>).</P><P><B>Errors</B></P><P>Refer to the syntax of arithmetic FD expressions for possible errors
(section&#XA0;<A HREF="#FD-arithmetic-expressions">9.6.1</A>).</P><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>fd_prime/1</TT>,
<TT>fd_not_prime/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc334">9.6.4</A>&#XA0;&#XA0;<TT>fd_prime/1</TT>,
<TT>fd_not_prime/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_prime(?fd_variable)<BR>
fd_not_prime(?fd_variable)</TT></DD></DL><P><B>Description</B></P><P><TT>fd_prime(X)</TT> constraints <TT>X</TT> to be a prime number between
<TT>0..vector_max</TT>.
This constraint enforces a sparse representation
for the domain of <TT>X</TT> (section&#XA0;<A HREF="#Intro-FD">9.1</A>).</P><P><TT>fd_not_prime(X)</TT> constraints <TT>X</TT> to be a non prime number
between <TT>0..vector_max</TT>. This constraint enforces a sparse
representation for the domain of <TT>X</TT> (section&#XA0;<A HREF="#Intro-FD">9.1</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>X</TT> is neither an FD variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, X)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsection Boolean and reified constraints-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc335">9.7</A>&#XA0;&#XA0;Boolean and reified constraints</H3><!--SEC END --><P>
<A NAME="Boolean-and-reified-constraints"></A></P><!--TOC subsubsection Boolean FD expressions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc336">9.7.1</A>&#XA0;&#XA0;Boolean FD expressions</H4><!--SEC END --><P>
<A NAME="Boolean-FD-expressions"></A></P><P>An boolean FD expression is a Prolog term built from integers (0 for false,
1 for true), variables (Prolog or FD variables), partial AC arithmetic
constraints (section&#XA0;<A HREF="#Partial-AC:-(:=)/2">9.6.2</A>), full AC arithmetic constraints
(section&#XA0;<A HREF="#Full-AC:-(:=:)/2">9.6.3</A>) and functors (or operators) that represent
boolean functions. When a sub-expression of a boolean expression is an
arithmetic constraint <I><TT>c</TT></I>, it is reified. Namely, as soon as the
solver detects that <I><TT>c</TT></I> is true (i.e. <EM>entailed</EM>) the
sub-expression has the value <TT>1</TT>. Similarly when the solver detects
that <I><TT>c</TT></I> is false (i.e. <EM>disentailed</EM>) the sub-expression
evaluates as <TT>0</TT>. While neither the entailment nor the disentailment
can be detected the sub-expression is evaluated as a domain <TT>0..1</TT>.
The following table details the components of an FD boolean expression:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP>
FD Expression</TD><TD ALIGN=left NOWRAP>Result</TD></TR>
<TR><TD ALIGN=left NOWRAP>
Prolog variable</TD><TD ALIGN=left NOWRAP>domain <TT>0..1</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
FD variable <TT>X</TT></TD><TD ALIGN=left NOWRAP>domain of <TT>X</TT>, <TT>X</TT> is constrained to
be in <TT>0..1</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>0</TT> (integer)</TD><TD ALIGN=left NOWRAP><TT>0</TT> (false)</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>1</TT> (integer)</TD><TD ALIGN=left NOWRAP><TT>1</TT> (true)</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>#\ E</TT></TD><TD ALIGN=left NOWRAP>not <TT>E</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>E1 #&lt;=&gt; E2</TT></TD><TD ALIGN=left NOWRAP><TT>E1</TT> equivalent to <TT>E2</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>E1 #\&lt;=&gt; E2</TT></TD><TD ALIGN=left NOWRAP><TT>E1</TT> not equivalent to
<TT>E2</TT> (i.e. <TT>E1</TT> different from <TT>E2)</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>E1 ## E2</TT></TD><TD ALIGN=left NOWRAP><TT>E1</TT> exclusive OR <TT>E2</TT> (i.e. <TT>E1</TT>
not equivalent to <TT>E2)</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>E1 #==&gt; E2</TT></TD><TD ALIGN=left NOWRAP><TT>E1</TT> implies <TT>E2</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>E1 #\==&gt; E2</TT></TD><TD ALIGN=left NOWRAP><TT>E1</TT> does not imply <TT>E2</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>E1 #/\ E2</TT></TD><TD ALIGN=left NOWRAP><TT>E1</TT> AND <TT>E2</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>E1 #\/\ E2</TT></TD><TD ALIGN=left NOWRAP><TT>E1</TT> NAND <TT>E2</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>E1 #\/ E2</TT></TD><TD ALIGN=left NOWRAP><TT>E1</TT> OR <TT>E2</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>E1 #\\/ E2</TT></TD><TD ALIGN=left NOWRAP><TT>E1</TT> NOR <TT>E2</TT></TD></TR>
</TABLE><P><TT>#&lt;=&gt;</TT>, <TT>#\&lt;=&gt;</TT>, <TT>##</TT>,
<TT>#==&gt;</TT>, <TT>#\==&gt;</TT>, <TT>#/\</TT>,
<TT>#\/\</TT>, <TT>#\/</TT> and <TT>#\\/</TT> are
predefined infix operators. <TT>#\</TT> is a predefined prefix operator
(section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
a sub-expression <TT>E</TT> is neither a variable nor an integer (0
or 1) nor an FD boolean functor nor reified constraint</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_bool_evaluable, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an expression is too complex</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>resource_error(too_big_fd_constraint)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
a sub-expression is an invalid reified constraint</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left>an arithmetic constraint error (section&#XA0;<A HREF="#FD-arithmetic-expressions">9.6.1</A>)</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><!--TOC subsubsection <TT>fd_reified_in/4</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc337">9.7.2</A>&#XA0;&#XA0;<TT>fd_reified_in/4</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_reified_in(?fd_variable, +integer, +integer, ?fd_variable)
</TT></DD></DL><P><B>Description</B></P><P><TT>fd_reified_in(X, Lower, Upper, B)</TT> captures the truth value of the constraint <TT>X</TT> &#X2208; [<TT>Lower</TT>..<TT>Upper</TT>] in the boolean variable <TT>B</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>X</TT> is neither a variable nor an FD variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, X)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>B</TT> is neither a variable nor an FD variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, B)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Lower</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Lower</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Lower)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Upper</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Upper</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Upper)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><!--TOC subsubsection <TT>(#</TT><TT>\</TT><TT>)/1</TT> - constraint NOT,
<TT>(#</TT><TT>&lt;</TT><TT>=</TT><TT>&gt;</TT><TT>)/2</TT> - constraint equivalent,<BR>
 <TT>(#</TT><TT>\</TT><TT>&lt;</TT><TT>=</TT><TT>&gt;</TT><TT>)/2</TT> - constraint different,
<TT>(##)/2</TT> - constraint XOR,<BR>
 <TT>(#==</TT><TT>&gt;</TT><TT>)/2</TT> - constraint imply,
<TT>(#</TT><TT>\</TT><TT>==</TT><TT>&gt;</TT><TT>)/2</TT> - constraint not imply,<BR>
 <TT>(#/</TT><TT>\</TT><TT>)/2</TT> - constraint AND,
<TT>(#</TT><TT>\</TT><TT>/</TT><TT>\</TT><TT>)/2</TT> - constraint NAND,<BR>
 <TT>(#</TT><TT>\</TT><TT>/)/2</TT> - constraint OR,
<TT>(#</TT><TT>\</TT><TT>\</TT><TT>/)/2</TT> - constraint NOR-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc338">9.7.3</A>&#XA0;&#XA0;<TT>(#\)/1</TT> - constraint NOT,
<TT>(#&lt;=&gt;)/2</TT> - constraint equivalent,<BR>
 <TT>(#\&lt;=&gt;)/2</TT> - constraint different,
<TT>(##)/2</TT> - constraint XOR,<BR>
 <TT>(#==&gt;)/2</TT> - constraint imply,
<TT>(#\==&gt;)/2</TT> - constraint not imply,<BR>
 <TT>(#/\)/2</TT> - constraint AND,
<TT>(#\/\)/2</TT> - constraint NAND,<BR>
 <TT>(#\/)/2</TT> - constraint OR,
<TT>(#\\/)/2</TT> - constraint NOR</H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
#\(?fd_bool_evaluable)<BR>
#&lt;=&gt;(?fd_bool_evaluable, ?fd_bool_evaluable)<BR>
#\&lt;=&gt;(?fd_bool_evaluable, ?fd_bool_evaluable)<BR>
##(?fd_bool_evaluable, ?fd_bool_evaluable)<BR>
#==&gt;(?fd_bool_evaluable, ?fd_bool_evaluable)<BR>
#\==&gt;(?fd_bool_evaluable, ?fd_bool_evaluable)<BR>
#/\(?fd_bool_evaluable, ?fd_bool_evaluable)<BR>
#\/\(?fd_bool_evaluable, ?fd_bool_evaluable)<BR>
#\/(?fd_bool_evaluable, ?fd_bool_evaluable)<BR>
#\\/(?fd_bool_evaluable, ?fd_bool_evaluable)</TT></DD></DL><P><B>Description</B></P><P><TT>#\= FdBoolExpr1</TT> constraints <TT>FdBoolExpr1</TT> to be
false.</P><P><TT>FdBoolExpr1 #&lt;=&gt; FdBoolExpr2</TT> constrains
<TT>FdBoolExpr1</TT> to be equivalent to <TT>FdBoolExpr2</TT>.</P><P><TT>FdBoolExpr1 #\&lt;=&gt; FdBoolExpr2</TT> constrains
<TT>FdBoolExpr1</TT> to be equivalent to not <TT>FdBoolExpr2</TT>.</P><P><TT>FdBoolExpr1 ## FdBoolExpr2</TT> constrains <TT>FdBoolExpr1</TT> XOR
<TT>FdBoolExpr2</TT> to be true</P><P><TT>FdBoolExpr1 #==&gt; FdBoolExpr2</TT> constrains
<TT>FdBoolExpr1</TT> to imply <TT>FdBoolExpr2</TT>.</P><P><TT>FdBoolExpr1 #\==&gt; FdBoolExpr2</TT> constrains
<TT>FdBoolExpr1</TT> to not imply <TT>FdBoolExpr2</TT>.</P><P><TT>FdBoolExpr1 #/\ FdBoolExpr2</TT> constrains <TT>FdBoolExpr1</TT>
AND <TT>FdBoolExpr2</TT> to be true.</P><P><TT>FdBoolExpr1 #\/\ FdBoolExpr2</TT> constrains
<TT>FdBoolExpr1</TT> AND <TT>FdBoolExpr2</TT> to be false.</P><P><TT>FdBoolExpr1 #\/ FdBoolExpr2</TT> constrains <TT>FdBoolExpr1</TT>
OR <TT>FdBoolExpr2</TT> to be true.</P><P><TT>FdBoolExpr1 #\\/ FdBoolExpr2</TT> constrains
<TT>FdBoolExpr1</TT> OR <TT>FdBoolExpr2</TT> to be false.</P><P><TT>FdBoolExpr1</TT> and <TT>FdBoolExpr2</TT> are boolean FD expressions
(section&#XA0;<A HREF="#Boolean-FD-expressions">9.7.1</A>).</P><P>Note that <TT>#\&lt;=&gt;</TT> (not equivalent) and <TT>##</TT>
(exclusive or) are synonymous.</P><P>These predicates post boolean constraints that are managed by the FD solver
using a partial arc-consistency algorithm to reduce the domain of involved
variables. The (dis)entailment of reified constraints is detected using
either the bounds (for partial AC arithmetic constraints) or the full domain
(for full AC arithmetic constraints).</P><P><TT>#&lt;=&gt;</TT>, <TT>#\&lt;=&gt;</TT>, <TT>##</TT>,
<TT>#==&gt;</TT>, <TT>#\==&gt;</TT>, <TT>#/\</TT>,
<TT>#\/\</TT>, <TT>#\/</TT> and <TT>#\\/</TT> are
predefined infix operators. <TT>#\</TT> is a predefined prefix operator
(section&#XA0;<A HREF="#op/3:(Term-input/output)">8.14.10</A>).</P><P><B>Errors</B></P><P>Refer to the syntax of boolean FD expressions for possible errors
(section&#XA0;<A HREF="#Boolean-FD-expressions">9.7.1</A>).</P><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>fd_cardinality/2</TT>,
<TT>fd_cardinality/3</TT>,
<TT>fd_at_least_one/1</TT>,
<TT>fd_at_most_one/1</TT>,<BR>
 <TT>fd_only_one/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc339">9.7.4</A>&#XA0;&#XA0;<TT>fd_cardinality/2</TT>,
<TT>fd_cardinality/3</TT>,
<TT>fd_at_least_one/1</TT>,
<TT>fd_at_most_one/1</TT>,<BR>
 <TT>fd_only_one/1</TT></H4><!--SEC END --><P>
<A NAME="fd-cardinality/2"></A>




</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_cardinality(+fd_bool_evaluable_list, ?fd_variable)<BR>
fd_cardinality(+integer, ?fd_variable, +integer)<BR>
fd_at_least_one(+fd_bool_evaluable_list)<BR>
fd_at_most_one(+fd_bool_evaluable_list)<BR>
fd_only_one(+fd_bool_evaluable_list)</TT></DD></DL><P><B>Description</B></P><P><TT>fd_cardinality(List, Count)</TT> unifies <TT>Count</TT> with the number
of constraints that are true in <TT>List</TT>. This is equivalent to post
the constraint <TT>B<SUB>1</SUB> + B<SUB>2</SUB> + &#X2026;+ B<SUB><I>n</I></SUB> #= Count</TT>
where each variable <TT>Bi</TT> is a new variable defined by the constraint
<TT>B<SUB><I>i</I></SUB> #&lt;=&gt; C<SUB><I>i</I></SUB></TT> where <TT>C<SUB><I>i</I></SUB></TT> is the
<TT>i</TT><EM>th</EM> constraint of <TT>List</TT>. Each <TT>C<SUB><I>i</I></SUB></TT>
must be a boolean FD expression (section&#XA0;<A HREF="#Boolean-FD-expressions">9.7.1</A>).</P><P><TT>fd_cardinality(Lower, List, Upper)</TT> is equivalent to
<TT>fd_cardinality(List, Count), Lower #=&lt; Count, Count #=&lt;
Upper</TT></P><P><TT>fd_at_least_one(List)</TT> is equivalent to
<TT>fd_cardinality(List, Count), Count #&gt;= 1</TT>.</P><P><TT>fd_at_most_one(List)</TT> is equivalent to
<TT>fd_cardinality(List, Count), Count #=&lt; 1</TT>.</P><P><TT>fd_only_one(List)</TT> is equivalent to <TT>fd_cardinality(List,
1)</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, List)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Count</TT> is neither an FD variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, Count)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Lower</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Lower</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Lower)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Upper</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Upper</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, Upper)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>List</TT> list is an invalid
boolean expression</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left>an FD boolean constraint (section&#XA0;<A HREF="#Boolean-FD-expressions">9.7.1</A>)</TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsection Symbolic constraints-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc340">9.8</A>&#XA0;&#XA0;Symbolic constraints</H3><!--SEC END --><!--TOC subsubsection <TT>fd_all_different/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc341">9.8.1</A>&#XA0;&#XA0;<TT>fd_all_different/1</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_all_different(+fd_variable_list)</TT></DD></DL><P><B>Description</B></P><P><TT>fd_all_different(List)</TT> constrains all variables in <TT>List</TT>
to take distinct values. This is equivalent to posting an inequality
constraint for each pair of variables. This constraint is triggered when a
variable becomes ground, removing its value from the domain of the other
variables.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, List)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>List</TT> list is neither a
variable nor an integer nor an FD variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>fd_element/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc342">9.8.2</A>&#XA0;&#XA0;<TT>fd_element/3</TT></H4><!--SEC END --><P>
<A NAME="fd-element/3"></A>
</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_element(?fd_variable, +integer_list, ?fd_variable)</TT></DD></DL><P><B>Description</B></P><P><TT>fd_element(I, List, X)</TT> constraints <TT>X</TT> to be equal to the
<TT>I</TT><EM>th</EM> integer (from 1) of <TT>List</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>I</TT> is neither a variable nor an FD variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, I)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>X</TT> is neither a variable nor an FD variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, X)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is a partial list or a list with an element
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, List)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>List</TT> list is neither a
variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>fd_element_var/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc343">9.8.3</A>&#XA0;&#XA0;<TT>fd_element_var/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_element_var(?fd_variable, +fd_variable_list, ?fd_variable)</TT></DD></DL><P><B>Description</B></P><P><TT>fd_element_var(I, List, X)</TT> constraints <TT>X</TT> to be equal to
the <TT>I</TT><EM>th</EM> variable (from 1) of <TT>List</TT>. This
constraint is similar to <TT>fd_element/3</TT> (section&#XA0;<A HREF="#fd-element/3">9.8.2</A>) but
<TT>List</TT> can also contain FD variables (rather than just integers).</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>I</TT> is neither a variable nor an FD variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, I)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>X</TT> is neither a variable nor an FD variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, X)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, List)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>List</TT> list is neither a
variable nor an integer nor an FD variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicate.</P><!--TOC subsubsection <TT>fd_atmost/3</TT>,
<TT>fd_atleast/3</TT>,
<TT>fd_exactly/3</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc344">9.8.4</A>&#XA0;&#XA0;<TT>fd_atmost/3</TT>,
<TT>fd_atleast/3</TT>,
<TT>fd_exactly/3</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_atmost(+integer, +fd_variable_list, +integer)<BR>
fd_atleast(+integer, +fd_variable_list, +integer)<BR>
fd_exactly(+integer, +fd_variable_list, +integer)</TT></DD></DL><P><B>Description</B></P><P><TT>fd_atmost(N, List, V)</TT> posts the constraint that at most <TT>N</TT>
variables of <TT>List</TT> are equal to the value <TT>V</TT>.</P><P><TT>fd_atleast(N, List, V)</TT> posts the constraint that at least
<TT>N</TT> variables of <TT>List</TT> are equal to the value <TT>V</TT>.</P><P><TT>fd_exactly(N, List, V)</TT> posts the constraint that at exactly
<TT>N</TT> variables of <TT>List</TT> are equal to the value <TT>V</TT>.</P><P>These constraints are special cases of <TT>fd_cardinality/2</TT>
(section&#XA0;<A HREF="#fd-cardinality/2">9.7.4</A>) but their implementation is more efficient.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>N</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>N</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, N)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>V</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>V</TT> is neither a variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, V)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>List</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, List)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>List</TT> list is neither a
variable nor an FD variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsubsection <TT>fd_relation/2</TT>,
<TT>fd_relationc/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc345">9.8.5</A>&#XA0;&#XA0;<TT>fd_relation/2</TT>,
<TT>fd_relationc/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_relation(+integer_list_list, ?fd_variable_list)<BR>
fd_relationc(+integer_list_list, ?fd_variable_list)</TT></DD></DL><P><B>Description</B></P><P><TT>fd_relation(Relation, Vars)</TT> constraints the tuple of variables
<TT>Vars</TT> to be equal to one tuple of the list <TT>Relation</TT>. A
tuple is represented by a list.</P><P>Example: definition of the boolean AND relation so that X AND Y
&#X21D4; Z:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">and(X,Y,Z):-
        fd_relation([[0,0,0],[0,1,0],[1,0,0],[1,1,1]], [X,Y,Z]).
</PRE></DD></DL><P><TT>fd_relationc(Columns, Vars)</TT> is similar to <TT>fd_relation/2</TT>
except that the relation is not given as the list of tuples but as the list
of the columns of the relation. A column is represented by a list.</P><P>Example:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">and(X,Y,Z):-
        fd_relationc([[0,0,1,1],[0,1,0,1],[0,0,0,1]], [X,Y,Z]).
</PRE></DD></DL><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Relation</TT> is a partial list or a list with a sub-term
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Relation</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Relation)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Relation</TT> list is neither a
variable nor an integer</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(integer, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Vars</TT> is a partial list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Vars</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Vars)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Vars</TT> list is neither a
variable nor an integer nor an FD variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsection Labeling constraints-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc346">9.9</A>&#XA0;&#XA0;Labeling constraints</H3><!--SEC END --><!--TOC subsubsection <TT>fd_labeling/2</TT>,
<TT>fd_labeling/1</TT>,
<TT>fd_labelingff/1</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc347">9.9.1</A>&#XA0;&#XA0;<TT>fd_labeling/2</TT>,
<TT>fd_labeling/1</TT>,
<TT>fd_labelingff/1</TT></H4><!--SEC END --><P>
<A NAME="fd-labeling/2"></A>


</P><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_labeling(+fd_variable_list, +fd_labeling_option_list)<BR>
fd_labeling(+fd_variable, +fd_labeling_option_list)<BR>
fd_labeling(+fd_variable_list)<BR>
fd_labeling(+fd_variable)<BR>
fd_labelingff(+fd_variable_list)<BR>
fd_labelingff(+fd_variable)</TT></DD></DL><P><B>Description</B></P><P><TT>fd_labeling(Vars, Options)</TT> assigns a value to each variable
<TT>X</TT> of the list <TT>Vars</TT> according to the list of labeling
options given by <TT>Options</TT>. <TT>Vars</TT> can be also a single FD
variable. This predicate is re-executable on backtracking.</P><P><B>FD labeling options</B>: <TT>Options</TT> is a list of labeling
options. If this list contains contradictory options, the rightmost option
is the one which applies. Possible options are:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>variable_method(V)</TT>: specifies the
heuristics to select the variable to enumerate:<UL CLASS="itemize"><LI CLASS="li-itemize"><TT>standard</TT>: no heuristics, the leftmost variable is selected.</LI><LI CLASS="li-itemize"><TT>first_fail</TT> (or <TT>ff</TT>): selects the variable with the
smallest number of elements in its domain. If several variables have the
same number of elements the leftmost variable is selected.</LI><LI CLASS="li-itemize"><TT>most_constrained</TT>: like <TT>first_fail</TT> but when
several variables have the same number of elements selects the
variable that appears in most constraints.</LI><LI CLASS="li-itemize"><TT>smallest</TT>: selects the variable that has the smallest value
in its domain. If there is more than one such variable selects the
variable that appears in most constraints.</LI><LI CLASS="li-itemize"><TT>largest</TT>: selects the variable that has the greatest value in
its domain. If there is more than one such variable selects the variable
that appears in most constraints.</LI><LI CLASS="li-itemize"><TT>max_regret</TT>: selects the variable that has the greatest
difference between the smallest value and the next value of its domain. If
there is more than one such variable selects the variable that appears in
most constraints.</LI><LI CLASS="li-itemize"><TT>random</TT>: selects randomly a variable. Each variable is only
chosen once.</LI></UL><P>The default value is <TT>standard</TT>.</P></LI><LI CLASS="li-itemize"><TT>reorder(true/false)</TT>: specifies if the variable
heuristics should dynamically reorder the list of variable (<TT>true</TT>) or
not (<TT>false</TT>). Dynamic reordering is generally more efficient but in
some cases a static ordering is faster. The default value is
<TT>true</TT>.</LI><LI CLASS="li-itemize"><TT>value_method(V)</TT>: specifies the heuristics
to select the value to assign to the chosen variable:<UL CLASS="itemize"><LI CLASS="li-itemize"><TT>min</TT>: enumerates the values from the smallest to the greatest
(default).</LI><LI CLASS="li-itemize"><TT>max</TT>: enumerates the values from the greatest to the smallest.</LI><LI CLASS="li-itemize"><TT>middle</TT>: enumerates the values from the middle to the bounds.</LI><LI CLASS="li-itemize"><TT>bounds</TT>: enumerates the values from the bounds to the middle.</LI><LI CLASS="li-itemize"><TT>random</TT>: enumerates the values randomly. Each value is only
tried once.</LI></UL><P>The default value is <TT>min</TT>.</P></LI><LI CLASS="li-itemize"><TT>backtracks(B)</TT>: unifies <TT>B</TT> with the
number of backtracks during the enumeration.</LI></UL><P><TT>fd_labeling(Vars)</TT> is equivalent to <TT>fd_labeling(Vars,
[])</TT>.</P><P><TT>fd_labelingff(Vars)</TT> is equivalent to <TT>fd_labeling(Vars,
[variable_method(ff)])</TT>.</P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Vars</TT> is a partial list or a list with an element
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Vars</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Vars)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Vars</TT> list is neither a
variable nor an integer nor an FD variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Options</TT> is a partial list or a list with an element
<TT>E</TT> which is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Options</TT> is neither a partial list nor a list</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(list, Options)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
an element <TT>E</TT> of the <TT>Options</TT> list is neither a
variable nor a labeling option</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>domain_error(fd_labeling_option, E)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.</P><!--TOC subsection Optimization constraints-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc348">9.10</A>&#XA0;&#XA0;Optimization constraints</H3><!--SEC END --><!--TOC subsubsection <TT>fd_minimize/2</TT>,
<TT>fd_maximize/2</TT>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc349">9.10.1</A>&#XA0;&#XA0;<TT>fd_minimize/2</TT>,
<TT>fd_maximize/2</TT></H4><!--SEC END --><P><B>Templates</B></P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>
fd_minimize(+callable_term, ?fd_variable)<BR>
fd_maximize(+callable_term, ?fd_variable)</TT></DD></DL><P><B>Description</B></P><P><TT>fd_minimize(Goal, X)</TT> repeatedly calls <TT>Goal</TT> to find a
value that minimizes the variable <TT>X</TT>. <TT>Goal</TT> is a Prolog goal
that should instantiate <TT>X</TT>, a common case being the use of
<TT>fd_labeling/2</TT> (section&#XA0;<A HREF="#fd-labeling/2">9.9.1</A>). This predicate uses a
branch-and-bound algorithm with restart: each time <TT>call(Goal)</TT>
succeeds the computation restarts with a new constraint <TT>X #&lt; V</TT>
where <TT>V</TT> is the value of <TT>X</TT> at the end of the last call of
<TT>Goal</TT>. When a failure occurs (either because there are no remaining
choice-points for <TT>Goal</TT> or because the added constraint is
inconsistent with the rest of the store) the last solution is recomputed
since it is optimal.</P><P><TT>fd_maximize(Goal, X)</TT> is similar to <TT>fd_minimize/2</TT> but
<TT>X</TT> is maximized<TT>.</TT></P><P><B>Errors</B></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Goal</TT> is a variable</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>instantiation_error</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>Goal</TT> is neither a variable nor a callable term</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(callable, Goal)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
The predicate indicator <TT>Pred</TT> of <TT>Goal</TT> does not
correspond to an existing procedure and the value of the <TT>unknown</TT>
Prolog flag is <TT>error</TT> (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>)</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>existence_error(procedure, Pred)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
<TR><TD VALIGN=top ALIGN=left>
<TT>X</TT> is neither a variable nor an FD variable nor an integer
</TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD VALIGN=top ALIGN=left><TT>type_error(fd_variable, X)</TT></TD></TR>
<TR><TD CLASS="hbar" COLSPAN=3></TD></TR>
</TABLE><P><B>Portability</B></P><P>GNU Prolog predicates.
</P><!--CUT END -->
<!--TOC section Interfacing Prolog and C-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc350">10</A>&#XA0;&#XA0;Interfacing Prolog and C</H2><!--SEC END --><P>
<A NAME="Interfacing-Prolog-and-C"></A>
</P><!--CUT DEF subsection 1 --><!--TOC subsection Introduction-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc351">10.1</A>&#XA0;&#XA0;Introduction</H3><!--SEC END --><P>The foreign code interface allows the use to link Prolog and C in both
directions.</P><P>A Prolog predicate can call a C function passing different kinds of arguments
(input, output or input/output). The interface performs implicit Prolog
&#X2194; C data conversions for simple types (for instance a Prolog
integer is automatically converted into a C integer) and provides a set of
API (Application Programming Interface) functions to convert more complex
types (lists or structures). The interface also performs automatic error
detection depending on the actual type of the passed argument. An important
feature is the ability to write non-deterministic code in C.</P><P>It is also possible to call (or callback) a Prolog predicate from a C
function and to manage Prolog non-determinism: the C code can ask for next
solutions, remove all remaining solutions or terminate and keep
alternatives for the calling Prolog predicate).</P><!--TOC subsection Including and using <TT>gprolog.h</TT>-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc352">10.2</A>&#XA0;&#XA0;Including and using <TT>gprolog.h</TT></H3><!--SEC END --><P>The C code should include <TT>gprolog.h</TT> which provides a set of C
definitions (types, macros, prototypes) associated to the API. Include this
files as follows:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">#include &lt;gprolog.h&gt;
</PRE></DD></DL><P>If the installation has been correctly done nothing else is needed. If the C
compiler/preprocessor cannot locate <TT>gprolog.h</TT> pass the C compiler
option required to specify an additional include directory
(e.g.<TT>-Iinclude_dir</TT>) to <TT>gplc</TT> as follows
(section&#XA0;<A HREF="#Using-the-compiler">4.4.3</A>):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>% gplc -C -I</TT>include_dir ...</DD></DL><P>The file <TT>gprolog.h</TT> declares the following C types:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>PlBool</TT> as an integer and the constants <TT>PL_FALSE</TT> (i.e. 0) and <TT>PL_TRUE</TT>
(i.e. 1).</LI><LI CLASS="li-itemize"><TT>PlLong</TT> as an integer able to store a pointer (equivalent to
<TT>intptr_t</TT>). This type appeared in GNU Prolog 1.4.0 in replacement
of <TT>long</TT> to support Windows 64 bits (where the <TT>long</TT> type is only
32 bits). This type is used to handle integer types.</LI><LI CLASS="li-itemize"><TT>PlULong</TT> same as <TT>PlLong</TT> but unsigned (same as <TT>uintptr_t</TT>).</LI><LI CLASS="li-itemize"><TT>PlTerm</TT> same as <TT>intptr_t</TT>. This type is used to store general Prolog terms.</LI></UL><P><B>New in GNU Prolog 1.3.1 and backward compatibility issues</B>: in
GNU Prolog 1.3.1 the API has been modified to protect namespace. The name of
public functions, macros, variables and types are now prefixed
with <TT>Pl_</TT>, <TT>PL_</TT> or <TT>pl_</TT>. All these prefixes should
be avoided by the foreign C-code to prevent name clashes. To ensure a
backward compatibility, the names used by the old API are available thanks to
a set of <TT>#define</TT>. However, this deprecated API should not be used
by recent code. It is also possible to prevent the definition of the
compatibility macros using:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">#define __GPROLOG_FOREIGN_STRICT__
#include &lt;gprolog.h&gt;
</PRE></DD></DL><P>In addition, <TT>gprolog.h</TT> defines a set of macros:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT> __GNU_PROLOG__</TT> (as the major version).</LI><LI CLASS="li-itemize"><TT> __GPROLOG__</TT>, <TT>__GPROLOG_MINOR__</TT> and
<TT>__GPROLOG_PATCHLEVEL__</TT>. Their values are the major version,
minor version, and patch level of GNU Prolog, as integer constants. For
example, GNU Prolog 1.3.2 will define <TT>____GPROLOG__</TT> to 1,
<TT>____GPROLOG_MINOR__</TT> to 3, and
<TT>____GPROLOG_PATCHLEVEL__</TT> to 2.<P>If you need to write code which depends on a specific version, you must be
more careful. Recall these macros appeared in GNU Prolog 1.3.1 (undefined
before), each time the minor version is increased, the patch level is reset
to zero; each time the major version is increased (which happens rarely),
the minor version and patch level are reset.</P></LI><LI CLASS="li-itemize"><TT>__GPROLOG_VERSION__</TT>: the version as an integer defined as
follows: <I>major</I> * 10000 + <I>minor</I> * 100 + <I>patch level</I>. For example: version
1.3.2 will result in the value 10302.</LI><LI CLASS="li-itemize"><TT>PL_PROLOG_DIALECT</TT>: a C constant string (generally
<TT>"gprolog"</TT>). Appeared in 1.3.2.</LI><LI CLASS="li-itemize"><TT>PL_PROLOG_NAME</TT>: a C constant string (generally
<TT>"GNU Prolog"</TT>).</LI><LI CLASS="li-itemize"><TT>PL_PROLOG_VERSION</TT>: a C constant string associated to the
version (e.g. <TT>"1.4.0"</TT>).</LI><LI CLASS="li-itemize"><TT>PL_PROLOG_DATE</TT>: a C constant string associated with the date
of this version (e.g. <TT>"Mar 29 2011"</TT>.</LI><LI CLASS="li-itemize"><TT>PL_PROLOG_COPYRIGHT</TT>: a C constant string associated with the
copyright of this version (e.g. <TT>"Copyright (C) 1999-2012 Daniel Diaz"</TT>.</LI></UL><P>Note the above <TT>PL_PROLOG_</TT>... macros are also accessible via Prolog
flags thanks to the built-in predicate <TT>current_prolog_flag/2</TT>
(section&#XA0;<A HREF="#current-prolog-flag/2">8.22.2</A>)</P><!--TOC subsection Calling C from Prolog-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc353">10.3</A>&#XA0;&#XA0;Calling C from Prolog</H3><!--SEC END --><P>
<A NAME="Calling-C-from-Prolog"></A></P><!--TOC subsubsection Introduction-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc354">10.3.1</A>&#XA0;&#XA0;Introduction</H4><!--SEC END --><P>This interface can then be used to write both simple and complex C routines.
A simple routine uses either input or output arguments which type is simple.
In that case the user does not need any knowledge of Prolog data structures
since all Prolog &#X2194; C data conversions are implicitly
achieved. To manipulate complex terms (lists, structures) a set of functions
is provided. Finally it is also possible to write non-deterministic C code.</P><!--TOC subsubsection <TT>foreign/2</TT> directive-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc355">10.3.2</A>&#XA0;&#XA0;<TT>foreign/2</TT> directive</H4><!--SEC END --><P>
<A NAME="foreign/2-directive"></A>

</P><P><TT>foreign/2</TT> directive (section&#XA0;<A HREF="#foreign/2">7.1.15</A>) declares a C function interface.
The general form is <TT>foreign(Template, Options)</TT> which defines an
interface predicate whose prototype is <TT>Template</TT> according to the
options given by <TT>Options</TT>. <TT>Template</TT> is a callable term
specifying the type/mode of each argument of the associated Prolog predicate.</P><P><B>Foreign options</B>: <TT>Options</TT> is a list of foreign options. If
this list contains contradictory options, the rightmost option is the one
which applies. Possible options are:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>fct_name(F)</TT>: <TT>F</TT> is an atom representing
the name of the C function to call. By default the name of the C function is
the same as the principal functor of <TT>Template</TT>. In any case, the atom
associated with the name of the function must conforms to the syntax of C
identifiers.</LI><LI CLASS="li-itemize"><TT>return(boolean</TT>/<TT>none</TT>/<TT>jump)</TT>:
specifies the value returned by the C function:<UL CLASS="itemize"><LI CLASS="li-itemize"><TT>boolean</TT>: the type of the function is <TT>PlBool</TT> (returns
<TT>PL_TRUE</TT> on success, <TT>PL_FALSE</TT> otherwise).</LI><LI CLASS="li-itemize"><TT>none</TT>: the type of the function is <TT>void</TT> (no returned
value).</LI><LI CLASS="li-itemize"><TT>jump</TT>: the type of the function is <TT>void(*)()</TT> (returns
the address of a Prolog code to execute).</LI></UL><P>The default value is <TT>boolean</TT>.</P></LI><LI CLASS="li-itemize"><TT>bip_name(Name, Arity)</TT>: initializes the error
context with <TT>Name</TT> and <TT>Arity</TT>. If an error occurs this
information is used to indicate from which predicate the error occurred
(section&#XA0;<A HREF="#General-format-and-error-context">6.3.1</A>). It is also possible to prevent the
initialization of the error context using <TT>bip_name(none)</TT>. By
default <TT>Name</TT> and <TT>Arity</TT> are set to the functor and arity of
<TT>Template</TT>.</LI><LI CLASS="li-itemize"><TT>choice_size(N)</TT>: this option specifies that the
function implements a non-deterministic code. <TT>N</TT> is an integer
specifying the size needed by the non-deterministic C function. This facility
is explained later (section&#XA0;<A HREF="#Writing-non-deterministic-C-code">10.3.7</A>). By default a
foreign function is deterministic.</LI></UL><P><TT>foreign(Template)</TT> is equivalent to
<TT>foreign(Template, [])</TT>.</P><P><B>Foreign modes and types</B>: each argument of <TT>Template</TT>
specifies the foreign mode and type of the corresponding argument. This
information is used to check the type of effective arguments at run-time and
to perform Prolog &#X2194; C data conversions. Each argument of
<TT>Template</TT> is formed with a mode symbol followed by a type name.
Possible foreign modes are:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>+</TT>: input argument.</LI><LI CLASS="li-itemize"><TT>-</TT>: output argument.</LI><LI CLASS="li-itemize"><TT>?</TT>: input/output argument.</LI></UL><P>Possible foreign types are:</P><TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP>
Foreign type</TD><TD ALIGN=left NOWRAP>Prolog type</TD><TD ALIGN=left NOWRAP>C type</TD><TD ALIGN=left NOWRAP>Description of the C type</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>integer</TT></TD><TD ALIGN=left NOWRAP>integer</TD><TD ALIGN=left NOWRAP><TT>PlLong</TT></TD><TD ALIGN=left NOWRAP>value of the integer</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>positive</TT></TD><TD ALIGN=left NOWRAP>positive integer</TD><TD ALIGN=left NOWRAP><TT>PlLong</TT></TD><TD ALIGN=left NOWRAP>value of the integer</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>float</TT></TD><TD ALIGN=left NOWRAP>floating point number</TD><TD ALIGN=left NOWRAP><TT>double</TT></TD><TD ALIGN=left NOWRAP>value of the
floating point number</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>number</TT></TD><TD ALIGN=left NOWRAP>number</TD><TD ALIGN=left NOWRAP><TT>double</TT></TD><TD ALIGN=left NOWRAP>value of the number</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>atom</TT></TD><TD ALIGN=left NOWRAP>atom</TD><TD ALIGN=left NOWRAP><TT>PlLong</TT></TD><TD ALIGN=left NOWRAP>internal key of the atom</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>boolean</TT></TD><TD ALIGN=left NOWRAP>boolean</TD><TD ALIGN=left NOWRAP><TT>PlLong</TT></TD><TD ALIGN=left NOWRAP>value of the boolean
(0=<TT>false</TT>, 1=<TT>true</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>char</TT></TD><TD ALIGN=left NOWRAP>character</TD><TD ALIGN=left NOWRAP><TT>PlLong</TT></TD><TD ALIGN=left NOWRAP>value of (the code of) the
character</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>code</TT></TD><TD ALIGN=left NOWRAP>character code</TD><TD ALIGN=left NOWRAP><TT>PlLong</TT></TD><TD ALIGN=left NOWRAP>value of the character-code</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>byte</TT></TD><TD ALIGN=left NOWRAP>byte</TD><TD ALIGN=left NOWRAP><TT>PlLong</TT></TD><TD ALIGN=left NOWRAP>value of the byte</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>in_char</TT></TD><TD ALIGN=left NOWRAP>in-character</TD><TD ALIGN=left NOWRAP><TT>PlLong</TT></TD><TD ALIGN=left NOWRAP>value of the character or
<TT>-1</TT> for end-of-file</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>in_code</TT></TD><TD ALIGN=left NOWRAP>in-character code</TD><TD ALIGN=left NOWRAP><TT>PlLong</TT></TD><TD ALIGN=left NOWRAP>value of the
character-code or <TT>-1</TT> for end-of-file</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>in_byte</TT></TD><TD ALIGN=left NOWRAP>in-byte</TD><TD ALIGN=left NOWRAP><TT>PlLong</TT></TD><TD ALIGN=left NOWRAP>value of the byte or
<TT>-1</TT> for the end-of-file</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>string</TT></TD><TD ALIGN=left NOWRAP>atom</TD><TD ALIGN=left NOWRAP><TT>char *</TT></TD><TD ALIGN=left NOWRAP>C string containing the name of
the atom</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>chars</TT></TD><TD ALIGN=left NOWRAP>character list</TD><TD ALIGN=left NOWRAP><TT>char *</TT></TD><TD ALIGN=left NOWRAP>C string containing the
characters of the list</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>codes</TT></TD><TD ALIGN=left NOWRAP>character-code list</TD><TD ALIGN=left NOWRAP><TT>char *</TT></TD><TD ALIGN=left NOWRAP>C string containing
the characters of the list</TD></TR>
<TR><TD ALIGN=left NOWRAP>
<TT>term</TT></TD><TD ALIGN=left NOWRAP>Prolog term</TD><TD ALIGN=left NOWRAP><TT>PlTerm</TT></TD><TD ALIGN=left NOWRAP>generic Prolog term</TD></TR>
</TABLE><P><B>Simple foreign type</B>: a simple type is any foreign type listed in
the above tabled except <TT>term</TT>. A simple foreign type is an atomic
term (character and character-code lists are in fact lists of constants).
Each simple foreign type is converted to/from a C type to simplify the
writing of the C function.</P><P><B>Complex foreign type</B>: type foreign type <TT>term</TT> refers to any
Prolog term (e.g. lists, structures&#X2026;). When such an type is
specified the argument is passed to the C function as a <TT>PlTerm</TT>
(GNU Prolog C type equivalent to a <TT>PlLong</TT>). Several functions are
provided to manipulate <TT>PlTerm</TT> variables (section&#XA0;<A HREF="#Manipulating-Prolog-terms">10.4</A>). 
Since the original term is passed to the function it is
possible to read its value or to unify it. So the meaning of the mode symbol
is less significant. For this reason it is possible to omit the mode symbol.
In that case <TT>term</TT> is equivalent to <TT>+term</TT>.</P><!--TOC subsubsection The C function-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc356">10.3.3</A>&#XA0;&#XA0;The C function</H4><!--SEC END --><P>The type returned by the C function depends on the value of the
<TT>return</TT> foreign option (section&#XA0;<A HREF="#foreign/2-directive">10.3.2</A>). If it is
<TT>boolean</TT> then the C function is of type <TT>PlBool</TT> and shall
return <TT>PL_TRUE</TT> in case of success and <TT>PL_FALSE</TT>
otherwise. If the <TT>return</TT> option is <TT>none</TT> the C function is of
type <TT>void</TT>. Finally if it is <TT>jump</TT>, the function shall return
the address of a Prolog predicate and, at the exit of the function, the
control is given to that predicate.</P><P>The type of the arguments of the C function depends on the mode and type
declaration specified in <TT>Template</TT> for the corresponding argument as
explained in the following sections.</P><!--TOC subsubsection Input arguments-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc357">10.3.4</A>&#XA0;&#XA0;Input arguments</H4><!--SEC END --><P>
<A NAME="Input-arguments"></A>
An input argument is tested at run-time to check if its type conforms to the
foreign type and then it is passed to the C function. The type of the
associated C argument is given by the above table (section&#XA0;<A HREF="#foreign/2-directive">10.3.2</A>). For instance, the effective argument <TT>Arg</TT> associated with
<TT>+positive</TT> foreign declaration is submitted to the following
process:</P><UL CLASS="itemize"><LI CLASS="li-itemize">if <TT>Arg</TT> is a variable an <TT>instantiation_error</TT> is
raised.</LI><LI CLASS="li-itemize">if <TT>Arg</TT> is neither a variable nor an integer a
<TT>type_error(integer, Arg)</TT> is raised.</LI><LI CLASS="li-itemize">if <TT>Arg</TT> is an integer &lt; 0 a
<TT>domain_error(not_less_than_zero, Arg)</TT> is raised.</LI><LI CLASS="li-itemize">otherwise the value of <TT>Arg</TT> is passed to the C is passed to
the C function as an integer (<TT>PlLong</TT>).</LI></UL><P>When <TT>+string</TT> is specified the string passed to the function is the
internal string of the corresponding atom and should not be modified.</P><P>When <TT>+term</TT> is specified the term passed to the function is the
original Prolog term. It can be read and/or unified. It is also the case
when <TT>term</TT> is specified without any mode symbol.</P><!--TOC subsubsection Output arguments-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc358">10.3.5</A>&#XA0;&#XA0;Output arguments</H4><!--SEC END --><P>
<A NAME="Output-arguments"></A>
An output argument is tested at run-time to check if its type conforms to
the foreign type and it is unified with the value set by the C function. The
type of the associated C argument is a pointer to the type given by the
above table (section&#XA0;<A HREF="#foreign/2-directive">10.3.2</A>). For instance, the effective
argument <TT>Arg</TT> associated with <TT>-positive</TT> foreign declaration
is handled as follows:</P><UL CLASS="itemize"><LI CLASS="li-itemize">if <TT>Arg</TT> is neither a variable nor an integer a
<TT>type_error(integer, Arg)</TT> is raised.</LI><LI CLASS="li-itemize">if <TT>Arg</TT> is an integer &lt; 0 a
<TT>domain_error(not_less_than_zero, Arg)</TT> is raised.</LI><LI CLASS="li-itemize">otherwise a pointer to an integer (<TT>PlLong</TT> <TT>*</TT>) is passed
to the C function. If the function returns <TT>PL_TRUE</TT> the integer stored
at this location is unified with <TT>Arg</TT>.</LI></UL><P>When <TT>-term</TT> is specified, the function must construct a term into
the its corresponding argument (which is of type <TT>PlTerm *</TT>). At the
exit of the function this term will be unified with the actual predicate
argument.</P><!--TOC subsubsection Input/output arguments-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc359">10.3.6</A>&#XA0;&#XA0;Input/output arguments</H4><!--SEC END --><P>
<A NAME="Input/output-arguments"></A>
Basically an input/output argument is treated as in input argument if it is
not a variable, as an output argument otherwise. The type of the associated
C argument is a pointer to a <TT>PlFIOArg</TT> (GNU Prolog C type) defined as
follows:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">typedef struct
    {
     PlBool is_var;
     PlBool unify;
     union
        {
         PlLong l;
         char  *s;
         double d;
        }value;
    }PlFIOArg;
</PRE></DD></DL><P>The field <TT>is_var</TT> is set to <TT>PL_TRUE</TT> if the argument is a
variable and <TT>PL_FALSE</TT> otherwise. This value can be tested by the C
function to determine which treatment to perform. The field <TT>unify</TT>
controls whether the effective argument must be unified at the exit of the C
function. Initially <TT>unify</TT> is set to the same value as
<TT>is_var</TT> (i.e. a variable argument will be unified while a
non-variable argument will not) but it can be modified by the C function.
The field <TT>value</TT> stores the value of the argument. It is declared as
a C <TT>union</TT> since there are several kinds of value types. The field
<TT>s</TT> is used for C strings, <TT>d</TT> for C doubles and <TT>l</TT>
otherwise (<TT>int</TT>, <TT>PlLong</TT>, <TT>PlTerm</TT>). if <TT>is_var</TT>
is <TT>PL_FALSE</TT> then <TT>value</TT> contains the input value of the
argument with the same conventions as for input arguments
(section&#XA0;<A HREF="#Input-arguments">10.3.4</A>). At the exit of the function, if unify is
<TT>PL_TRUE</TT> <TT>value</TT> must contain the value to unify with the same
conventions as for output arguments
(section&#XA0;<A HREF="#Output-arguments">10.3.5</A>).</P><P>For instance, the effective argument <TT>Arg</TT> associated with
<TT>?positive</TT> foreign declaration is handled as follows:</P><UL CLASS="itemize"><LI CLASS="li-itemize">if <TT>Arg</TT> is a variable <TT>is_var</TT> and <TT>unify</TT> are
set to <TT>PL_TRUE</TT> else to <TT>PL_FALSE</TT> and its value is copied in
<TT>value.l</TT>.</LI><LI CLASS="li-itemize">if <TT>Arg</TT> is neither a variable nor an integer a
<TT>type_error(integer, Arg)</TT> is raised.</LI><LI CLASS="li-itemize">if <TT>Arg</TT> is an integer &lt; 0 a
<TT>domain_error(not_less_than_zero, Arg)</TT> is raised.</LI><LI CLASS="li-itemize">otherwise a pointer to the <TT>PlFIOArg</TT> (<TT>PlFIOArg</TT>
<TT>*</TT>) is passed to the C function. If the function returns
<TT>PL_TRUE</TT> and if <TT>unify</TT> is <TT>PL_TRUE</TT> the value stored in
<TT>value.l</TT> is unified with <TT>Arg</TT>.</LI></UL><!--TOC subsubsection Writing non-deterministic C code-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc360">10.3.7</A>&#XA0;&#XA0;Writing non-deterministic C code</H4><!--SEC END --><P>
<A NAME="Writing-non-deterministic-C-code"></A>
The interface allows the user to write non-deterministic C code. When a C
function is non-deterministic, a choice-point is created for this function.
When a failure occurs, if all more recent non-deterministic code are
finished, the function is re-invoked. It is then important to inform Prolog
when there is no more solution (i.e. no more choice) for a non-deterministic
code. So, when no more choices remains the function must remove the
choice-point. The interface increments a counter each time the function is
re-invoked. At the first call this counter is equal to 0. This information
allows the function to detect its first call. When writing non-deterministic
code, it is often useful to record data between consecutive re-invocations of
the function. The interface maintains a buffer to record such an
information. The size of this buffer is given by
<TT>choice_size(N)</TT> when using <TT>foreign/2</TT>
(section&#XA0;<A HREF="#foreign/2-directive">10.3.2</A>). This size is the number of (consecutive)
<TT>PlLong</TT><EM>s</EM> needed by the C function. Inside the function it is
possible to call the following functions/macros:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">int  Pl_Get_Choice_Counter(void)
TYPE Pl_Get_Choice_Buffer (TYPE)
void Pl_No_More_Choice    (void)
</PRE></DD></DL><P>The macro <TT>Pl_Get_Choice_Counter()</TT> returns the value of the
invocation counter (0 at the first call).</P><P>The macro <TT>Pl_Get_Choice_Buffer(<I>TYPE</I>)</TT> returns a
pointer to the buffer (casted to <I><TT>TYPE</TT></I>).</P><P>The function <TT>Pl_No_More_Choice()</TT> deletes the choice point
associated with the function.</P><!--TOC subsubsection Example: input and output arguments-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc361">10.3.8</A>&#XA0;&#XA0;Example: input and output arguments</H4><!--SEC END --><P>
All examples presented here can be found in the <TT>ExamplesC</TT>
sub-directory of the distribution, in the files <TT>examp.pl</TT> (Prolog
part) and <TT>examp_c.c</TT> (C part).</P><P>Let us define a predicate <TT>first_occurrence(A, C, P)</TT> which unifies
<TT>P</TT> with the position (from 0) of the first occurrence of the
character <TT>C</TT> in the atom <TT>A</TT>. The predicate must fail if
<TT>C</TT> does not appear in <TT>A</TT>.</P><P>In the prolog file <TT>examp.pl</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>:- foreign(first_occurrence(+string, +char, -positive)).</TT></DD></DL><P>In the C file <TT>examp_c.c</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">#include &lt;string.h&gt;
#include &lt;gprolog.h&gt;

PlBool
first_occurrence(char *str, PlLong c, PlLong *pos)
{
  char *p;

  p = strchr(str, c);
  if (p == NULL)                    /* C does not appear in A */
    return PL_FALSE;                /* fail */

  *pos = p - str;                   /* set the output argument */
  return PL_TRUE;                   /* succeed */
}
</PRE></DD></DL><P>The compilation produces an executable called <TT>examp</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>% gplc examp.pl examp_c.c</TT></DD></DL><P>Examples of use:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">| ?- first_occurrence(prolog, p, X).

X = 0

| ?- first_occurrence(prolog, k, X).

no

| ?- first_occurrence(prolog, A, X).
{exception: error(instantiation_error,first_occurrence/3)}

| ?- first_occurrence(prolog, 1 ,X).
{exception: error(type_error(character,1),first_occurrence/3)}
</PRE></DD></DL><!--TOC subsubsection Example: non-deterministic code-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc362">10.3.9</A>&#XA0;&#XA0;Example: non-deterministic code</H4><!--SEC END --><P>
We here define a predicate <TT>occurrence(A, C, P)</TT> which unifies
<TT>P</TT> with the position (from 0) of one occurrence of the character
<TT>C</TT> in the atom <TT>A</TT>. The predicate will fail if <TT>C</TT>
does not appear in <TT>A</TT>. The predicate is re-executable on
backtracking. The information that must be recorded between two invocations
of the function is the next starting position in <TT>A</TT> to search for
<TT>C</TT>.</P><P>In the prolog file <TT>examp.pl</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>:- foreign(occurrence(+string, +char, -positive),
[choice_size(1)]).</TT></DD></DL><P>In the C file <TT>examp_c.c</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">#include &lt;string.h&gt;
#include &lt;gprolog.h&gt;

PlBool
occurrence(char *str, PlLong c, PlLong *pos)
{
  char **info_pos;
  char *p;

  info_pos = Pl_Get_Choice_Buffer(char **); /* recover the buffer */

  if (Pl_Get_Choice_Counter() == 0) /* first invocation ? */
    *info_pos = str;

  p = strchr(*info_pos, c);
  if (p == NULL)                    /* c does not appear */
    {
      Pl_No_More_Choice();          /* remove choice-point */
      return PL_FALSE;              /* fail */
    }

  *pos = p - str;                   /* set the output argument */
  *info_pos = p + 1;                /* update next starting pos */
  return PL_TRUE;                   /* succeed */
}
</PRE></DD></DL><P>The compilation produces an executable called <TT>examp</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>% gplc examp.pl examp_c.c</TT></DD></DL><P>Examples of use:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- occurrence(prolog, o, X).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>X = 2 ?</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user presses <TT>;</TT> to compute another solution)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>X = 4 ?</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user presses <TT>;</TT> to compute another solution)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>no</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(no more solution)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- occurrence(prolog, k, X).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>no</TT></TD></TR>
</TABLE></DD></DL><P>In the first example when the second (the last) occurrence is found
(<TT>X=4</TT>) the choice-point remains and the failure is detected only when
another solution is requested (by pressing <TT>;</TT>). It is possible to
improve this behavior by deleting the choice-point when there is no more
occurrence. To do this it is necessary to do one search ahead. The
information stored is the position of the next occurrence. Let us define such
a behavior for the predicate <TT>occurrence2/3</TT>.</P><P>In the prolog file <TT>examp.pl</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>:- foreign(occurrence2(+string, +char, -positive),
[choice_size(1)]).</TT></DD></DL><P>In the C file <TT>examp_c.c</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">#include &lt;string.h&gt;
#include &lt;gprolog.h&gt;

PlBool
occurrence2(char *str, PlLong c, PlLong *pos)
{
  char **info_pos;
  char *p;

  info_pos = Pl_Get_Choice_Buffer(char **); /* recover the buffer */

  if (Pl_Get_Choice_Counter() == 0) /* first invocation ? */
    {
      p = strchr(str, c);
      if (p == NULL)                /* C does not appear at all */
        {
          Pl_No_More_Choice();      /* remove choice-point */
          return PL_FALSE;          /* fail */
        }

      *info_pos = p;
    }
                                    /* info_pos = an occurrence */
  *pos = *info_pos - str;           /* set the output argument */

  p = strchr(*info_pos + 1, c);
  if (p == NULL)                    /* no more occurrence */
    Pl_No_More_Choice();            /* remove choice-point */
  else
    *info_pos = p;                  /* else update next solution */

  return PL_TRUE;                   /* succeed */
}
</PRE></DD></DL><P>Examples of use:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- occurrence2(prolog, l, X).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>X = 3</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user is not prompted since there is no more alternative)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- occurrence2(prolog, o, X).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>X = 2 ?</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user presses <TT>;</TT> to compute another solution)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>X = 4</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user is not prompted since there is no more alternative)</TD></TR>
</TABLE></DD></DL><!--TOC subsubsection Example: input/output arguments-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc363">10.3.10</A>&#XA0;&#XA0;Example: input/output arguments</H4><!--SEC END --><P>
We here define a predicate <TT>char_ascii(Char, Code</TT>) which converts
in both directions the character <TT>Char</TT> and its character-code
<TT>Code</TT>. This predicate is then similar to <TT>char_code/2</TT>
(section&#XA0;<A HREF="#char-code/2">8.19.4</A>).</P><P>In the prolog file <TT>examp.pl</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>:- foreign(char_ascii(?char, ?code)).</TT></DD></DL><P>In the C file <TT>examp_c.c</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">#include &lt;gprolog.h&gt;

PlBool
char_ascii(PlFIOArg *c, PlFIOArg *ascii)
{
  if (!c-&gt;is_var)                  /* Char is not a variable */
    {
      ascii-&gt;unify = PL_TRUE;      /* enforce unif. of Code */
      ascii-&gt;value.l = c-&gt;value.l; /* set Code */
      return PL_TRUE;              /* succeed */
    }

  if (ascii-&gt;is_var)               /* Code is also a variable */
    Pl_Err_Instantiation();        /* emit instantiation_error */

  c-&gt;value.l = ascii-&gt;value.l;     /* set Char */
  return PL_TRUE;                  /* succeed */
}
</PRE></DD></DL><P>If <TT>Char</TT> is instantiated it is necessary to enforce the unification
of <TT>Code</TT> since it could be instantiated. Recall that by default if
an input/output argument is instantiated it will not be unified at the exit
of the function (section&#XA0;<A HREF="#Input/output-arguments">10.3.6</A>). If both <TT>Char</TT> and
<TT>Code</TT> are variables the function raises an
<TT>instantiation_error</TT>. The way to raise Prolog errors is described
later (section&#XA0;<A HREF="#Raising-Prolog-errors">10.5</A>).</P><P>The compilation produces an executable called <TT>examp</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>% gplc examp.pl examp_c.c</TT></DD></DL><P>Examples of use:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">| ?- char_ascii(a, X).

X = 97

| ?- char_ascii(X, 65).

X = 'A'

| ?- char_ascii(a, 12).

no

| ?- char_ascii(X, X).
{exception: error(instantiation_error,char_ascii/2)}

| ?- char_ascii(1, 12).
{exception: error(type_error(character,1),char_ascii/2)}
</PRE></DD></DL><!--TOC subsection Manipulating Prolog terms-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc364">10.4</A>&#XA0;&#XA0;Manipulating Prolog terms</H3><!--SEC END --><P>
<A NAME="Manipulating-Prolog-terms"></A></P><!--TOC subsubsection Introduction-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc365">10.4.1</A>&#XA0;&#XA0;Introduction</H4><!--SEC END --><P>
<A NAME="Introduction:(Manipulating-Prolog-terms)"></A>
In the following we presents a set of functions to manipulate Prolog terms.
For simple foreign terms the functions manipulate simple C types
(section&#XA0;<A HREF="#foreign/2-directive">10.3.2</A>).</P><P>Functions managing lists handle an array of 2 elements (of type
<TT>PlTerm</TT>) containing the terms corresponding to the head and the tail
of the list. For the empty list <TT>NULL</TT> is passed as the array. These
functions require to flatten a list in each sub-list. To simplify the
management of proper lists (i.e. lists terminated by <TT>[]</TT>) a set of
functions is provided that handle the number of elements of the list (an
integer) and an array whose elements (of type <TT>PlTerm</TT>) are the
elements of the list. The caller of these functions must provide the array.</P><P>Functions managing compound terms handle a functor (the principal functor of
the term), an arity <I><TT>N</TT></I> &#X2265; 0 and an array of <I><TT>N</TT></I> elements
(of type <TT>PlTerm</TT>) containing the sub-terms of the compound term.
Since a list is a special case of compound term (functor = <TT>&#X2019;.&#X2019;</TT> and
arity=2) it is possible to use any function managing compound terms to deal
with a list but the error detection is not the same. Indeed many functions
check if the Prolog argument is correct. The name of a read or unify
function checking the Prolog arguments is of the form
<TT><I>Name</I>_Check()</TT>. For each of these functions there is a also
check-free version called <TT><I>Name</I>()</TT>. We then only present the
name of checking functions.</P><!--TOC subsubsection Managing Prolog atoms-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc366">10.4.2</A>&#XA0;&#XA0;Managing Prolog atoms</H4><!--SEC END --><P>Each atom has a unique internal key (an integer) which corresponds to its index in the
GNU Prolog atom table. It is possible to obtain the information about an atom
and to create new atoms using:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">char   *Pl_Atom_Name           (int atom)
int     Pl_Atom_Length         (int atom)
PlBool  Pl_Atom_Needs_Quote    (int atom)
PlBool  Pl_Atom_Needs_Scan     (int atom)
PlBool  Pl_Is_Valid_Atom       (int atom)
int     Pl_Create_Atom         (const char *str)
int     Pl_Create_Allocate_Atom(const char *str)
int     Pl_Find_Atom           (const char *str)
int     Pl_Atom_Char           (char c)
int     Pl_Atom_Nil            (void)
int     Pl_Atom_False          (void)
int     Pl_Atom_True           (void)
int     Pl_Atom_End_Of_File    (void)
</PRE></DD></DL><P>The function <TT>Pl_Atom_Name(atom)</TT> returns the internal string of
<TT>atom</TT> (this string should not be modified). The function
<TT>Pl_Atom_Length(atom)</TT> returns the length (of the name) of
<TT>atom</TT>.</P><P>The function <TT>Pl_Atom_Needs_Scan(atom)</TT> indicates if the canonical
form of <TT>atom</TT> needs to be quoted as done by <TT>writeq/2</TT>
(section&#XA0;<A HREF="#write-term/3">8.14.6</A>). In that case <TT>Pl_Atom_Needs_Scan(atom)</TT>
indicates if this simply comes down to write quotes around the name of
<TT>atom</TT> or if it necessary to scan each character of the name because
there are some non-printable characters (or included quote characters). The
function <TT>Pl_Is_Valid_Atom(atom)</TT> is true only if <TT>atom</TT> is the
internal key of an existing atom.</P><P>The function <TT>Pl_Create_Atom(str)</TT> adds a new atom whose name is the
content of <TT>str</TT> to the system and returns its internal key. If the
atom already exists its key is simply returned. The string <TT>str</TT>
passed to the function should not be modified later. The function
<TT>Pl_Create_Allocate_Atom(str)</TT> is provided when this condition cannot
be ensured. It simply makes a dynamic copy of <TT>str</TT>
(using <TT>strdup(3)</TT>).</P><P>The function <TT>Pl_Find_Atom(str)</TT> returns the internal key of the
atom whose name is <TT>str</TT> or <TT>-1</TT> if does not exist.</P><P>All atoms corresponding to a single character already exist and their
key can be obtained via the function <TT>Pl_Atom_Char</TT>. For
instance <TT>Pl_Atom_Char(&#X2019;.&#X2019;)</TT> is the atom associated with
<TT>&#X2019;.&#X2019;</TT> (this atom is the functor of lists). The other functions return
the internal key of frequently used atoms: <TT>[]</TT>,
<TT>false</TT>, <TT>true</TT> and <TT>end_of_file</TT>.</P><!--TOC subsubsection Reading Prolog terms-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc367">10.4.3</A>&#XA0;&#XA0;Reading Prolog terms</H4><!--SEC END --><P>
<A NAME="Reading-Prolog-terms"></A>
The name of all functions presented here are of the form
<TT>Pl_Rd_<I>Name</I>_Check()</TT>. They all check the validity of the
Prolog term to read emitting appropriate errors if necessary. Each function
has a check-free version called <TT>Pl_Rd_<I>Name</I>()</TT>.</P><P><B>Simple foreign types</B>: for each simple foreign type
(section&#XA0;<A HREF="#foreign/2-directive">10.3.2</A>) there is a read function (used by the
interface when an input argument is provided):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">PlLong  Pl_Rd_Integer_Check  (PlTerm term)
PlLong  Pl_Rd_Positive_Check (PlTerm term)
double  Pl_Rd_Float_Check    (PlTerm term)
double  Pl_Rd_Number_Check   (PlTerm term)
int     Pl_Rd_Atom_Check     (PlTerm term)
int     Pl_Rd_Boolean_Check  (PlTerm term)
int     Pl_Rd_Char_Check     (PlTerm term)
int     Pl_Rd_In_Char_Check  (PlTerm term)
int     Pl_Rd_Code_Check     (PlTerm term)
int     Pl_Rd_In_Code_Check  (PlTerm term)
int     Pl_Rd_Byte_Check     (PlTerm term)
int     Pl_Rd_In_Byte_Check  (PlTerm term)
char   *Pl_Rd_String_Check   (PlTerm term)
char   *Pl_Rd_Chars_Check    (PlTerm term)
char   *Pl_Rd_Codes_Check    (PlTerm term)
int     Pl_Rd_Chars_Str_Check(PlTerm term, char *str)
int     Pl_Rd_Codes_Str_Check(PlTerm term, char *str)
</PRE></DD></DL><P>All functions returning a C string (<TT>char *</TT>) use a same buffer. The
function <TT>Pl_Rd_Chars_Str_Check()</TT> is similar to
<TT>Pl_Rd_Chars_Check()</TT> but accepts as argument a string to store the
result and returns the length of that string (which is also the length of
the Prolog list). Similarly for <TT>Pl_Rd_Codes_Str_Check()</TT>.</P><P><B>Complex terms</B>: the following functions return the sub-arguments
(terms) of complex terms as an array of <TT>PlTerm</TT> except
<TT>Pl_Rd_Proper_List_Check()</TT> which returns the size of the list read
(and initializes the array <TT>element</TT>). Refer to the introduction of
this section for more information about the arguments of complex functions
(section&#XA0;<A HREF="#Introduction:(Manipulating-Prolog-terms)">10.4.1</A>).</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">int     Pl_Rd_Proper_List_Check(PlTerm term, PlTerm *arg)
PlTerm *Pl_Rd_List_Check       (PlTerm term)
PlTerm *Pl_Rd_Compound_Check   (PlTerm term, int *functor, int *arity)
PlTerm *Pl_Rd_Callable_Check   (PlTerm term, int *functor, int *arity)
</PRE></DD></DL><!--TOC subsubsection Unifying Prolog terms-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc368">10.4.4</A>&#XA0;&#XA0;Unifying Prolog terms</H4><!--SEC END --><P>
The name of all functions presented here are of the form
<TT>Pl_Un_<I>Name</I>_Check()</TT>. They all check the validity of the
Prolog term to unify emitting appropriate errors if necessary. Each function
has a check-free version called <TT>Pl_Un_<I>Name</I>()</TT>.</P><P><B>Simple foreign types</B>: for each simple foreign type
(section&#XA0;<A HREF="#foreign/2-directive">10.3.2</A>) there is an unify function (used by the
interface when an output argument is provided):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">PlBool Pl_Un_Integer_Check (PlLong n,          PlTerm term)
PlBool Pl_Un_Positive_Check(PlLong n,          PlTerm term)
PlBool Pl_Un_Float_Check   (double n,        PlTerm term)
PlBool Pl_Un_Number_Check  (double n,        PlTerm term)
PlBool Pl_Un_Atom_Check    (int atom,        PlTerm term)
PlBool Pl_Un_Boolean_Check (int b,           PlTerm term)
PlBool Pl_Un_Char_Check    (int c,           PlTerm term)
PlBool Pl_Un_In_Char_Check (int c,           PlTerm term)
PlBool Pl_Un_Code_Check    (int c,           PlTerm term)
PlBool Pl_Un_In_Code_Check (int c,           PlTerm term)
PlBool Pl_Un_Byte_Check    (int b,           PlTerm term)
PlBool Pl_Un_In_Byte_Check (int b,           PlTerm term)
PlBool Pl_Un_String_Check  (const char *str, PlTerm term)
PlBool Pl_Un_Chars_Check   (const char *str, PlTerm term)
PlBool Pl_Un_Codes_Check   (const char *str, PlTerm term)
</PRE></DD></DL><P>The function <TT>Pl_Un_Number_Check(n, term)</TT> unifies <TT>term</TT> with
an integer if <TT>n</TT> is an integer, with a floating point number
otherwise. The function <TT>Pl_Un_String_Check(str, term)</TT> creates the
atom corresponding to <TT>str</TT> and then unifies term with it (same as
<TT>Pl_Un_Atom_Check(Pl_Create_Allocate_Atom(str), term)</TT>).</P><P>The following functions perform a general unification (between 2 terms). The
second one performs a occurs-check test (while the first one does not).</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">PlBool Pl_Unif(PlTerm term1, PlTerm term2)
PlBool Pl_Unif_With_Occurs_Check(PlTerm term1, PlTerm term2)
</PRE></DD></DL><P><B>Complex terms</B>: the following functions accept the sub-arguments
(terms) of complex terms as an array of <TT>PlTerm</TT>. Refer to the
introduction of this section for more information about the arguments of
complex functions (section&#XA0;<A HREF="#Introduction:(Manipulating-Prolog-terms)">10.4.1</A>).</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">PlBool Pl_Un_Proper_List_Check(int size, PlTerm *arg, PlTerm term)
PlBool Pl_Un_List_Check       (PlTerm *arg, PlTerm term)
PlBool Pl_Un_Compound_Check   (int functor, int arity, PlTerm *arg,
                               PlTerm term)
PlBool Pl_Un_Callable_Check   (int functor, int arity, PlTerm *arg,
                               PlTerm term)
</PRE></DD></DL><P>All these functions check the type of the term to unify and return the
result of the unification. Generally if an unification fails the C function
returns <TT>PL_FALSE</TT> to enforce a failure. However if there are several
arguments to unify and if an unification fails then the C function returns
<TT>PL_FALSE</TT> and the type of other arguments has not been checked.
Normally all error cases are tested before doing any work to be sure that
the predicate fails/succeeds only if no error condition is satisfied. So a
good method is to check the validity of all arguments to unify and later
to do the unification (using check-free functions). Obviously if there is
only one to unify it is more efficient to use a unify function checking the
argument. For the other cases the interface provides a set of functions to
check the type of a term.</P><P><B>Simple foreign types</B>: for each simple foreign type
(section&#XA0;<A HREF="#foreign/2-directive">10.3.2</A>) there is check-for-unification function (used
by the interface when an output argument is provided):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">void Pl_Check_For_Un_Integer (PlTerm term)
void Pl_Check_For_Un_Positive(PlTerm term)
void Pl_Check_For_Un_Float   (PlTerm term)
void Pl_Check_For_Un_Number  (PlTerm term)
void Pl_Check_For_Un_Atom    (PlTerm term)
void Pl_Check_For_Un_Boolean (PlTerm term)
void Pl_Check_For_Un_Char    (PlTerm term)
void Pl_Check_For_Un_In_Char (PlTerm term)
void Pl_Check_For_Un_Code    (PlTerm term)
void Pl_Check_For_Un_In_Code (PlTerm term)
void Pl_Check_For_Un_Byte    (PlTerm term)
void Pl_Check_For_Un_In_Byte (PlTerm term)
void Pl_Check_For_Un_String  (PlTerm term)
void Pl_Check_For_Un_Chars   (PlTerm term)
void Pl_Check_For_Un_Codes   (PlTerm term)
</PRE></DD></DL><P><B>Complex terms</B>: the following functions check the validity of
complex terms:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">void Pl_Check_For_Un_List    (PlTerm term)
void Pl_Check_For_Un_Compound(PlTerm term)
void Pl_Check_For_Un_Callable(PlTerm term)
void Pl_Check_For_Un_Variable(PlTerm term)
</PRE></DD></DL><P>The function <TT>Pl_Check_For_Un_List(term)</TT> checks if <TT>term</TT> can
be unified with a list. This test is done for the entire list (not only for
the functor/arity of <TT>term</TT> but also recursively on the tail of the
list). The function <TT>Pl_Check_For_Un_Variable(term)</TT> ensures that
<TT>term</TT> is not currently instantiated. These functions can be defined
using functions to test the type of a Prolog term (section&#XA0;<A HREF="#Testing-the-type-of-Prolog-terms">10.4.6</A>) and functions to raise Prolog errors (section&#XA0;<A HREF="#Raising-Prolog-errors">10.5</A>). For instance <TT>Pl_Check_For_Un_List(term)</TT> is defined
as follows:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">void Pl_Check_For_Un_List(PlTerm term)
{
 if (!Pl_Builtin_List_Or_Partial_List(term))
     Pl_Err_Type(type_list, term);
}
</PRE></DD></DL><!--TOC subsubsection Creating Prolog terms-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc369">10.4.5</A>&#XA0;&#XA0;Creating Prolog terms</H4><!--SEC END --><P>
<A NAME="Creating-Prolog-terms"></A>
These functions are provided to creates Prolog terms. Each function returns
a <TT>PlTerm</TT> containing the created term.</P><P><B>Simple foreign types</B>: for each simple foreign type
(section&#XA0;<A HREF="#foreign/2-directive">10.3.2</A>) there is a creation function:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">PlTerm Pl_Mk_Integer (PlLong n)
PlTerm Pl_Mk_Positive(PlLong n)
PlTerm Pl_Mk_Float   (double n)
PlTerm Pl_Mk_Number  (double n)
PlTerm Pl_Mk_Atom    (int atom)
PlTerm Pl_Mk_Boolean (int b)
PlTerm Pl_Mk_Char    (int c)
PlTerm Pl_Mk_In_Char (int c)
PlTerm Pl_Mk_Code    (int c)
PlTerm Pl_Mk_In_Code (int c)
PlTerm Pl_Mk_Byte    (int b)
PlTerm Pl_Mk_In_Byte (int b)
PlTerm Pl_Mk_String  (const char *str)
PlTerm Pl_Mk_Chars   (const char *str)
PlTerm Pl_Mk_Codes   (const char *str)
</PRE></DD></DL><P>The function <TT>Pl_Mk_Number(n, term)</TT> initializes <TT>term</TT> with an
integer if <TT>n</TT> is an integer, with a floating point number otherwise.
The function <TT>Pl_Mk_String(str)</TT> first creates an atom corresponding to
<TT>str</TT> and then returns that Prolog atom (i.e. equivalent to
<TT>Pl_Mk_Atom(Pl_Create_Allocate_Atom(str))</TT>).</P><P><B>Complex terms</B>: the following functions accept the sub-arguments
(terms) of complex terms as an array of <TT>PlTerm</TT>. Refer to the
introduction of this section for more information about the arguments of
complex functions (section&#XA0;<A HREF="#Introduction:(Manipulating-Prolog-terms)">10.4.1</A>).</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">PlTerm Pl_Mk_Proper_List(int size, const PlTerm *arg)
PlTerm Pl_Mk_List       (PlTerm *arg)
PlTerm Pl_Mk_Compound   (int functor, int arity, const PlTerm *arg)
PlTerm Pl_Mk_Callable   (int functor, int arity, const PlTerm *arg)
</PRE></DD></DL><!--TOC subsubsection Testing the type of Prolog terms-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc370">10.4.6</A>&#XA0;&#XA0;Testing the type of Prolog terms</H4><!--SEC END --><P>
<A NAME="Testing-the-type-of-Prolog-terms"></A>
The following functions test the type of a Prolog term. Each function
corresponds to a type testing built-in predicate (section&#XA0;<A HREF="#var/1">8.1.1</A>).</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">PlBool Pl_Builtin_Var                 (PlTerm term)
PlBool Pl_Builtin_Non_Var             (PlTerm term)
PlBool Pl_Builtin_Atom                (PlTerm term)
PlBool Pl_Builtin_Integer             (PlTerm term)
PlBool Pl_Builtin_Float               (PlTerm term)
PlBool Pl_Builtin_Number              (PlTerm term)
PlBool Pl_Builtin_Atomic              (PlTerm term)
PlBool Pl_Builtin_Compound            (PlTerm term)
PlBool Pl_Builtin_Callable            (PlTerm term)
PlBool Pl_Builtin_List                (PlTerm term)
PlBool Pl_Builtin_Partial_List        (PlTerm term)
PlBool Pl_Builtin_List_Or_Partial_List(PlTerm term)
PlBool Pl_Builtin_Fd_Var              (PlTerm term)
PlBool Pl_Builtin_Non_Fd_Var          (PlTerm term)
PlBool Pl_Builtin_Generic_Var         (PlTerm term)
PlBool Pl_Builtin_Non_Generic_Var     (PlTerm term)
int    Pl_Type_Of_Term                (PlTerm term)
PlLong   Pl_List_Length                 (PlTerm list)
</PRE></DD></DL><P>The function <TT>Pl_Type_Of_Term(term)</TT> returns the type of
<TT>term</TT>, the following constants can be used to test this type (e.g.
in a <TT>switch</TT> instruction):</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>PL_PLV</TT>: Prolog variable.</LI><LI CLASS="li-itemize"><TT>PL_FDV</TT>: finite domain variable.</LI><LI CLASS="li-itemize"><TT>PL_INT</TT>: integer.</LI><LI CLASS="li-itemize"><TT>PL_FLT</TT>: floating point number.</LI><LI CLASS="li-itemize"><TT>PL_ATM</TT>: atom.</LI><LI CLASS="li-itemize"><TT>PL_LST</TT>: list.</LI><LI CLASS="li-itemize"><TT>PL_STC</TT>: structure
</LI></UL><P>The tag <TT>PL_LST</TT> means a term whose principal functor is <TT>&#X2019;.&#X2019;</TT>
and whose arity is 2 (recall that the empty list is the atom <TT>[]</TT>).
The tag <TT>PL_STC</TT> means any other compound term.</P><P>The function <TT>Pl_List_Length(list)</TT> returns the number of elements of
the <TT>list</TT> (<TT>0</TT> for the empty list). If list is not a list
this function returns <TT>-1</TT>.</P><!--TOC subsubsection Comparing Prolog terms-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc371">10.4.7</A>&#XA0;&#XA0;Comparing Prolog terms</H4><!--SEC END --><P>The following functions compares Prolog terms. Each function corresponds to
a comparison built-in predicate (section&#XA0;<A HREF="#(==)/2">8.3.2</A>).</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">PlBool Pl_Builtin_Term_Eq (PlTerm term1, PlTerm term2)
PlBool Pl_Builtin_Term_Neq(PlTerm term1, PlTerm term2)
PlBool Pl_Builtin_Term_Lt (PlTerm term1, PlTerm term2)
PlBool Pl_Builtin_Term_Lte(PlTerm term1, PlTerm term2)
PlBool Pl_Builtin_Term_Gt (PlTerm term1, PlTerm term2)
PlBool Pl_Builtin_Term_Gte(PlTerm term1, PlTerm term2)
</PRE></DD></DL><P>All these functions are based on a general comparison function returning a
negative integer if <TT>term1</TT> is less than <TT>term2</TT>, 0 if they
are equal and a positive integer otherwise:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">PlLong Term_Compare(PlTerm term1, PlTerm term2)
</PRE></DD></DL><P>Finally, the following function gives an access to the <TT>compare/3</TT>
built-in (section&#XA0;<A HREF="#compare/3">8.3.3</A>) unifying <TT>cmp</TT> with the
atom <TT>&lt;</TT>, <TT>=</TT> or <TT>&gt;</TT> depending on the result of
the comparison of <TT>term1</TT> and <TT>term2</TT>.</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">PlBool Pl_Builtin_Compare(PlTerm cmp, PlTerm term1, PlTerm term2)
</PRE></DD></DL><!--TOC subsubsection Term processing-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc372">10.4.8</A>&#XA0;&#XA0;Term processing</H4><!--SEC END --><P>The following functions give access to the built-in predicates:
<TT>functor/3</TT> (section&#XA0;<A HREF="#functor/3">8.4.1</A>), <TT>arg/3</TT> (section&#XA0;<A HREF="#arg/3">8.4.2</A>)
and <TT>(=..)/2</TT> (section&#XA0;<A HREF="#(=..)/2">8.4.3</A>).</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">PlBool Pl_Builtin_Functor(PlTerm term, PlTerm functor, PlTerm arity)

PlBool Pl_Builtin_Arg(PlTerm arg_no, PlTerm term, PlTerm sub_term)

PlBool Pl_Builtin_Univ(PlTerm term, PlTerm list)
</PRE></DD></DL><P>The following functions make a copy of a Prolog term:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">void Pl_Copy_Term           (PlTerm *dst_term, const PlTerm *src_term)
void Pl_Copy_Contiguous_Term(PlTerm *dst_term, const PlTerm *src_term)
int  Pl_Term_Size           (PlTerm term)
</PRE></DD></DL><P>The function <TT>Pl_Copy_Term(dst_term, src_term)</TT> makes a copy of the
term located at <TT>src_term</TT> and stores it from the address given by
<TT>dst_term</TT>. The result is a contiguous term. If it can be ensured
that the source term is a contiguous term (i.e. result of a previous copy)
the function <TT>Pl_Copy_Contiguous_Term()</TT> can be used instead (it is
faster). In any case, sufficient space should be available for the copy
(i.e. from <TT>dst_term</TT>). The function <TT>Pl_Term_Size(term)</TT>
returns the number of <TT>PlTerm</TT> needed by <TT>term</TT>.</P><!--TOC subsubsection Comparing and evaluating arithmetic expressions-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc373">10.4.9</A>&#XA0;&#XA0;Comparing and evaluating arithmetic expressions</H4><!--SEC END --><P>
The following functions compare arithmetic expressions. Each function
corresponds to a comparison built-in predicate (section&#XA0;<A HREF="#(=:=)/2">8.6.3</A>).</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">PlBool Pl_Builtin_Eq (PlTerm expr1, PlTerm expr2)
PlBool Pl_Builtin_Neq(PlTerm expr1, PlTerm expr2)
PlBool Pl_Builtin_Lt (PlTerm expr1, PlTerm expr2)
PlBool Pl_Builtin_Lte(PlTerm expr1, PlTerm expr2)
PlBool Pl_Builtin_Gt (PlTerm expr1, PlTerm expr2)
PlBool Pl_Builtin_Gte(PlTerm expr1, PlTerm expr2)
</PRE></DD></DL><P>The following function evaluates the expression <TT>expr</TT> and stores its
result as a Prolog number (integer or floating point number) in
<TT>result</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">void Pl_Math_Evaluate(PlTerm expr, PlTerm *result)
</PRE></DD></DL><P>This function can be followed by a read function (section&#XA0;<A HREF="#Reading-Prolog-terms">10.4.3</A>)
to obtain the result.</P><!--TOC subsection Raising Prolog errors-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc374">10.5</A>&#XA0;&#XA0;Raising Prolog errors</H3><!--SEC END --><P>
<A NAME="Raising-Prolog-errors"></A>
The following functions allows a C function to raise a Prolog error. Refer
to the section concerning Prolog errors for more information about the
effect of raising an error (section&#XA0;<A HREF="#Errors">6.3</A>).</P><!--TOC subsubsection Managing the error context-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc375">10.5.1</A>&#XA0;&#XA0;Managing the error context</H4><!--SEC END --><P>
When one of the following error function is invoked it refers to the
implicit error context (section&#XA0;<A HREF="#General-format-and-error-context">6.3.1</A>). This
context indicates the name and the arity of the concerned predicate. When
using a <TT>foreign/2</TT> declaration this context is set by default to the
name and arity of the associated Prolog predicate. This can be controlled
using the <TT>bip_name</TT> option (section&#XA0;<A HREF="#foreign/2-directive">10.3.2</A>). In any
case, the following functions can also be used to modify this context:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">void Pl_Set_C_Bip_Name  (const char *functor, int arity)
void Pl_Unset_C_Bip_Name(void)
</PRE></DD></DL><P>The function <TT>Pl_Set_C_Bip_Name(functor, arity)</TT> initializes the
context of the error with <TT>functor</TT> and <TT>arity</TT> (if
<TT>arity</TT>&lt;0 only <TT>functor</TT> is significant). The function
<TT>Pl_Unset_C_Bip_Name()</TT> removes such an initialization (the context
is then reset to the last <TT>Functor</TT>/<TT>Arity</TT> set by a call to
<TT>set_bip_name/2</TT> (section&#XA0;<A HREF="#set-bip-name/2">8.22.3</A>). This is useful when
writing a C routine to define a context for errors occurring in this routine
and, before exiting to restore the previous context.</P><!--TOC subsubsection Instantiation error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc376">10.5.2</A>&#XA0;&#XA0;Instantiation error</H4><!--SEC END --><P>
The following function raises an instantiation error (section&#XA0;<A HREF="#Instantiation-error">6.3.2</A>):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>void Pl_Err_Instantiation(void)</TT></DD></DL><!--TOC subsubsection Uninstantiation error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc377">10.5.3</A>&#XA0;&#XA0;Uninstantiation error</H4><!--SEC END --><P>
The following function raises an uninstantiation error (section&#XA0;<A HREF="#Uninstantiation-error">6.3.3</A>):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>void Pl_Err_Uninstantiation( PlTerm culprit)</TT></DD></DL><!--TOC subsubsection Type error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc378">10.5.4</A>&#XA0;&#XA0;Type error</H4><!--SEC END --><P>
The following function raises a type error (section&#XA0;<A HREF="#Type-error">6.3.4</A>):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>void Pl_Err_Type(int atom_type, PlTerm culprit)</TT></DD></DL><P><TT>atom_type</TT> is (the internal key of) the atom associated with the
expected type. For each type name <I><TT>T</TT></I> there is a
corresponding predefined atom stored in a global variable whose name is of
the form <TT>pl_type_<I>T</I></TT>. <TT>culprit</TT> is the argument which
caused the error.</P><P><B>Example</B>: <TT>x</TT> is an atom while an integer was expected:
<TT>Pl_Err_Type(pl_type_integer, x)</TT>.</P><!--TOC subsubsection Domain error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc379">10.5.5</A>&#XA0;&#XA0;Domain error</H4><!--SEC END --><P>
The following function raises a domain error (section&#XA0;<A HREF="#Domain-error">6.3.5</A>):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>void Pl_Err_Domain(int atom_domain, PlTerm culprit)</TT></DD></DL><P><TT>atom_domain</TT> is (the internal key of) the atom associated with the
expected domain. For each domain name <I><TT>D</TT></I> there is a
corresponding predefined atom stored in a global variable whose name is of
the form <TT>domain_<I>D</I></TT>. <TT>culprit</TT> is the argument which
caused the error.</P><P><B>Example</B>: <TT>x</TT> is &lt; 0 but should be &#X2265; 0:
<TT>Pl_Err_Domain(pl_domain_not_less_than_zero, x)</TT>.</P><!--TOC subsubsection Existence error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc380">10.5.6</A>&#XA0;&#XA0;Existence error</H4><!--SEC END --><P>
The following function raises an existence error (section&#XA0;<A HREF="#Existence-error">6.3.6</A>):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>void Pl_Err_Existence(int atom_object, PlTerm culprit)</TT></DD></DL><P><TT>atom_object</TT> is (the internal key of) the atom associated with the
type of the object. For each object name <I><TT>O</TT></I> there is a
corresponding predefined atom stored in a global variable whose name is of
the form <TT>pl_existence_<I>O</I></TT>. <TT>culprit</TT> is the argument
which caused the error.</P><P><B>Example</B>: <TT>x</TT> does not refer to an existing source:
<TT>Pl_Err_Existence(pl_existence_source_sink, x)</TT>.</P><!--TOC subsubsection Permission error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc381">10.5.7</A>&#XA0;&#XA0;Permission error</H4><!--SEC END --><P>
The following function raises a permission error (section&#XA0;<A HREF="#Permission-error">6.3.7</A>):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>void Pl_Err_Permission(int atom_operation, int atom_permission,
PlTerm culprit)</TT></DD></DL><P><TT>atom_operation</TT> is (the internal key of) the atom associated with the
operation which caused the error. For each operation name
<I><TT>O</TT></I> there is a corresponding predefined atom stored in a
global variable whose name is of the form
<TT>pl_permission_operation_<I>O</I></TT>. <TT>atom_permission</TT> is
(the internal key of) the atom associated with the tried permission. For each
permission name <I><TT>P</TT></I> there is a corresponding predefined atom
stored in a global variable whose name is of the form
<TT>pl_permission_type_<I>P</I></TT>. <TT>culprit</TT> is the argument
which caused the error.</P><P><B>Example</B>: reading from an output stream <TT>x</TT>:
<TT>Pl_Err_Permission(pl_permission_operation_input,<BR>
pl_permission_type_stream, x)</TT>.</P><!--TOC subsubsection Representation error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc382">10.5.8</A>&#XA0;&#XA0;Representation error</H4><!--SEC END --><P>
The following function raises a representation error (section&#XA0;<A HREF="#Representation-error">6.3.8</A>):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>void Pl_Err_Representation(int atom_limit)</TT></DD></DL><P><TT>atom_limit</TT> is (the internal key of) the atom associated with the
reached limit. For each limit name <I><TT>L</TT></I> there is a
corresponding predefined atom stored in a global variable whose name is of
the form <TT>pl_representation_<I>L</I></TT>.</P><P><B>Example</B>: an arity too big occurs:
<TT>Pl_Err_Representation(pl_representation_max_arity)</TT>.</P><!--TOC subsubsection Evaluation error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc383">10.5.9</A>&#XA0;&#XA0;Evaluation error</H4><!--SEC END --><P>
The following function raises an evaluation error (section&#XA0;<A HREF="#Evaluation-error">6.3.9</A>):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>void Pl_Err_Evaluation(int atom_error)</TT></DD></DL><P><TT>atom_error</TT> is (the internal key of) the atom associated with the
error. For each evaluation error name <I><TT>E</TT></I> there is a
corresponding predefined atom stored in a global variable whose name is of
the form <TT>pl_evaluation_<I>E</I></TT>.</P><P><B>Example</B>: a division by zero occurs:
<TT>Pl_Err_Evaluation(pl_evaluation_zero_divisor)</TT>.</P><!--TOC subsubsection Resource error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc384">10.5.10</A>&#XA0;&#XA0;Resource error</H4><!--SEC END --><P>
The following function raises a resource error (section&#XA0;<A HREF="#Resource-error">6.3.10</A>):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>void Pl_Err_Resource(int atom_resource)</TT></DD></DL><P><TT>atom_resource</TT> is (the internal key of) the atom associated with the
resource. For each resource error name <I><TT>R</TT></I> there is a
corresponding predefined atom stored in a global variable whose name is of
the form <TT>pl_resource_<I>R</I></TT>.</P><P><B>Example</B>: too many open streams:
<TT>Pl_Err_Resource(pl_resource_too_many_open_streams)</TT>.</P><!--TOC subsubsection Syntax error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc385">10.5.11</A>&#XA0;&#XA0;Syntax error</H4><!--SEC END --><P>
The following function raises a syntax error (section&#XA0;<A HREF="#Syntax-error">6.3.11</A>):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>void Pl_Err_Syntax(int atom_error)</TT></DD></DL><P><TT>atom_error</TT> is (the internal key of) the atom associated with the
error. There is no predefined syntax error atoms.</P><P><B>Example</B>: a <TT>/</TT> is expected:
<TT>Pl_Err_Syntax(Pl_Create_Atom("/ expected"))</TT>.</P><P>The following function emits a syntax error according to the value of the
<TT>syntax_error</TT> Prolog flag (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>). This
function can then return (if the value of the flag is either
<TT>warning</TT> or <TT>fail</TT>). In that case the calling function should
fail (e.g. returning <TT>PL_FALSE</TT>). This function accepts a file name (the
empty string C <TT>""</TT> can be passed), a line and column number and an
error message string. Using this function makes it possible to further call
the built-in predicate <TT>syntax_error_info/4</TT>
(section&#XA0;<A HREF="#syntax-error-info/4">8.14.4</A>):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>void Pl_Emit_Syntax_Error(char *file_name, int line, int column,
char *message)</TT></DD></DL><P><B>Example</B>: a <TT>/</TT> is expected:
<TT>Pl_Emit_Syntax_Error("data", 10, 30, "/ expected")</TT>.</P><!--TOC subsubsection System error-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc386">10.5.12</A>&#XA0;&#XA0;System error</H4><!--SEC END --><P>
The following function raises a system error (4.3.11, page *):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>void Pl_Err_System(int atom_error)</TT></DD></DL><P><TT>atom_error</TT> is (the internal key of) the atom associated with the
error. There is no predefined system error atoms.</P><P><B>Example</B>: an invalid pathname is given:
<TT>Pl_Err_System(Pl_Create_Atom("invalid path name"))</TT>.</P><P>The following function emits a system error associated with an operating
system error according to the value of the <TT>os_error</TT>
Prolog flag (section&#XA0;<A HREF="#set-prolog-flag/2">8.22.1</A>). This function can then return (if the value of the flag is either <TT>warning</TT> or <TT>fail</TT>).
In that case the calling function should fail (e.g. returning
<TT>PL_FALSE</TT>).</P><P>The following function uses the value of the <TT>errno</TT> C library
variable (basically it calls <TT>Pl_Err_System</TT> with the result
of <TT>strerror(errno)</TT>).</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>void Pl_Os_Error(void)</TT></DD></DL><P><B>Example</B>: if a call to the C Unix function <TT>chdir(2)</TT> returns
<TT>-1</TT> then call <TT>Os_Error()</TT>.</P><!--TOC subsection Calling Prolog from C-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc387">10.6</A>&#XA0;&#XA0;Calling Prolog from C</H3><!--SEC END --><!--TOC subsubsection Introduction-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc388">10.6.1</A>&#XA0;&#XA0;Introduction</H4><!--SEC END --><P>
The following functions allows a C function to call a Prolog predicate:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">void   Pl_Query_Begin        (PlBool recoverable)
int    Pl_Query_Call         (int functor, int arity, PlTerm *arg)
int    Pl_Query_Next_Solution(void)
void   Pl_Query_End          (int op)
PlTerm Pl_Get_Exception      (void)
void   Pl_Exec_Continuation  (int functor, int arity, PlTerm *arg)
</PRE></DD></DL><P>The invocation of a Prolog predicate should be done as follows:</P><UL CLASS="itemize"><LI CLASS="li-itemize">open a query using <TT>Pl_Query_Begin()</TT></LI><LI CLASS="li-itemize">compute the first solution using <TT>Pl_Query_Call()</TT></LI><LI CLASS="li-itemize">eventually compute next solutions using
<TT>Pl_Query_Next_Solution()</TT></LI><LI CLASS="li-itemize">close the query using <TT>Pl_Query_End()</TT></LI></UL><P>The function <TT>Pl_Query_Begin(recoverable)</TT> is used to initialize a query. The argument <TT>recoverable</TT> shall be set to
<TT>PL_TRUE</TT> if the user wants to recover, at the end of the query, the
memory space consumed by the query (in that case an additional choice-point
is created). All terms created in the heap, e.g. using <TT>Pl_Mk_...</TT>
family functions (section&#XA0;<A HREF="#Creating-Prolog-terms">10.4.5</A>), after the invocation of
<TT>Pl_Query_Begin()</TT> can be recovered when calling
<TT>Pl_Query_End(PL_TRUE)</TT> (see below).</P><P>The function <TT>Pl_Query_Call(functor, arity, arg)</TT> calls a predicate
passing arguments. It is then used to compute the first solution. The
arguments <TT>functor</TT>, <TT>arity</TT> and <TT>arg</TT> are similar to
those of the functions handling complex terms
(section&#XA0;<A HREF="#Introduction:(Manipulating-Prolog-terms)">10.4.1</A>). This function returns:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>PL_FAILURE</TT> (a constant equal to <TT>PL_FALSE</TT>, i.e. 0) if
the query fails.</LI><LI CLASS="li-itemize"><TT>PL_SUCCESS</TT> (a constant equal to <TT>PL_TRUE</TT>, i.e. 1) in
case of success. In that case the argument array <TT>arg</TT> can be used to
obtain the unification performed by the query.</LI><LI CLASS="li-itemize"><TT>PL_EXCEPTION</TT> (a constant equal to 2). In that case function
<TT>Pl_Get_Exception()</TT> can be used to obtained the exceptional term
raised by <TT>throw/1</TT> (section&#XA0;<A HREF="#catch/3">7.2.4</A>).</LI></UL><P>The function <TT>Pl_Query_Next_Solution()</TT> is used to compute a new
solution. It must be only used if the result of the previous solution was
<TT>PL_SUCCESS</TT>. This functions returns the same kind of values as
<TT>Pl_Query_Call()</TT> (see above).</P><P>The function <TT>Pl_Query_End(op)</TT> is used to finish a query. This
function mainly manages the remaining alternatives of the query. However,
even if the query has no alternatives this function must be used to
correctly finish the query. The value of <TT>op</TT> is:</P><UL CLASS="itemize"><LI CLASS="li-itemize"><TT>PL_RECOVER</TT>: to recover the memory space consumed by the
query. After that the state of Prolog stacks is exactly the same as before
opening the query. To use this option the query must have been initialized
specifying <TT>PL_TRUE</TT> for <TT>recoverable</TT> (see above).</LI><LI CLASS="li-itemize"><TT>PL_CUT</TT>: to cut remaining alternatives. The effect of this
option is similar to a cut after the query.</LI><LI CLASS="li-itemize"><TT>PL_KEEP_FOR_PROLOG</TT>: to keep the alternatives for Prolog.
This is useful when the query was invoked in a foreign C function. In that
case, when the predicate corresponding to the C foreign function is invoked
a query is executed and the remaining alternatives are then available as
alternatives of that predicate.</LI></UL><P>Note that several queries can be nested since a stack of queries is
maintained. For instance, it is possible to call a query and before
terminating it to call another query. In that case the first execution of
<TT>Pl_Query_End()</TT> will finish the second query (i.e. the inner) and
the next execution of <TT>Pl_Query_End()</TT> will finish the first query.</P><P>Finally, the function <TT>Pl_Exec_Continuation(functor, arity,
arg)</TT> replaces the current calculus by the execution of the specified
predicate. The arguments <TT>functor</TT>, <TT>arity</TT> and
<TT>arg</TT> are similar to those of the functions handling complex
terms (section&#XA0;<A HREF="#Introduction:(Manipulating-Prolog-terms)">10.4.1</A>).</P><!--TOC subsubsection Example: <TT>my_call/1</TT> - a <TT>call/1</TT> clone-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc389">10.6.2</A>&#XA0;&#XA0;Example: <TT>my_call/1</TT> - a <TT>call/1</TT> clone</H4><!--SEC END --><P>We here define a predicate <TT>my_call(Goal)</TT> which acts like
<TT>call(Goal)</TT> except that we do not handle exceptions (if an exception
occurs the goal simply fails):</P><P>In the prolog file <TT>examp.pl</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>:- foreign(my_call(term)).</TT></DD></DL><P>In the C file <TT>examp_c.c</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">#include &lt;string.h&gt;
#include &lt;gprolog.h&gt;

PlBool
my_call(PlTerm goal)

{
  PlTerm *arg;
  int functor, arity;
  int result;

  arg = Pl_Rd_Callable_Check(goal, &amp;functor, &amp;arity);
  Pl_Query_Begin(PL_FALSE);
  result = Pl_Query_Call(functor, arity, arg);
  Pl_Query_End(PL_KEEP_FOR_PROLOG);
  return (result == PL_SUCCESS);
}
</PRE></DD></DL><P>The compilation produces an executable called <TT>examp</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>% gplc examp.pl examp_c.c</TT></DD></DL><P>Examples of use:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- my_call(write(hello)).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>hello</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- my_call(for(X,1,3)).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>X = 1 ?</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user presses <TT>;</TT> to compute another solution)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>X = 2 ?</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user presses <TT>;</TT> to compute another solution)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>X = 3</TT></TD><TD VALIGN=top ALIGN=center NOWRAP>&#XA0;&#XA0;</TD><TD ALIGN=left NOWRAP>(here the user is not prompted since there is no more alternative)</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- my_call(1).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>{exception:&#XA0;error(type_error(callable,1),my_call/1)}</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- my_call(call(1)).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>no</TT></TD></TR>
</TABLE></DD></DL><P>When <TT>my_call(1)</TT> is called an error is raised due to the use of
<TT>Pl_Rd_Callable_Check()</TT>. However the error raised by
<TT>my_call(call(1))</TT> is ignored and <TT>PL_FALSE</TT> (i.e. a failure) is
returned by the foreign function.</P><P>To really simulate the behavior of <TT>call/1</TT> when an exception
is recovered it should be re-raised to be captured by an earlier
handler. The idea is then to execute a <TT>throw/1</TT> as the
continuation. This is what it is done by the following code:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">#include &lt;string.h&gt;
#include &lt;gprolog.h&gt;

PlBool
my_call(PlTerm goal)
{
  PlTerm *args;
  int functor, arity;
  int result;

  args = Pl_Rd_Callable_Check(goal, &amp;functor, &amp;arity);
  Pl_Query_Begin(PL_FALSE);
  result = Pl_Query_Call(functor, arity, args);
  Pl_Query_End(PL_KEEP_FOR_PROLOG);
  if (result == PL_EXCEPTION)
    {
      PlTerm except = Pl_Get_Exception();
      Pl_Exec_Continuation(Find_Atom("throw"), 1, &amp;except);
    }

  return result;
}
</PRE></DD></DL><P>The following code propagates the error raised by <TT>call/1</TT>.</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>| ?- my_call(call(1)).</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP COLSPAN=3><TT>{exception:&#XA0;error(type_error(callable,1),my_call/1)}</TT></TD></TR>
</TABLE></DD></DL><P>Finally note that a simpler way to define <TT>my_call/1</TT> is to use
<TT>Pl_Exec_Continuation()</TT> as follows:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">#include &lt;string.h&gt;
#include &lt;gprolog.h&gt;

PlBool
my_call(PlTerm goal)
{
  PlTerm *args;
  int functor, arity;

  args = Pl_Rd_Callable_Check(goal, &amp;functor, &amp;arity);
  Pl_Exec_Continuation(functor, arity, args);
  return PL_TRUE;
}
</PRE></DD></DL><!--TOC subsubsection Example: recovering the list of all operators-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc390">10.6.3</A>&#XA0;&#XA0;Example: recovering the list of all operators</H4><!--SEC END --><P>We here define a predicate <TT>all_op(List)</TT> which unifies
<TT>List</TT> with the list of all currently defined operators as would be done by: <TT>findall(X,current_op(_,_,X),List)</TT>.</P><P>In the prolog file <TT>examp.pl</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>:- foreign(all_op(term)).</TT></DD></DL><P>In the C file <TT>examp_c.c</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">#include &lt;string.h&gt;
#include &lt;gprolog.h&gt;

PlBool
all_op(PlTerm list)
{
  PlTerm op[1024];
  PlTerm args[3];
  int n = 0;
  int result;

  Pl_Query_Begin(PL_TRUE);
  args[0] = Pl_Mk_Variable();
  args[1] = Pl_Mk_Variable();
  args[2] = Pl_Mk_Variable();
  result = Pl_Query_Call(Find_Atom("current_op"), 3, args);
  while (result)
    {
      op[n++] = Pl_Mk_Atom(Pl_Rd_Atom(args[2])); /* arg[2]: the name of the op */
      result = Pl_Query_Next_Solution();
    }
  Pl_Query_End(PL_RECOVER);

  return Pl_Un_Proper_List_Check(n, op, list);
}
</PRE></DD></DL><P>Note that we know here that there is no source for exception. In that case
the result of <TT>Pl_Query_Call</TT> and <TT>Pl_Query_Next_Solution</TT>
can be considered as a boolean.</P><P>The compilation produces an executable called <TT>examp</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>% gplc examp.pl examp_c.c</TT></DD></DL><P>Example of use:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">| ?- all_op(L).

L = [:-,:-,\=,=:=,#&gt;=,#&lt;#,@&gt;=,--&gt;,mod,#&gt;=#,**,*,+,+,',',...]

| ?- findall(X,current_op(_,_,X),L).

L = [:-,:-,\=,=:=,#&gt;=,#&lt;#,@&gt;=,--&gt;,mod,#&gt;=#,**,*,+,+,',',...]
</PRE></DD></DL><!--TOC subsection Defining a new C <TT>main()</TT> function-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc391">10.7</A>&#XA0;&#XA0;Defining a new C <TT>main()</TT> function</H3><!--SEC END --><P>GNU Prolog allows the user to define his own <TT>main()</TT>
function. This can be useful to perform several tasks before starting
the Prolog engine. To do this simply define a classical
<TT>main(argc, argv)</TT> function. The following functions can then be used:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">int    Pl_Start_Prolog         (int argc, char *argv[])
void   Pl_Stop_Prolog          (void)
void   Pl_Reset_Prolog         (void)
PlBool Pl_Try_Execute_Top_Level(void)
</PRE></DD></DL><P>The function <TT>Pl_Start_Prolog(argc, argv)</TT> initializes the Prolog
engine (<TT>argc</TT> and <TT>argv</TT> are the command-line variables). This
function collects all linked objects (issued from the compilation of Prolog
files) and initializes them. The initialization of a Prolog object file
consists in adding to appropriate tables new atoms, new predicates and
executing its system directives. A system directive is generated by the
Prolog to WAM compiler to reflect a (user) directive executed at compile-time
such as <TT>op/3</TT> (section&#XA0;<A HREF="#op/3">7.1.11</A>). Indeed, when the compiler encounters such
a directive it immediately executes it and also generates a system directive
to execute it at the start of the executable. When all system directives
have been executed the Prolog engine executes all initialization directives
defined with <TT>initialization/1</TT>
(section&#XA0;<A HREF="#initialization/1">7.1.14</A>). The function returns the number of user
directives (i.e. <TT>initialization/1</TT>) executed. This function must be
called only once.</P><P>The function <TT>Pl_Stop_Prolog()</TT> stops the Prolog engine. This function
must be called only once after all Prolog treatment have been done.</P><P>The function <TT>Pl_Reset_Prolog()</TT> reinitializes the Prolog engine
(i.e. reset all Prolog stacks).</P><P>The function <TT>Pl_Try_Execute_Top_Level()</TT> executes the
top-level if linked (section&#XA0;<A HREF="#Using-the-compiler">4.4.3</A>) and returns
<TT>PL_TRUE</TT>. If the top-level is not present the functions returns
<TT>PL_FALSE</TT>.</P><P>Here is the definition of the default GNU Prolog <TT>main()</TT> function:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">static int
Main_Wrapper(int argc, char *argv[])
{
  int nb_user_directive;
  PlBool top_level;

  nb_user_directive = Pl_Start_Prolog(argc, argv);

  top_level = Pl_Try_Execute_Top_Level();

  Pl_Stop_Prolog();

  if (top_level || nb_user_directive)
    return 0;

  fprintf(stderr,
          "Warning: no initial goal executed\n"
          "   use a directive :- initialization(Goal)\n"
          "   or remove the link option --no-top-level"
          " (or --min-bips or --min-size)\n");

  return 1;
}

int
main(int argc, char *argv[])
{
  return Main_Wrapper(argc, argv);
}
</PRE></DD></DL><P>Note that under some circumstances it is necessary to encapsulate the code of
<TT>main()</TT> inside an intermediate function called by
<TT>main()</TT>. Indeed, some C compilers (e.g. gcc) treats <TT>main()</TT>
particularly, producing an incompatible code w.r.t GNU Prolog. So it is a
good idea to always use a wrapper function as shown above.</P><!--TOC subsubsection Example: asking for ancestors-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc392">10.7.1</A>&#XA0;&#XA0;Example: asking for ancestors</H4><!--SEC END --><P>In this example we use the following Prolog code (in a file called
<TT>new_main.pl</TT>):</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">parent(bob,   mary).
parent(jane,  mary).
parent(mary,  peter).
parent(paul,  peter).
parent(peter, john).

anc(X, Y):-
        parent(X, Y).

anc(X, Z) :-
        parent(X, Y),
        anc(Y, Z).
</PRE></DD></DL><P>The following file (called <TT>new_main_c.c</TT>) defines a <TT>main()</TT>
function read the name of a person and displaying all successors of that
person. This is equivalent to the Prolog query: <TT>anc(Result, Name)</TT>.</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">static int
Main_Wrapper(int argc, char *argv[])
{
  int func;
  PlTerm arg[10];
  char str[100];
  char *sol[100];
  int i, nb_sol = 0;
  PlBool res;

  Pl_Start_Prolog(argc, argv);

  func = Pl_Find_Atom("anc");
  for (;;)
    {
      printf("\nEnter a name (or 'end' to finish): ");
      fflush(stdout);
      scanf("%s", str);

      if (strcmp(str, "end") == 0)
 break;

      Pl_Query_Begin(PL_TRUE);

      arg[0] = Pl_Mk_Variable();
      arg[1] = Pl_Mk_String(str);
      nb_sol = 0;
      res = Pl_Query_Call(func, 2, arg);
      while (res)
 {
   sol[nb_sol++] = Pl_Rd_String(arg[0]);
   res = Pl_Query_Next_Solution();
 }
      Pl_Query_End(PL_RECOVER);

      for (i = 0; i &lt; nb_sol; i++)
 printf("  solution: %s\n", sol[i]);
      printf("%d solution(s)\n", nb_sol);
    }

  Pl_Stop_Prolog();
  return 0;
}

int
main(int argc, char *argv[])
{
  return Main_Wrapper(argc, argv);
}
</PRE></DD></DL><P>The compilation produces an executable called <TT>new_main</TT>:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list"><TT>% gplc new_main.pl new_main_c.c</TT></DD></DL><P>Examples of use:</P><DL CLASS="list"><DT CLASS="dt-list">
</DT><DD CLASS="dd-list">
<PRE CLASS="verbatim">Enter a name (or 'end' to finish): john
  solution: peter
  solution: bob
  solution: jane
  solution: mary
  solution: paul
5 solution(s)

Enter a name (or 'end' to finish): mary
  solution: bob
  solution: jane
2 solution(s)

Enter a name (or 'end' to finish): end
</PRE></DD></DL><!--CUT END -->
<!--TOC section References-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="@biblio">References</A></H2><!--SEC END --><DL CLASS="thebibliography"><DT CLASS="dt-thebibliography">
<A NAME="Ait-Kaci91"><FONT COLOR=purple>[1]</FONT></A></DT><DD CLASS="dd-thebibliography"> H. A&#XEF;t-Kaci.
&#X201C;Warren&#X2019;s Abstract Machine, A Tutorial Reconstruction&#X201D;.<BR>
Logic Programming Series, MIT Press, 1991.<BR>
<TT><A HREF="http://web.archive.org/web/20071225092145/www.vanx.org/archive/wam/wam.html">http://web.archive.org/web/20071225092145/www.vanx.org/archive/wam/wam.html</A></TT></DD><DT CLASS="dt-thebibliography"><A NAME="Clock"><FONT COLOR=purple>[2]</FONT></A></DT><DD CLASS="dd-thebibliography"> W.F. Clocksin and C.S. Mellish.
Programming in Prolog, Springer-Verlag, 1981.</DD><DT CLASS="dt-thebibliography"><A NAME="wamcc"><FONT COLOR=purple>[3]</FONT></A></DT><DD CLASS="dd-thebibliography"> P. Codognet and D. Diaz.
&#X201C;<TT>wamcc</TT>: Compiling Prolog to C&#X201D;.<BR>
In <EM>12th International Conference on Logic Programming</EM>,
Tokyo, Japan, MIT Press, 1995.<BR>
<TT><A HREF="http://cri-dist.univ-paris1.fr/diaz/publications/WAMCC/iclp95.pdf">http://cri-dist.univ-paris1.fr/diaz/publications/WAMCC/iclp95.pdf</A></TT></DD><DT CLASS="dt-thebibliography"><A NAME="long-clp-fd"><FONT COLOR=purple>[4]</FONT></A></DT><DD CLASS="dd-thebibliography"> P. Codognet and D. Diaz.
&#X201C;Compiling Constraint in <TT>clp(FD)</TT>&#X201D;.<BR>
<EM>Journal of Logic Programming</EM>, Vol. 27, No. 3, June 1996.<BR>
<TT><A HREF="http://cri-dist.univ-paris1.fr/diaz/publications/CLP-FD/jlp96.pdf">http://cri-dist.univ-paris1.fr/diaz/publications/CLP-FD/jlp96.pdf</A></TT></DD><DT CLASS="dt-thebibliography"><A NAME="gnu-prolog"><FONT COLOR=purple>[5]</FONT></A></DT><DD CLASS="dd-thebibliography"> D. Diaz and P. Codognet.
&#X201C;Design and Implementation of the GNU Prolog System&#X201D;.<BR>
<EM>Journal of Functional and Logic Programming</EM>, Vol. 2001, No. 6, October 2001.<BR>
<TT><A HREF="http://cri-dist.univ-paris1.fr/diaz/publications/GNU-PROLOG/jflp01.pdf">http://cri-dist.univ-paris1.fr/diaz/publications/GNU-PROLOG/jflp01.pdf</A></TT></DD><DT CLASS="dt-thebibliography"><A NAME="iso-part1"><FONT COLOR=purple>[6]</FONT></A></DT><DD CLASS="dd-thebibliography">
Information technology - Programming languages - Prolog - Part 1:
General Core.<BR>
ISO/IEC 13211-1, 1995.
</DD><DT CLASS="dt-thebibliography"><A NAME="Jaffar-Lassez87"><FONT COLOR=purple>[7]</FONT></A></DT><DD CLASS="dd-thebibliography"> J. Jaffar and J-L. Lassez.
&#X201C;Constraint Logic Programming&#X201D;.<BR>
In <EM>Principles Of Programming Languages</EM>,
Munich, Germany, January 1987.</DD><DT CLASS="dt-thebibliography"><A NAME="pvh89"><FONT COLOR=purple>[8]</FONT></A></DT><DD CLASS="dd-thebibliography"> P. Van Hentenryck.
&#X201C;Constraint Satisfaction in Logic Programming&#X201D;.<BR>
Logic Programming Series, The MIT Press, 1989.</DD><DT CLASS="dt-thebibliography"><A NAME="Warren83"><FONT COLOR=purple>[9]</FONT></A></DT><DD CLASS="dd-thebibliography"> D. H. D. Warren.
&#X201C;An Abstract Prolog Instruction Set&#X201D;.<BR>
Technical Report 309, SRI International, Oct. 1983.</DD></DL><!--TOC section Index-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="@index">Index</A></H2><!--SEC END --><!--NAME gprolog-idx.html-->
<P></P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left><UL CLASS="indexenv"><LI CLASS="li-indexenv">
<TT>!/0</TT>, <B><A HREF="#htoc65">7.2.1</A></B>, <A HREF="#htoc67">7.2.3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>&#X2019;.&#X2019;/2</TT>, <B><A HREF="#htoc237">8.23.1</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>(&#X2019;,&#X2019;)/2</TT>, <B><A HREF="#htoc66">7.2.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>(*-&gt;)/2</TT>, <B><A HREF="#htoc66">7.2.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>(--&gt;)/2</TT>, <B><A HREF="#htoc187">8.17.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>(-&gt;)/2</TT>, <B><A HREF="#htoc66">7.2.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>(;)/2</TT>, <B><A HREF="#htoc66">7.2.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>(=)/2</TT>, <B><A HREF="#htoc73">8.2.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>(=..)/2</TT>, <B><A HREF="#htoc83">8.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(=:=)/2</TT>, <B><A HREF="#htoc97">8.6.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(==)/2</TT>, <B><A HREF="#htoc78">8.3.2</A></B>, <A HREF="#htoc212">8.20.4</A>
</LI><LI CLASS="li-indexenv"><TT>(=\=)/2</TT>, <B><A HREF="#htoc97">8.6.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(=&lt;)/2</TT>, <B><A HREF="#htoc97">8.6.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(@=&lt;)/2</TT>, <B><A HREF="#htoc78">8.3.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>(@&gt;)/2</TT>, <B><A HREF="#htoc78">8.3.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>(@&gt;=)/2</TT>, <B><A HREF="#htoc78">8.3.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>(@&lt;)/2</TT>, <B><A HREF="#htoc78">8.3.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#/\)/2 </TT>(FD), <B><A HREF="#htoc338">9.7.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#=)/2 </TT>(FD), <B><A HREF="#htoc332">9.6.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#==&gt;)/2 </TT>(FD), <B><A HREF="#htoc338">9.7.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#=#)/2 </TT>(FD), <B><A HREF="#htoc333">9.6.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#=&lt;)/2 </TT>(FD), <B><A HREF="#htoc332">9.6.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#=&lt;#)/2 </TT>(FD), <B><A HREF="#htoc333">9.6.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(##)/2 </TT>(FD), <B><A HREF="#htoc338">9.7.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#\)/1 </TT>(FD), <B><A HREF="#htoc338">9.7.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#\/)/2 </TT>(FD), <B><A HREF="#htoc338">9.7.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#\/\)/2 </TT>(FD), <B><A HREF="#htoc338">9.7.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#\=)/2 </TT>(FD), <B><A HREF="#htoc332">9.6.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#\==&gt;)/2 </TT>(FD), <B><A HREF="#htoc338">9.7.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#\=#)/2 </TT>(FD), <B><A HREF="#htoc333">9.6.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#\\/)/2 </TT>(FD), <B><A HREF="#htoc338">9.7.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#\&lt;=&gt;)/2 </TT>(FD), <B><A HREF="#htoc338">9.7.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#&gt;)/2 </TT>(FD), <B><A HREF="#htoc332">9.6.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#&gt;=)/2 </TT>(FD), <B><A HREF="#htoc332">9.6.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#&gt;=#)/2 </TT>(FD), <B><A HREF="#htoc333">9.6.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#&gt;#)/2 </TT>(FD), <B><A HREF="#htoc333">9.6.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#&lt;)/2 </TT>(FD), <B><A HREF="#htoc332">9.6.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#&lt;=&gt;)/2 </TT>(FD), <B><A HREF="#htoc338">9.7.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(#&lt;#)/2 </TT>(FD), <B><A HREF="#htoc333">9.6.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(\+)/1</TT>, <B><A HREF="#htoc192">8.18.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>(\=)/2</TT>, <B><A HREF="#htoc75">8.2.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(\==)/2</TT>, <B><A HREF="#htoc78">8.3.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>(&gt;)/2</TT>, <B><A HREF="#htoc97">8.6.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(&gt;=)/2</TT>, <B><A HREF="#htoc97">8.6.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(&lt;)/2</TT>, <B><A HREF="#htoc97">8.6.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>(is)/2</TT>, <B><A HREF="#htoc96">8.6.2</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>--</TT>, <B><A HREF="#htoc7">4.2.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>--assembly</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--aux-father</TT>, <B><A HREF="#htoc20">4.4.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>--aux-father2</TT>, <B><A HREF="#htoc20">4.4.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>--c-compiler</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--cmd-line</TT>, <B><A HREF="#htoc20">4.4.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>--comment</TT>, <B><A HREF="#htoc17">4.4.3</A></B>, <A HREF="#htoc17">4.4.3</A>
</LI><LI CLASS="li-indexenv"><TT>--compile-msg</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--consult-file</TT>, <B><A HREF="#htoc7">4.2.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>--cstr-size</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--decode</TT>, <B><A HREF="#htoc20">4.4.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>--demangling</TT>, <B><A HREF="#htoc20">4.4.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>--encode</TT>, <B><A HREF="#htoc20">4.4.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>--entry-goal</TT>, <B><A HREF="#htoc7">4.2.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>--fast-math</TT>, <B><A HREF="#htoc17">4.4.3</A></B>, <A HREF="#htoc95">8.6.1</A>
</LI><LI CLASS="li-indexenv"><TT>--fd-to-c</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--fixed-sizes</TT>, <A HREF="#htoc13">4.3</A>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--foreign-only</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--global-size</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--gui-console</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--help</TT>, <B><A HREF="#htoc7">4.2.1</A></B>, <B><A HREF="#htoc17">4.4.3</A></B>, <B><A HREF="#htoc20">4.4.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>--init-goal</TT>, <B><A HREF="#htoc7">4.2.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>--keep-void-inst</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--linker</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--local-size</TT>, <A HREF="#htoc13">4.3</A>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--mangling</TT>, <B><A HREF="#htoc20">4.4.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>--min-bips</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--min-fd-bips</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--min-pl-bips</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--min-reg-opt</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--min-size</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--mini-assembly</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--no-call-c</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--no-debugger</TT>, <A HREF="#htoc17">4.4.3</A>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--no-del-temp</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--no-demangling</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--no-fd-lib</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--no-inline</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--no-opt-last-subterm</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--no-redef-error</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--no-reg-opt</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--no-reorder</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--no-singl-warn</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--no-susp-warn</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--no-top-level</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--object</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--output</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--pl-state</TT>, <B><A HREF="#htoc17">4.4.3</A></B>, <A HREF="#htoc235">8.22.5</A>
</LI><LI CLASS="li-indexenv"><TT>--printf</TT>, <B><A HREF="#htoc20">4.4.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>--query-goal</TT>, <B><A HREF="#htoc7">4.2.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>--relax</TT>, <B><A HREF="#htoc20">4.4.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>--statistics</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--strip</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--temp-dir</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--trail-size</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--verbose</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--version</TT>, <B><A HREF="#htoc7">4.2.1</A></B>, <B><A HREF="#htoc17">4.4.3</A></B>, <B><A HREF="#htoc20">4.4.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>--wam-comment</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--wam-for-byte-code</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>--wam-for-native</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>-A</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>-C</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>-c</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>-D</TT>, <B><A HREF="#htoc20">4.4.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>-E</TT>, <B><A HREF="#htoc20">4.4.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>-F</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>-h</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>-L</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>-M</TT>, <B><A HREF="#htoc17">4.4.3</A></B>, <B><A HREF="#htoc20">4.4.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>-o</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>-P</TT>, <B><A HREF="#htoc20">4.4.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>-S</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>-s</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>-v</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>-W</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>-w</TT>, <B><A HREF="#htoc17">4.4.3</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>abolish/1</TT>, <B><A HREF="#htoc105">8.7.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>abort/0</TT>, <A HREF="#htoc11">4.2.5</A>, <A HREF="#htoc29">5.5</A>, <B><A HREF="#htoc191">8.18.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>absolute_file_name </TT>(property), <B><A HREF="#htoc263">8.27.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>absolute_file_name/2</TT>, <A HREF="#htoc56">7.1.8</A>, <A HREF="#htoc119">8.10.6</A>, <A HREF="#htoc237">8.23.1</A>, <A HREF="#htoc238">8.23.2</A>, <B><A HREF="#htoc249">8.26.1</A></B>, <A HREF="#htoc251">8.26.3</A>, <A HREF="#htoc257">8.27.5</A>, <A HREF="#htoc259">8.27.7</A>, <A HREF="#htoc260">8.27.8</A>, <A HREF="#htoc261">8.27.9</A>, <A HREF="#htoc262">8.27.10</A>, <A HREF="#htoc263">8.27.11</A>, <A HREF="#htoc264">8.27.12</A>, <A HREF="#htoc265">8.27.13</A>
</LI><LI CLASS="li-indexenv"><TT>acyclic_term/1</TT>, <B><A HREF="#htoc87">8.4.7</A></B>
</LI><LI CLASS="li-indexenv"><TT>add_linedit_completion/1</TT>, <B><A HREF="#htoc294">8.29.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>add_stream_alias/2</TT>, <A HREF="#htoc114">8.10.1</A>, <B><A HREF="#htoc133">8.10.20</A></B>
</LI><LI CLASS="li-indexenv"><TT>add_stream_mirror/2</TT>, <A HREF="#htoc114">8.10.1</A>, <B><A HREF="#htoc135">8.10.22</A></B>
</LI><LI CLASS="li-indexenv"><TT>alias </TT>(option), <B><A HREF="#htoc119">8.10.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>alias </TT>(property), <B><A HREF="#htoc123">8.10.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>append </TT>(mode), <B><A HREF="#htoc119">8.10.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>append/1</TT>, <B><A HREF="#htoc181">8.16.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>append/3</TT>, <B><A HREF="#htoc209">8.20.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>arch </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>architecture/1</TT>, <B><A HREF="#htoc269">8.27.17</A></B>
</LI><LI CLASS="li-indexenv"><TT>arg/3</TT>, <B><A HREF="#htoc82">8.4.2</A></B>
</LI><LI CLASS="li-indexenv">argument
selector, <B><A HREF="#htoc223">8.21.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>argument_counter/1</TT>, <B><A HREF="#htoc253">8.27.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>argument_list/1</TT>, <A HREF="#htoc7">4.2.1</A>, <B><A HREF="#htoc255">8.27.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>argument_value/2</TT>, <A HREF="#htoc7">4.2.1</A>, <B><A HREF="#htoc254">8.27.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>asserta/1</TT>, <B><A HREF="#htoc101">8.7.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>assertz/1</TT>, <B><A HREF="#htoc101">8.7.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>at_end_of_stream/0</TT>, <B><A HREF="#htoc124">8.10.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>at_end_of_stream/1</TT>, <B><A HREF="#htoc124">8.10.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>atom/1</TT>, <B><A HREF="#htoc71">8.1.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>atom_chars/2</TT>, <B><A HREF="#htoc201">8.19.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>atom_codes/2</TT>, <B><A HREF="#htoc201">8.19.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>atom_concat/3</TT>, <B><A HREF="#htoc197">8.19.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>atom_hash/2</TT>, <B><A HREF="#htoc204">8.19.9</A></B>
</LI><LI CLASS="li-indexenv"><TT>atom_length/2</TT>, <B><A HREF="#htoc196">8.19.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>atom_property/2</TT>, <B><A HREF="#htoc207">8.19.12</A></B>
</LI><LI CLASS="li-indexenv"><TT>atomic/1</TT>, <B><A HREF="#htoc71">8.1.1</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>back_quotes </TT>(flag), <A HREF="#htoc7">4.2.1</A>, <A HREF="#htoc158">8.14</A>, <B><A HREF="#htoc231">8.22.1</A></B>, <A HREF="#htoc235">8.22.5</A>
</LI><LI CLASS="li-indexenv"><TT>back_quotes </TT>(token), <B><A HREF="#htoc161">8.14.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>backtracks </TT>(FD option), <B><A HREF="#htoc347">9.9.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>bagof/3</TT>, <B><A HREF="#htoc112">8.9.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>between/3</TT>, <B><A HREF="#htoc194">8.18.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>binary </TT>(option), <B><A HREF="#htoc119">8.10.6</A></B>, <A HREF="#htoc138">8.10.25</A>
</LI><LI CLASS="li-indexenv"><TT>bind_variables/2</TT>, <B><A HREF="#htoc92">8.5.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>bip_name </TT>(option), <B><A HREF="#htoc355">10.3.2</A></B>, <A HREF="#htoc375">10.5.1</A>
</LI><LI CLASS="li-indexenv"><TT>block </TT>(option), <B><A HREF="#htoc119">8.10.6</A></B>, <A HREF="#htoc140">8.10.27</A>
</LI><LI CLASS="li-indexenv"><TT>block_device </TT>(permission), <B><A HREF="#htoc263">8.27.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>bof </TT>(whence), <B><A HREF="#htoc127">8.10.14</A></B>
</LI><LI CLASS="li-indexenv"><TT>boolean </TT>(option), <B><A HREF="#htoc355">10.3.2</A></B>, <A HREF="#htoc356">10.3.3</A>
</LI><LI CLASS="li-indexenv"><TT>bounded </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>bounds </TT>(FD option), <B><A HREF="#htoc347">9.9.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>break/0</TT>, <A HREF="#htoc11">4.2.5</A>, <A HREF="#htoc29">5.5</A>, <B><A HREF="#htoc191">8.18.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>buffering </TT>(option), <B><A HREF="#htoc119">8.10.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>buffering </TT>(property), <B><A HREF="#htoc123">8.10.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>built_in </TT>(property), <A HREF="#htoc55">7.1.7</A>, <B><A HREF="#htoc108">8.8.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>built_in/0 </TT>(directive), <B><A HREF="#htoc55">7.1.7</A></B>
</LI><LI CLASS="li-indexenv"><TT>built_in/1 </TT>(directive), <B><A HREF="#htoc55">7.1.7</A></B>
</LI><LI CLASS="li-indexenv"><TT>built_in_fd </TT>(property), <A HREF="#htoc55">7.1.7</A>, <B><A HREF="#htoc108">8.8.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>built_in_fd/0 </TT>(directive), <B><A HREF="#htoc55">7.1.7</A></B>
</LI><LI CLASS="li-indexenv"><TT>built_in_fd/1 </TT>(directive), <B><A HREF="#htoc55">7.1.7</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>call/1</TT>, <B><A HREF="#htoc67">7.2.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>call/2-11</TT>, <B><A HREF="#htoc192">8.18.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>call_det/2</TT>, <B><A HREF="#htoc192">8.18.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>call_with_args/1-11</TT>, <B><A HREF="#htoc192">8.18.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>callable/1</TT>, <B><A HREF="#htoc71">8.1.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>catch/3</TT>, <A HREF="#htoc23">5.2</A>, <A HREF="#htoc35">6.3.1</A>, <B><A HREF="#htoc68">7.2.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>change_directory/1</TT>, <B><A HREF="#htoc257">8.27.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>char_code/2</TT>, <B><A HREF="#htoc199">8.19.4</A></B>, <A HREF="#htoc363">10.3.10</A>
</LI><LI CLASS="li-indexenv"><TT>char_conversion </TT>(flag), <A HREF="#htoc158">8.14</A>, <A HREF="#htoc170">8.14.12</A>, <B><A HREF="#htoc231">8.22.1</A></B>, <A HREF="#htoc235">8.22.5</A>
</LI><LI CLASS="li-indexenv"><TT>char_conversion/2 </TT>(directive), <B><A HREF="#htoc60">7.1.12</A></B>
</LI><LI CLASS="li-indexenv"><TT>char_conversion/2</TT>, <A HREF="#htoc60">7.1.12</A>, <B><A HREF="#htoc170">8.14.12</A></B>
</LI><LI CLASS="li-indexenv"><TT>character_count/2</TT>, <B><A HREF="#htoc128">8.10.15</A></B>
</LI><LI CLASS="li-indexenv"><TT>character_device </TT>(permission), <B><A HREF="#htoc263">8.27.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>choice_size </TT>(option), <B><A HREF="#htoc355">10.3.2</A></B>, <A HREF="#htoc360">10.3.7</A>
</LI><LI CLASS="li-indexenv"><TT>clause/2</TT>, <B><A HREF="#htoc104">8.7.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>close/1</TT>, <B><A HREF="#htoc120">8.10.7</A></B>
</LI><LI CLASS="li-indexenv"><TT>close/2</TT>, <B><A HREF="#htoc120">8.10.7</A></B>, <A HREF="#htoc273">8.27.21</A>, <A HREF="#htoc285">8.28.3</A>
</LI><LI CLASS="li-indexenv"><TT>close_input_atom_stream/1</TT>, <B><A HREF="#htoc144">8.11.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>close_input_chars_stream/1</TT>, <B><A HREF="#htoc144">8.11.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>close_input_codes_stream/1</TT>, <B><A HREF="#htoc144">8.11.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>close_output_atom_stream/2</TT>, <B><A HREF="#htoc146">8.11.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>close_output_chars_stream/2</TT>, <B><A HREF="#htoc146">8.11.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>close_output_codes_stream/2</TT>, <B><A HREF="#htoc146">8.11.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>compare/3</TT>, <B><A HREF="#htoc79">8.3.3</A></B>
</LI><LI CLASS="li-indexenv">completion, <B><A HREF="#htoc12">4.2.6</A></B>, <A HREF="#htoc294">8.29.3</A>, <A HREF="#htoc295">8.29.4</A>
</LI><LI CLASS="li-indexenv"><TT>compound/1</TT>, <B><A HREF="#htoc71">8.1.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>consult/1</TT>, <A HREF="#htoc9">4.2.3</A>, <A HREF="#htoc9">4.2.3</A>, <A HREF="#htoc15">4.4.1</A>, <A HREF="#htoc16">4.4.2</A>, <B><A HREF="#htoc237">8.23.1</A></B>
</LI><LI CLASS="li-indexenv">control constructs, <A HREF="#htoc64">7.2</A>
</LI><LI CLASS="li-indexenv"><TT>control_construct </TT>(property), <B><A HREF="#htoc108">8.8.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>copy_term/2</TT>, <B><A HREF="#htoc84">8.4.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>cpu_time/1</TT>, <B><A HREF="#htoc242">8.24.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>create_pipe/2</TT>, <B><A HREF="#htoc276">8.27.24</A></B>
</LI><LI CLASS="li-indexenv"><TT>current </TT>(whence), <B><A HREF="#htoc127">8.10.14</A></B>
</LI><LI CLASS="li-indexenv"><TT>current_alias/2</TT>, <B><A HREF="#htoc134">8.10.21</A></B>
</LI><LI CLASS="li-indexenv"><TT>current_atom/1</TT>, <B><A HREF="#htoc206">8.19.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>current_bip_name/2</TT>, <A HREF="#htoc35">6.3.1</A>, <B><A HREF="#htoc234">8.22.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>current_char_conversion/2</TT>, <B><A HREF="#htoc171">8.14.13</A></B>
</LI><LI CLASS="li-indexenv"><TT>current_input/1</TT>, <B><A HREF="#htoc115">8.10.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>current_mirror/2</TT>, <B><A HREF="#htoc137">8.10.24</A></B>
</LI><LI CLASS="li-indexenv"><TT>current_op/3</TT>, <B><A HREF="#htoc169">8.14.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>current_output/1</TT>, <B><A HREF="#htoc116">8.10.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>current_predicate/1</TT>, <A HREF="#htoc103">8.7.4</A>, <B><A HREF="#htoc107">8.8.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>current_prolog_flag/2</TT>, <B><A HREF="#htoc232">8.22.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>current_stream/1</TT>, <B><A HREF="#htoc122">8.10.9</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Definite clause grammars, see <I>DCG</I>
</LI><LI CLASS="li-indexenv"><TT>date_time/1</TT>, <B><A HREF="#htoc266">8.27.14</A></B>
</LI><LI CLASS="li-indexenv"><TT>debug </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>debug/0 </TT>(debug), <A HREF="#htoc9">4.2.3</A>, <A HREF="#htoc11">4.2.5</A>, <B><A HREF="#htoc25">5.3.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>debugging/0 </TT>(debug), <B><A HREF="#htoc25">5.3.1</A></B>, <A HREF="#htoc29">5.5</A>
</LI><LI CLASS="li-indexenv"><TT>decompose_file_name/4</TT>, <B><A HREF="#htoc250">8.26.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>delete/3</TT>, <B><A HREF="#htoc212">8.20.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>delete_directory/1</TT>, <B><A HREF="#htoc257">8.27.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>delete_file/1</TT>, <B><A HREF="#htoc261">8.27.9</A></B>
</LI><LI CLASS="li-indexenv">demangling, <A HREF="#htoc17">4.4.3</A>
</LI><LI CLASS="li-indexenv"><TT>dialect </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>directory </TT>(permission), <B><A HREF="#htoc263">8.27.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>directory_files/2</TT>, <B><A HREF="#htoc259">8.27.7</A></B>
</LI><LI CLASS="li-indexenv"><TT>discontiguous/1 </TT>(directive), <B><A HREF="#htoc53">7.1.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>display/1</TT>, <B><A HREF="#htoc164">8.14.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>display/2</TT>, <B><A HREF="#htoc164">8.14.6</A></B>, <A HREF="#htoc176">8.15.4</A>, <A HREF="#htoc177">8.15.5</A>, <A HREF="#htoc178">8.15.6</A>
</LI><LI CLASS="li-indexenv"><TT>display_to_atom/2</TT>, <B><A HREF="#htoc176">8.15.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>display_to_chars/2</TT>, <B><A HREF="#htoc177">8.15.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>display_to_codes/2</TT>, <B><A HREF="#htoc178">8.15.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>double_quotes </TT>(flag), <A HREF="#htoc158">8.14</A>, <B><A HREF="#htoc231">8.22.1</A></B>, <A HREF="#htoc235">8.22.5</A>
</LI><LI CLASS="li-indexenv"><TT>dynamic </TT>(property), <B><A HREF="#htoc108">8.8.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>dynamic/1 </TT>(directive), <B><A HREF="#htoc50">7.1.2</A></B>, <A HREF="#htoc100">8.7.1</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>elif/1 </TT>(directive), <B><A HREF="#htoc57">7.1.9</A></B>
</LI><LI CLASS="li-indexenv"><TT>else/0 </TT>(directive), <B><A HREF="#htoc57">7.1.9</A></B>
</LI><LI CLASS="li-indexenv"><TT>end_of_stream </TT>(property), <B><A HREF="#htoc123">8.10.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>end_of_term </TT>(option), <B><A HREF="#htoc159">8.14.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>endif/0 </TT>(directive), <B><A HREF="#htoc57">7.1.9</A></B>
</LI><LI CLASS="li-indexenv"><TT>ensure_linked/1 </TT>(directive), <B><A HREF="#htoc54">7.1.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>ensure_loaded/1 </TT>(directive), <B><A HREF="#htoc58">7.1.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>environ/2</TT>, <B><A HREF="#htoc256">8.27.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>eof </TT>(whence), <B><A HREF="#htoc127">8.10.14</A></B>
</LI><LI CLASS="li-indexenv"><TT>eof_action </TT>(option), <B><A HREF="#htoc119">8.10.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>eof_action </TT>(property), <B><A HREF="#htoc123">8.10.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>eof_code </TT>(option), <B><A HREF="#htoc119">8.10.6</A></B>, <A HREF="#htoc139">8.10.26</A>
</LI><LI CLASS="li-indexenv"><TT>error </TT>(option), <B><A HREF="#htoc119">8.10.6</A></B>, <A HREF="#htoc139">8.10.26</A>, <B><A HREF="#htoc159">8.14.1</A></B>
</LI><LI CLASS="li-indexenv">escape sequence, <A HREF="#htoc7">4.2.1</A>, <A HREF="#htoc207">8.19.12</A>, <B><A HREF="#htoc231">8.22.1</A></B>, <A HREF="#htoc231">8.22.1</A>
</LI><LI CLASS="li-indexenv"><TT>exclude </TT>(option), <B><A HREF="#htoc92">8.5.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>exec/4</TT>, <B><A HREF="#htoc274">8.27.22</A></B>
</LI><LI CLASS="li-indexenv"><TT>exec/5</TT>, <B><A HREF="#htoc274">8.27.22</A></B>
</LI><LI CLASS="li-indexenv"><TT>execute </TT>(permission), <B><A HREF="#htoc262">8.27.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>expand_term/2</TT>, <B><A HREF="#htoc188">8.17.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>extended </TT>(token), <B><A HREF="#htoc161">8.14.3</A></B>
</LI><LI CLASS="li-indexenv">extra-constrained, see <TT><I>extra_cstr</I></TT>
</LI><LI CLASS="li-indexenv"><TT>extra_cstr </TT>(FD), <B><A HREF="#htoc317">9.1.1</A></B>, <A HREF="#htoc329">9.5.2</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>fail </TT>(option), <B><A HREF="#htoc159">8.14.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>fail/0</TT>, <B><A HREF="#htoc65">7.2.1</A></B>, <A HREF="#htoc192">8.18.2</A>
</LI><LI CLASS="li-indexenv"><TT>false/0</TT>, <B><A HREF="#htoc192">8.18.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>fct_name </TT>(option), <B><A HREF="#htoc355">10.3.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_all_different/1 </TT>(FD), <B><A HREF="#htoc341">9.8.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_at_least_one/1 </TT>(FD), <B><A HREF="#htoc339">9.7.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_at_most_one/1 </TT>(FD), <B><A HREF="#htoc339">9.7.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_atleast/3 </TT>(FD), <B><A HREF="#htoc344">9.8.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_atmost/3 </TT>(FD), <B><A HREF="#htoc344">9.8.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_cardinality/2 </TT>(FD), <B><A HREF="#htoc339">9.7.4</A></B>, <A HREF="#htoc344">9.8.4</A>
</LI><LI CLASS="li-indexenv"><TT>fd_cardinality/3 </TT>(FD), <B><A HREF="#htoc339">9.7.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_dom/2 </TT>(FD), <B><A HREF="#htoc328">9.5.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_domain/2 </TT>(FD), <B><A HREF="#htoc324">9.3.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_domain/3 </TT>(FD), <B><A HREF="#htoc323">9.3.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_domain_bool/1 </TT>(FD), <B><A HREF="#htoc323">9.3.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_element/3 </TT>(FD), <B><A HREF="#htoc342">9.8.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_element_var/3 </TT>(FD), <B><A HREF="#htoc343">9.8.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_exactly/3 </TT>(FD), <B><A HREF="#htoc344">9.8.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_has_extra_cstr/1 </TT>(FD), <B><A HREF="#htoc329">9.5.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_has_vector/1 </TT>(FD), <B><A HREF="#htoc329">9.5.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_labeling/1 </TT>(FD), <B><A HREF="#htoc347">9.9.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_labeling/2 </TT>(FD), <B><A HREF="#htoc347">9.9.1</A></B>, <A HREF="#htoc349">9.10.1</A>
</LI><LI CLASS="li-indexenv"><TT>fd_labelingff/1 </TT>(FD), <B><A HREF="#htoc347">9.9.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_max/2 </TT>(FD), <B><A HREF="#htoc328">9.5.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_max_integer </TT>(FD), <B><A HREF="#htoc317">9.1.1</A></B>, <A HREF="#htoc319">9.2.1</A>
</LI><LI CLASS="li-indexenv"><TT>fd_max_integer/1 </TT>(FD), <B><A HREF="#htoc319">9.2.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_maximize/2 </TT>(FD), <B><A HREF="#htoc349">9.10.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_min/2 </TT>(FD), <B><A HREF="#htoc328">9.5.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_minimize/2 </TT>(FD), <B><A HREF="#htoc349">9.10.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_not_prime/1 </TT>(FD), <B><A HREF="#htoc334">9.6.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_only_one/1 </TT>(FD), <B><A HREF="#htoc339">9.7.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_prime/1 </TT>(FD), <B><A HREF="#htoc334">9.6.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_reified_in/4 </TT>(FD), <B><A HREF="#htoc337">9.7.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_relation/2 </TT>(FD), <B><A HREF="#htoc345">9.8.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_relationc/2 </TT>(FD), <B><A HREF="#htoc345">9.8.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_set_vector_max/1 </TT>(FD), <A HREF="#htoc317">9.1.1</A>, <B><A HREF="#htoc321">9.2.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_size/2 </TT>(FD), <B><A HREF="#htoc328">9.5.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_use_vector/1 </TT>(FD), <B><A HREF="#htoc329">9.5.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_var/1 </TT>(FD), <B><A HREF="#htoc326">9.4.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>fd_vector_max/1 </TT>(FD), <A HREF="#htoc317">9.1.1</A>, <B><A HREF="#htoc320">9.2.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>fifo </TT>(permission), <B><A HREF="#htoc263">8.27.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>file_exists/1</TT>, <B><A HREF="#htoc262">8.27.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>file_name </TT>(property), <B><A HREF="#htoc123">8.10.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>file_permission/2</TT>, <B><A HREF="#htoc262">8.27.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>file_property/2</TT>, <B><A HREF="#htoc263">8.27.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>find_linedit_completion/2</TT>, <B><A HREF="#htoc295">8.29.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>findall/3</TT>, <B><A HREF="#htoc111">8.9.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>first_fail </TT>(FD option), <B><A HREF="#htoc347">9.9.1</A></B>
</LI><LI CLASS="li-indexenv">flag, see <I>Prolog flag</I>
</LI><LI CLASS="li-indexenv"><TT>float/1</TT>, <B><A HREF="#htoc71">8.1.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>flush_output/0</TT>, <B><A HREF="#htoc121">8.10.8</A></B>
</LI><LI CLASS="li-indexenv"><TT>flush_output/1</TT>, <A HREF="#htoc114">8.10.1</A>, <B><A HREF="#htoc121">8.10.8</A></B>
</LI><LI CLASS="li-indexenv"><TT>for/3</TT>, <B><A HREF="#htoc194">8.18.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>forall/2</TT>, <B><A HREF="#htoc192">8.18.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>force </TT>(option), <B><A HREF="#htoc120">8.10.7</A></B>
</LI><LI CLASS="li-indexenv"><TT>foreign/1 </TT>(directive), <B><A HREF="#htoc63">7.1.15</A></B>, <B><A HREF="#htoc355">10.3.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>foreign/2 </TT>(directive), <B><A HREF="#htoc63">7.1.15</A></B>, <B><A HREF="#htoc355">10.3.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>fork_prolog/1</TT>, <B><A HREF="#htoc275">8.27.23</A></B>
</LI><LI CLASS="li-indexenv"><TT>format/2</TT>, <B><A HREF="#htoc165">8.14.7</A></B>
</LI><LI CLASS="li-indexenv"><TT>format/3</TT>, <B><A HREF="#htoc165">8.14.7</A></B>, <A HREF="#htoc176">8.15.4</A>, <A HREF="#htoc177">8.15.5</A>, <A HREF="#htoc178">8.15.6</A>
</LI><LI CLASS="li-indexenv"><TT>format_to_atom/3</TT>, <B><A HREF="#htoc176">8.15.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>format_to_chars/3</TT>, <B><A HREF="#htoc177">8.15.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>format_to_codes/3</TT>, <B><A HREF="#htoc178">8.15.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>from </TT>(option), <B><A HREF="#htoc92">8.5.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>full </TT>(debug), <B><A HREF="#htoc26">5.3.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>functor/3</TT>, <B><A HREF="#htoc81">8.4.1</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">GUI console, <A HREF="#htoc12">4.2.6</A>, <A HREF="#htoc17">4.4.3</A>
</LI><LI CLASS="li-indexenv"><TT>g_array </TT>(global var.), <B><A HREF="#htoc223">8.21.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_array_auto </TT>(global var.), <B><A HREF="#htoc223">8.21.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_array_extend </TT>(global var.), <B><A HREF="#htoc223">8.21.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_array_size/2</TT>, <B><A HREF="#htoc226">8.21.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_assign/2</TT>, <B><A HREF="#htoc224">8.21.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_assignb/2</TT>, <B><A HREF="#htoc224">8.21.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_dec/1</TT>, <B><A HREF="#htoc227">8.21.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_dec/2</TT>, <B><A HREF="#htoc227">8.21.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_dec/3</TT>, <B><A HREF="#htoc227">8.21.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_deco/2</TT>, <B><A HREF="#htoc227">8.21.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_inc/1</TT>, <B><A HREF="#htoc227">8.21.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_inc/2</TT>, <B><A HREF="#htoc227">8.21.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_inc/3</TT>, <B><A HREF="#htoc227">8.21.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_inco/2</TT>, <B><A HREF="#htoc227">8.21.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_link/2</TT>, <B><A HREF="#htoc224">8.21.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_read/2</TT>, <B><A HREF="#htoc225">8.21.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_reset_bit/2</TT>, <B><A HREF="#htoc228">8.21.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_set_bit/2</TT>, <B><A HREF="#htoc228">8.21.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_test_reset_bit/2</TT>, <B><A HREF="#htoc228">8.21.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>g_test_set_bit/2</TT>, <B><A HREF="#htoc228">8.21.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>generic_var/1 </TT>(FD), <B><A HREF="#htoc326">9.4.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>get/1</TT>, <B><A HREF="#htoc184">8.16.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>get0/1</TT>, <B><A HREF="#htoc184">8.16.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>get_byte/1</TT>, <B><A HREF="#htoc154">8.13.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>get_byte/2</TT>, <A HREF="#htoc114">8.10.1</A>, <B><A HREF="#htoc154">8.13.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>get_char/1</TT>, <B><A HREF="#htoc148">8.12.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>get_char/2</TT>, <B><A HREF="#htoc148">8.12.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>get_code/1</TT>, <B><A HREF="#htoc148">8.12.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>get_code/2</TT>, <B><A HREF="#htoc148">8.12.1</A></B>, <A HREF="#htoc149">8.12.2</A>
</LI><LI CLASS="li-indexenv"><TT>get_key/1</TT>, <B><A HREF="#htoc149">8.12.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>get_key/2</TT>, <B><A HREF="#htoc149">8.12.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>get_key_no_echo/1</TT>, <B><A HREF="#htoc149">8.12.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>get_key_no_echo/2</TT>, <B><A HREF="#htoc149">8.12.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>get_linedit_prompt/1</TT>, <B><A HREF="#htoc292">8.29.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>get_print_stream/1</TT>, <B><A HREF="#htoc167">8.14.9</A></B>
</LI><LI CLASS="li-indexenv"><TT>get_seed/1</TT>, <B><A HREF="#htoc245">8.25.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>gplc</TT>, <B><A HREF="#htoc17">4.4.3</A></B>, <A HREF="#htoc17">4.4.3</A>, <A HREF="#htoc19">4.4.5</A>, <A HREF="#htoc20">4.4.6</A>, <A HREF="#htoc20">4.4.6</A>, <A HREF="#htoc235">8.22.5</A>
</LI><LI CLASS="li-indexenv"><TT>ground/1</TT>, <B><A HREF="#htoc71">8.1.1</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>half </TT>(debug), <B><A HREF="#htoc26">5.3.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>halt/0</TT>, <A HREF="#htoc7">4.2.1</A>, <A HREF="#htoc11">4.2.5</A>, <B><A HREF="#htoc191">8.18.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>halt/1</TT>, <B><A HREF="#htoc191">8.18.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>hash </TT>(property), <B><A HREF="#htoc207">8.19.12</A></B>
</LI><LI CLASS="li-indexenv"><TT>hexgplc</TT>, <B><A HREF="#htoc20">4.4.6</A></B>
</LI></UL></TD><TD VALIGN=top ALIGN=left><UL CLASS="indexenv"><LI CLASS="li-indexenv"><TT>home </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>host </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>host_cpu </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>host_name/1</TT>, <B><A HREF="#htoc267">8.27.15</A></B>
</LI><LI CLASS="li-indexenv"><TT>host_os </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>host_vendor </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>hostname_address/2</TT>, <B><A HREF="#htoc290">8.28.8</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>if/1 </TT>(directive), <B><A HREF="#htoc57">7.1.9</A></B>
</LI><LI CLASS="li-indexenv"><TT>ignore_ops </TT>(option), <B><A HREF="#htoc164">8.14.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>include/1 </TT>(directive), <B><A HREF="#htoc56">7.1.8</A></B>
</LI><LI CLASS="li-indexenv"><TT>infix_op </TT>(property), <B><A HREF="#htoc207">8.19.12</A></B>
</LI><LI CLASS="li-indexenv"><TT>initialization/1 </TT>(directive), <A HREF="#htoc17">4.4.3</A>, <A HREF="#htoc18">4.4.4</A>, <B><A HREF="#htoc62">7.1.14</A></B>, <A HREF="#htoc391">10.7</A>
</LI><LI CLASS="li-indexenv"><TT>input </TT>(property), <B><A HREF="#htoc123">8.10.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>integer/1</TT>, <B><A HREF="#htoc71">8.1.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>integer_rounding_function </TT>(flag), <A HREF="#htoc95">8.6.1</A>, <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv">interpreter, see <I>top-level</I>
</LI><LI CLASS="li-indexenv"><TT>is_list/1</TT>, <B><A HREF="#htoc71">8.1.1</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>jump </TT>(option), <B><A HREF="#htoc355">10.3.2</A></B>, <A HREF="#htoc356">10.3.3</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>keysort/1</TT>, <B><A HREF="#htoc221">8.20.13</A></B>
</LI><LI CLASS="li-indexenv"><TT>keysort/2</TT>, <B><A HREF="#htoc221">8.20.13</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>largest </TT>(FD option), <B><A HREF="#htoc347">9.9.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>last/2</TT>, <B><A HREF="#htoc216">8.20.8</A></B>
</LI><LI CLASS="li-indexenv"><TT>last_modification </TT>(property), <B><A HREF="#htoc263">8.27.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>last_read_start_line_column/2</TT>, <B><A HREF="#htoc163">8.14.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>leash/1 </TT>(debug), <B><A HREF="#htoc26">5.3.2</A></B>, <A HREF="#htoc29">5.5</A>
</LI><LI CLASS="li-indexenv"><TT>length </TT>(property), <B><A HREF="#htoc207">8.19.12</A></B>
</LI><LI CLASS="li-indexenv"><TT>length/2</TT>, <B><A HREF="#htoc217">8.20.9</A></B>
</LI><LI CLASS="li-indexenv"><TT>line </TT>(option), <B><A HREF="#htoc119">8.10.6</A></B>, <A HREF="#htoc140">8.10.27</A>
</LI><LI CLASS="li-indexenv"><TT>line_count/2</TT>, <B><A HREF="#htoc129">8.10.16</A></B>, <A HREF="#htoc131">8.10.18</A>
</LI><LI CLASS="li-indexenv"><TT>line_position/2</TT>, <B><A HREF="#htoc130">8.10.17</A></B>
</LI><LI CLASS="li-indexenv"><TT>linedit</TT>, <B><A HREF="#htoc12">4.2.6</A></B>, <A HREF="#htoc149">8.12.2</A>, <A HREF="#htoc291">8.29</A>, <A HREF="#htoc292">8.29.1</A>, <A HREF="#htoc293">8.29.2</A>, <A HREF="#htoc294">8.29.3</A>, <A HREF="#htoc295">8.29.4</A>
</LI><LI CLASS="li-indexenv"><TT>list/1</TT>, <B><A HREF="#htoc71">8.1.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>list_or_partial_list/1</TT>, <B><A HREF="#htoc71">8.1.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>listing/0</TT>, <B><A HREF="#htoc239">8.23.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>listing/1</TT>, <A HREF="#htoc29">5.5</A>, <A HREF="#htoc166">8.14.8</A>, <B><A HREF="#htoc239">8.23.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>load/1</TT>, <A HREF="#htoc9">4.2.3</A>, <A HREF="#htoc16">4.4.2</A>, <A HREF="#htoc17">4.4.3</A>, <B><A HREF="#htoc238">8.23.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>loose </TT>(debug), <B><A HREF="#htoc26">5.3.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>lower_upper/2</TT>, <B><A HREF="#htoc200">8.19.5</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">MA, <B><A HREF="#htoc16">4.4.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>make_directory/1</TT>, <B><A HREF="#htoc257">8.27.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>maplist/2-8</TT>, <B><A HREF="#htoc220">8.20.12</A></B>
</LI><LI CLASS="li-indexenv"><TT>max </TT>(FD option), <B><A HREF="#htoc347">9.9.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>max_arity </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>max_atom </TT>(flag), <A HREF="#htoc204">8.19.9</A>, <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>max_depth </TT>(option), <B><A HREF="#htoc164">8.14.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>max_integer </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>, <A HREF="#htoc317">9.1.1</A>
</LI><LI CLASS="li-indexenv"><TT>max_list/2</TT>, <B><A HREF="#htoc219">8.20.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>max_regret </TT>(FD option), <B><A HREF="#htoc347">9.9.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>max_unget </TT>(flag), <A HREF="#htoc151">8.12.4</A>, <A HREF="#htoc156">8.13.3</A>, <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>member/2</TT>, <B><A HREF="#htoc210">8.20.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>memberchk/2</TT>, <B><A HREF="#htoc210">8.20.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>meta_predicate </TT>(property), <B><A HREF="#htoc108">8.8.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>middle </TT>(FD option), <B><A HREF="#htoc347">9.9.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>min </TT>(FD option), <B><A HREF="#htoc347">9.9.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>min_integer </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>min_list/2</TT>, <B><A HREF="#htoc219">8.20.11</A></B>
</LI><LI CLASS="li-indexenv">mini-assembly, <A HREF="#htoc3">3</A>, <B><A HREF="#htoc16">4.4.2</A></B>, <A HREF="#htoc20">4.4.6</A>
</LI><LI CLASS="li-indexenv"><TT>mirror </TT>(option), <B><A HREF="#htoc119">8.10.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>mirror </TT>(property), <B><A HREF="#htoc123">8.10.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>mode </TT>(property), <B><A HREF="#htoc123">8.10.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>monofile </TT>(property), <B><A HREF="#htoc108">8.8.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>most_constrained </TT>(FD option), <B><A HREF="#htoc347">9.9.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>msort/1</TT>, <B><A HREF="#htoc221">8.20.13</A></B>
</LI><LI CLASS="li-indexenv"><TT>msort/2</TT>, <B><A HREF="#htoc221">8.20.13</A></B>
</LI><LI CLASS="li-indexenv"><TT>multifile </TT>(property), <B><A HREF="#htoc108">8.8.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>multifile/1 </TT>(directive), <B><A HREF="#htoc52">7.1.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>multifile_warning </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>, <A HREF="#htoc235">8.22.5</A>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">name demangling, <B><A HREF="#htoc20">4.4.6</A></B>
</LI><LI CLASS="li-indexenv">name mangling, <A HREF="#htoc17">4.4.3</A>, <B><A HREF="#htoc20">4.4.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>name/2</TT>, <B><A HREF="#htoc203">8.19.8</A></B>
</LI><LI CLASS="li-indexenv"><TT>name_query_vars/2</TT>, <B><A HREF="#htoc91">8.5.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>name_singleton_vars/1</TT>, <B><A HREF="#htoc90">8.5.1</A></B>, <A HREF="#htoc166">8.14.8</A>
</LI><LI CLASS="li-indexenv"><TT>namevars </TT>(option), <A HREF="#htoc8">4.2.2</A>, <B><A HREF="#htoc92">8.5.3</A></B>, <B><A HREF="#htoc164">8.14.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>native_code </TT>(property), <B><A HREF="#htoc108">8.8.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>needs_quotes </TT>(property), <B><A HREF="#htoc207">8.19.12</A></B>
</LI><LI CLASS="li-indexenv"><TT>needs_scan </TT>(property), <B><A HREF="#htoc207">8.19.12</A></B>
</LI><LI CLASS="li-indexenv"><TT>new_atom/1</TT>, <B><A HREF="#htoc205">8.19.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>new_atom/2</TT>, <B><A HREF="#htoc205">8.19.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>new_atom/3</TT>, <B><A HREF="#htoc205">8.19.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>next </TT>(option), <B><A HREF="#htoc92">8.5.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>nl/0</TT>, <B><A HREF="#htoc152">8.12.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>nl/1</TT>, <B><A HREF="#htoc152">8.12.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>nodebug/0 </TT>(debug), <B><A HREF="#htoc25">5.3.1</A></B>, <A HREF="#htoc29">5.5</A>
</LI><LI CLASS="li-indexenv"><TT>non_fd_var/1 </TT>(FD), <B><A HREF="#htoc326">9.4.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>non_generic_var/1 </TT>(FD), <B><A HREF="#htoc326">9.4.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>none </TT>(debug), <B><A HREF="#htoc26">5.3.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>none </TT>(option), <B><A HREF="#htoc119">8.10.6</A></B>, <A HREF="#htoc140">8.10.27</A>, <B><A HREF="#htoc355">10.3.2</A></B>, <A HREF="#htoc356">10.3.3</A>
</LI><LI CLASS="li-indexenv"><TT>nonvar/1</TT>, <B><A HREF="#htoc71">8.1.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>nospy/1 </TT>(debug), <B><A HREF="#htoc27">5.3.3</A></B>, <A HREF="#htoc29">5.5</A>
</LI><LI CLASS="li-indexenv"><TT>nospyall/0 </TT>(debug), <B><A HREF="#htoc27">5.3.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>notrace/0 </TT>(debug), <B><A HREF="#htoc25">5.3.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>nth/3</TT>, <B><A HREF="#htoc218">8.20.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>number/1</TT>, <B><A HREF="#htoc71">8.1.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>number_atom/2</TT>, <B><A HREF="#htoc202">8.19.7</A></B>
</LI><LI CLASS="li-indexenv"><TT>number_chars/2</TT>, <B><A HREF="#htoc202">8.19.7</A></B>
</LI><LI CLASS="li-indexenv"><TT>number_codes/2</TT>, <B><A HREF="#htoc202">8.19.7</A></B>
</LI><LI CLASS="li-indexenv"><TT>numbervars </TT>(option), <A HREF="#htoc8">4.2.2</A>, <B><A HREF="#htoc92">8.5.3</A></B>, <B><A HREF="#htoc164">8.14.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>numbervars/1</TT>, <B><A HREF="#htoc92">8.5.3</A></B>, <A HREF="#htoc166">8.14.8</A>
</LI><LI CLASS="li-indexenv"><TT>numbervars/3</TT>, <B><A HREF="#htoc92">8.5.3</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>once/1</TT>, <B><A HREF="#htoc192">8.18.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>op/3 </TT>(directive), <B><A HREF="#htoc59">7.1.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>op/3</TT>, <A HREF="#htoc59">7.1.11</A>, <B><A HREF="#htoc168">8.14.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>open/3</TT>, <B><A HREF="#htoc119">8.10.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>open/4</TT>, <A HREF="#htoc114">8.10.1</A>, <B><A HREF="#htoc119">8.10.6</A></B>, <A HREF="#htoc138">8.10.25</A>, <A HREF="#htoc139">8.10.26</A>, <A HREF="#htoc140">8.10.27</A>, <A HREF="#htoc281">8.27.29</A>
</LI><LI CLASS="li-indexenv"><TT>open_input_atom_stream/2</TT>, <B><A HREF="#htoc143">8.11.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>open_input_chars_stream/2</TT>, <B><A HREF="#htoc143">8.11.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>open_input_codes_stream/2</TT>, <B><A HREF="#htoc143">8.11.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>open_output_atom_stream/1</TT>, <B><A HREF="#htoc145">8.11.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>open_output_chars_stream/1</TT>, <B><A HREF="#htoc145">8.11.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>open_output_codes_stream/1</TT>, <B><A HREF="#htoc145">8.11.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>os_error </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>, <A HREF="#htoc386">10.5.12</A>
</LI><LI CLASS="li-indexenv"><TT>os_version/1</TT>, <B><A HREF="#htoc268">8.27.16</A></B>
</LI><LI CLASS="li-indexenv"><TT>output </TT>(property), <B><A HREF="#htoc123">8.10.10</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">Prolog flag, <A HREF="#htoc7">4.2.1</A>, <A HREF="#htoc33">6.2</A>, <A HREF="#htoc33">6.2</A>, <A HREF="#htoc61">7.1.13</A>, <A HREF="#htoc95">8.6.1</A>, <A HREF="#htoc107">8.8.1</A>, <A HREF="#htoc151">8.12.4</A>, <A HREF="#htoc156">8.13.3</A>, <A HREF="#htoc158">8.14</A>, <A HREF="#htoc159">8.14.1</A>, <A HREF="#htoc161">8.14.3</A>, <A HREF="#htoc170">8.14.12</A>, <A HREF="#htoc204">8.19.9</A>, <B><A HREF="#htoc231">8.22.1</A></B>, <A HREF="#htoc232">8.22.2</A>, <A HREF="#htoc235">8.22.5</A>, <A HREF="#htoc317">9.1.1</A>, <A HREF="#htoc385">10.5.11</A>, <A HREF="#htoc386">10.5.12</A>
</LI><LI CLASS="li-indexenv">PrologScript, <B><A HREF="#htoc10">4.2.4</A></B>, <A HREF="#htoc237">8.23.1</A>
</LI><LI CLASS="li-indexenv"><TT>partial_list/1</TT>, <B><A HREF="#htoc71">8.1.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>peek_byte/1</TT>, <B><A HREF="#htoc155">8.13.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>peek_byte/2</TT>, <B><A HREF="#htoc155">8.13.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>peek_char/1</TT>, <B><A HREF="#htoc150">8.12.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>peek_char/2</TT>, <B><A HREF="#htoc150">8.12.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>peek_code/1</TT>, <B><A HREF="#htoc150">8.12.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>peek_code/2</TT>, <B><A HREF="#htoc150">8.12.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>permission </TT>(property), <B><A HREF="#htoc263">8.27.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>permutation/2</TT>, <B><A HREF="#htoc213">8.20.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>phrase/2</TT>, <B><A HREF="#htoc189">8.17.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>phrase/3</TT>, <B><A HREF="#htoc189">8.17.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>popen/3</TT>, <A HREF="#htoc114">8.10.1</A>, <B><A HREF="#htoc273">8.27.21</A></B>
</LI><LI CLASS="li-indexenv"><TT>portray/1</TT>, <B><A HREF="#htoc164">8.14.6</A></B>, <A HREF="#htoc167">8.14.9</A>
</LI><LI CLASS="li-indexenv"><TT>portray_clause/1</TT>, <B><A HREF="#htoc166">8.14.8</A></B>
</LI><LI CLASS="li-indexenv"><TT>portray_clause/2</TT>, <B><A HREF="#htoc166">8.14.8</A></B>, <A HREF="#htoc239">8.23.3</A>
</LI><LI CLASS="li-indexenv"><TT>portrayed </TT>(option), <B><A HREF="#htoc164">8.14.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>position </TT>(property), <B><A HREF="#htoc123">8.10.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>postfix_op </TT>(property), <B><A HREF="#htoc207">8.19.12</A></B>
</LI><LI CLASS="li-indexenv"><TT>predicate_property/2</TT>, <B><A HREF="#htoc108">8.8.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>prefix/2</TT>, <B><A HREF="#htoc214">8.20.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>prefix_op </TT>(property), <B><A HREF="#htoc207">8.19.12</A></B>
</LI><LI CLASS="li-indexenv"><TT>print/1</TT>, <B><A HREF="#htoc164">8.14.6</A></B>, <A HREF="#htoc165">8.14.7</A>
</LI><LI CLASS="li-indexenv"><TT>print/2</TT>, <B><A HREF="#htoc164">8.14.6</A></B>, <A HREF="#htoc167">8.14.9</A>, <A HREF="#htoc176">8.15.4</A>, <A HREF="#htoc177">8.15.5</A>, <A HREF="#htoc178">8.15.6</A>
</LI><LI CLASS="li-indexenv"><TT>print_to_atom/2</TT>, <B><A HREF="#htoc176">8.15.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>print_to_chars/2</TT>, <B><A HREF="#htoc177">8.15.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>print_to_codes/2</TT>, <B><A HREF="#htoc178">8.15.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>priority </TT>(option), <B><A HREF="#htoc164">8.14.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>private </TT>(property), <B><A HREF="#htoc108">8.8.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>prolog_copyright </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>prolog_date </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>prolog_file </TT>(property), <B><A HREF="#htoc108">8.8.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>prolog_file_name/2</TT>, <A HREF="#htoc237">8.23.1</A>, <B><A HREF="#htoc251">8.26.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>prolog_line </TT>(property), <B><A HREF="#htoc108">8.8.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>prolog_name </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>prolog_pid/1</TT>, <B><A HREF="#htoc278">8.27.26</A></B>
</LI><LI CLASS="li-indexenv"><TT>prolog_version </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>public </TT>(property), <B><A HREF="#htoc108">8.8.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>public/1 </TT>(directive), <B><A HREF="#htoc51">7.1.3</A></B>, <A HREF="#htoc100">8.7.1</A>
</LI><LI CLASS="li-indexenv"><TT>punct </TT>(token), <B><A HREF="#htoc161">8.14.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>put/1</TT>, <B><A HREF="#htoc185">8.16.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>put_byte/1</TT>, <B><A HREF="#htoc157">8.13.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>put_byte/2</TT>, <B><A HREF="#htoc157">8.13.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>put_char/1</TT>, <B><A HREF="#htoc152">8.12.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>put_char/2</TT>, <B><A HREF="#htoc152">8.12.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>put_code/1</TT>, <B><A HREF="#htoc152">8.12.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>put_code/2</TT>, <B><A HREF="#htoc152">8.12.5</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>quoted </TT>(option), <A HREF="#htoc8">4.2.2</A>, <B><A HREF="#htoc164">8.14.6</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>random </TT>(FD option), <B><A HREF="#htoc347">9.9.1</A></B>, <B><A HREF="#htoc347">9.9.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>random/1</TT>, <B><A HREF="#htoc246">8.25.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>random/3</TT>, <B><A HREF="#htoc247">8.25.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>randomize/0</TT>, <B><A HREF="#htoc244">8.25.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>read </TT>(mode), <B><A HREF="#htoc119">8.10.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>read </TT>(permission), <B><A HREF="#htoc262">8.27.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>read/1</TT>, <B><A HREF="#htoc159">8.14.1</A></B>, <A HREF="#htoc163">8.14.5</A>
</LI><LI CLASS="li-indexenv"><TT>read/2</TT>, <B><A HREF="#htoc159">8.14.1</A></B>, <A HREF="#htoc163">8.14.5</A>, <A HREF="#htoc173">8.15.1</A>, <A HREF="#htoc174">8.15.2</A>, <A HREF="#htoc175">8.15.3</A>
</LI><LI CLASS="li-indexenv"><TT>read_atom/1</TT>, <B><A HREF="#htoc160">8.14.2</A></B>, <A HREF="#htoc163">8.14.5</A>
</LI><LI CLASS="li-indexenv"><TT>read_atom/2</TT>, <B><A HREF="#htoc160">8.14.2</A></B>, <A HREF="#htoc163">8.14.5</A>, <A HREF="#htoc170">8.14.12</A>
</LI><LI CLASS="li-indexenv"><TT>read_from_atom/2</TT>, <B><A HREF="#htoc173">8.15.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>read_from_chars/2</TT>, <B><A HREF="#htoc174">8.15.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>read_from_codes/2</TT>, <B><A HREF="#htoc175">8.15.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>read_integer/1</TT>, <B><A HREF="#htoc160">8.14.2</A></B>, <A HREF="#htoc163">8.14.5</A>
</LI><LI CLASS="li-indexenv"><TT>read_integer/2</TT>, <B><A HREF="#htoc160">8.14.2</A></B>, <A HREF="#htoc163">8.14.5</A>, <A HREF="#htoc170">8.14.12</A>
</LI><LI CLASS="li-indexenv"><TT>read_number/1</TT>, <B><A HREF="#htoc160">8.14.2</A></B>, <A HREF="#htoc163">8.14.5</A>
</LI><LI CLASS="li-indexenv"><TT>read_number/2</TT>, <B><A HREF="#htoc160">8.14.2</A></B>, <A HREF="#htoc163">8.14.5</A>, <A HREF="#htoc170">8.14.12</A>
</LI><LI CLASS="li-indexenv"><TT>read_pl_state_file/1</TT>, <B><A HREF="#htoc235">8.22.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>read_term/2</TT>, <B><A HREF="#htoc159">8.14.1</A></B>, <A HREF="#htoc163">8.14.5</A>
</LI><LI CLASS="li-indexenv"><TT>read_term/3</TT>, <B><A HREF="#htoc159">8.14.1</A></B>, <A HREF="#htoc163">8.14.5</A>, <A HREF="#htoc170">8.14.12</A>, <A HREF="#htoc173">8.15.1</A>, <A HREF="#htoc174">8.15.2</A>, <A HREF="#htoc175">8.15.3</A>
</LI><LI CLASS="li-indexenv"><TT>read_term_from_atom/3</TT>, <A HREF="#htoc7">4.2.1</A>, <A HREF="#htoc159">8.14.1</A>, <B><A HREF="#htoc173">8.15.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>read_term_from_chars/3</TT>, <B><A HREF="#htoc174">8.15.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>read_term_from_codes/3</TT>, <B><A HREF="#htoc175">8.15.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>read_token/1</TT>, <B><A HREF="#htoc161">8.14.3</A></B>, <A HREF="#htoc163">8.14.5</A>
</LI><LI CLASS="li-indexenv"><TT>read_token/2</TT>, <B><A HREF="#htoc161">8.14.3</A></B>, <A HREF="#htoc163">8.14.5</A>, <A HREF="#htoc170">8.14.12</A>, <A HREF="#htoc173">8.15.1</A>, <A HREF="#htoc174">8.15.2</A>, <A HREF="#htoc175">8.15.3</A>
</LI><LI CLASS="li-indexenv"><TT>read_token_from_atom/2</TT>, <B><A HREF="#htoc173">8.15.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>read_token_from_chars/2</TT>, <B><A HREF="#htoc174">8.15.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>read_token_from_codes/2</TT>, <B><A HREF="#htoc175">8.15.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>real_file_name </TT>(property), <B><A HREF="#htoc263">8.27.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>real_time/1</TT>, <B><A HREF="#htoc242">8.24.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>regular </TT>(permission), <B><A HREF="#htoc263">8.27.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>remove_stream_mirror/2</TT>, <A HREF="#htoc114">8.10.1</A>, <A HREF="#htoc135">8.10.22</A>, <B><A HREF="#htoc136">8.10.23</A></B>
</LI><LI CLASS="li-indexenv"><TT>rename_file/2</TT>, <B><A HREF="#htoc260">8.27.8</A></B>
</LI><LI CLASS="li-indexenv"><TT>reorder </TT>(FD option), <B><A HREF="#htoc347">9.9.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>repeat/0</TT>, <B><A HREF="#htoc193">8.18.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>reposition </TT>(option), <B><A HREF="#htoc119">8.10.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>reposition </TT>(property), <B><A HREF="#htoc123">8.10.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>reset </TT>(option), <B><A HREF="#htoc119">8.10.6</A></B>, <A HREF="#htoc139">8.10.26</A>
</LI><LI CLASS="li-indexenv"><TT>retract/1</TT>, <B><A HREF="#htoc102">8.7.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>retractall/1</TT>, <B><A HREF="#htoc103">8.7.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>return </TT>(option), <B><A HREF="#htoc355">10.3.2</A></B>, <A HREF="#htoc356">10.3.3</A>
</LI><LI CLASS="li-indexenv"><TT>reverse/2</TT>, <B><A HREF="#htoc211">8.20.3</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>search </TT>(permission), <B><A HREF="#htoc262">8.27.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>see/1</TT>, <B><A HREF="#htoc181">8.16.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>seeing/1</TT>, <B><A HREF="#htoc182">8.16.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>seek/4</TT>, <B><A HREF="#htoc127">8.10.14</A></B>
</LI><LI CLASS="li-indexenv"><TT>seen/0</TT>, <B><A HREF="#htoc183">8.16.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>select/3</TT>, <B><A HREF="#htoc212">8.20.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>select/5</TT>, <A HREF="#htoc114">8.10.1</A>, <B><A HREF="#htoc281">8.27.29</A></B>, <A HREF="#htoc287">8.28.5</A>, <A HREF="#htoc289">8.28.7</A>
</LI><LI CLASS="li-indexenv"><TT>send_signal/2</TT>, <B><A HREF="#htoc279">8.27.27</A></B>
</LI><LI CLASS="li-indexenv"><TT>set_bip_name/2</TT>, <A HREF="#htoc35">6.3.1</A>, <B><A HREF="#htoc233">8.22.3</A></B>, <A HREF="#htoc375">10.5.1</A>
</LI><LI CLASS="li-indexenv"><TT>set_input/1</TT>, <A HREF="#htoc114">8.10.1</A>, <B><A HREF="#htoc117">8.10.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>set_linedit_prompt/1</TT>, <B><A HREF="#htoc293">8.29.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>set_output/1</TT>, <A HREF="#htoc114">8.10.1</A>, <B><A HREF="#htoc118">8.10.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>set_prolog_flag/2 </TT>(directive), <B><A HREF="#htoc61">7.1.13</A></B>
</LI><LI CLASS="li-indexenv"><TT>set_prolog_flag/2</TT>, <A HREF="#htoc61">7.1.13</A>, <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>set_seed/1</TT>, <B><A HREF="#htoc244">8.25.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>set_stream_buffering/2</TT>, <A HREF="#htoc114">8.10.1</A>, <B><A HREF="#htoc140">8.10.27</A></B>, <A HREF="#htoc281">8.27.29</A>, <A HREF="#htoc283">8.28.1</A>
</LI><LI CLASS="li-indexenv"><TT>set_stream_eof_action/2</TT>, <B><A HREF="#htoc139">8.10.26</A></B>
</LI><LI CLASS="li-indexenv"><TT>set_stream_line_column/3</TT>, <B><A HREF="#htoc132">8.10.19</A></B>
</LI><LI CLASS="li-indexenv"><TT>set_stream_position/2</TT>, <A HREF="#htoc114">8.10.1</A>, <B><A HREF="#htoc126">8.10.13</A></B>
</LI><LI CLASS="li-indexenv"><TT>set_stream_type/2</TT>, <B><A HREF="#htoc138">8.10.25</A></B>, <A HREF="#htoc283">8.28.1</A>
</LI><LI CLASS="li-indexenv"><TT>setarg/3</TT>, <B><A HREF="#htoc88">8.4.8</A></B>
</LI><LI CLASS="li-indexenv"><TT>setarg/4</TT>, <B><A HREF="#htoc88">8.4.8</A></B>
</LI><LI CLASS="li-indexenv"><TT>setof/3</TT>, <B><A HREF="#htoc112">8.9.3</A></B>
</LI><LI CLASS="li-indexenv">shebang support, <B><A HREF="#htoc10">4.2.4</A></B>, <A HREF="#htoc237">8.23.1</A>
</LI><LI CLASS="li-indexenv"><TT>shell/0</TT>, <B><A HREF="#htoc270">8.27.18</A></B>
</LI><LI CLASS="li-indexenv"><TT>shell/1</TT>, <B><A HREF="#htoc270">8.27.18</A></B>
</LI><LI CLASS="li-indexenv"><TT>shell/2</TT>, <B><A HREF="#htoc270">8.27.18</A></B>
</LI><LI CLASS="li-indexenv"><TT>singleton_warning </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>, <A HREF="#htoc235">8.22.5</A>
</LI><LI CLASS="li-indexenv"><TT>singletons </TT>(option), <A HREF="#htoc91">8.5.2</A>, <A HREF="#htoc92">8.5.3</A>, <B><A HREF="#htoc159">8.14.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>size </TT>(property), <B><A HREF="#htoc263">8.27.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>skip/1</TT>, <B><A HREF="#htoc184">8.16.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>sleep/1</TT>, <B><A HREF="#htoc280">8.27.28</A></B>
</LI><LI CLASS="li-indexenv"><TT>smallest </TT>(FD option), <B><A HREF="#htoc347">9.9.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>socket </TT>(permission), <B><A HREF="#htoc263">8.27.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>socket/2</TT>, <B><A HREF="#htoc284">8.28.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>socket_accept/3</TT>, <B><A HREF="#htoc289">8.28.7</A></B>
</LI><LI CLASS="li-indexenv"><TT>socket_accept/4</TT>, <B><A HREF="#htoc289">8.28.7</A></B>
</LI><LI CLASS="li-indexenv"><TT>socket_bind/2</TT>, <B><A HREF="#htoc286">8.28.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>socket_close/1</TT>, <B><A HREF="#htoc285">8.28.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>socket_connect/4</TT>, <A HREF="#htoc114">8.10.1</A>, <A HREF="#htoc285">8.28.3</A>, <B><A HREF="#htoc287">8.28.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>socket_listen/2</TT>, <B><A HREF="#htoc288">8.28.6</A></B>
</LI><LI CLASS="li-indexenv">soft-cut, <A HREF="#htoc66">7.2.2</A>
</LI><LI CLASS="li-indexenv"><TT>sort/1</TT>, <B><A HREF="#htoc221">8.20.13</A></B>
</LI><LI CLASS="li-indexenv"><TT>sort/2</TT>, <B><A HREF="#htoc221">8.20.13</A></B>
</LI><LI CLASS="li-indexenv"><TT>space_args </TT>(option), <B><A HREF="#htoc164">8.14.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>spawn/2</TT>, <B><A HREF="#htoc272">8.27.20</A></B>
</LI><LI CLASS="li-indexenv"><TT>spawn/3</TT>, <B><A HREF="#htoc272">8.27.20</A></B>
</LI><LI CLASS="li-indexenv"><TT>spy/1 </TT>(debug), <B><A HREF="#htoc27">5.3.3</A></B>, <A HREF="#htoc29">5.5</A>
</LI><LI CLASS="li-indexenv"><TT>spypoint_condition/3 </TT>(debug), <B><A HREF="#htoc27">5.3.3</A></B>, <A HREF="#htoc29">5.5</A>
</LI><LI CLASS="li-indexenv"><TT>sr_change_options/2</TT>, <B><A HREF="#htoc299">8.30.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_close/1</TT>, <B><A HREF="#htoc300">8.30.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_current_descriptor/1</TT>, <B><A HREF="#htoc302">8.30.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_error_from_exception/2</TT>, <B><A HREF="#htoc312">8.30.16</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_get_error_counters/3</TT>, <B><A HREF="#htoc310">8.30.14</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_get_file_name/2</TT>, <B><A HREF="#htoc305">8.30.9</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_get_include_list/2</TT>, <B><A HREF="#htoc307">8.30.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_get_include_stream_list/2</TT>, <B><A HREF="#htoc308">8.30.12</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_get_module/3</TT>, <B><A HREF="#htoc304">8.30.8</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_get_position/3</TT>, <B><A HREF="#htoc306">8.30.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_get_size_counters/3</TT>, <B><A HREF="#htoc309">8.30.13</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_get_stream/2</TT>, <B><A HREF="#htoc303">8.30.7</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_open/3</TT>, <B><A HREF="#htoc298">8.30.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_read_term/4</TT>, <B><A HREF="#htoc301">8.30.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_set_error_counters/3</TT>, <B><A HREF="#htoc311">8.30.15</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_write_error/2</TT>, <B><A HREF="#htoc314">8.30.18</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_write_error/4</TT>, <B><A HREF="#htoc314">8.30.18</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_write_error/6</TT>, <B><A HREF="#htoc314">8.30.18</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_write_message/4</TT>, <B><A HREF="#htoc313">8.30.17</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_write_message/6</TT>, <B><A HREF="#htoc313">8.30.17</A></B>
</LI><LI CLASS="li-indexenv"><TT>sr_write_message/8</TT>, <B><A HREF="#htoc313">8.30.17</A></B>
</LI><LI CLASS="li-indexenv"><TT>standard </TT>(FD option), <B><A HREF="#htoc347">9.9.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>static </TT>(property), <B><A HREF="#htoc108">8.8.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>statistics/0</TT>, <B><A HREF="#htoc241">8.24.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>statistics/2</TT>, <B><A HREF="#htoc241">8.24.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>stop/0</TT>, <B><A HREF="#htoc191">8.18.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>stream_line_column/3</TT>, <B><A HREF="#htoc131">8.10.18</A></B>
</LI><LI CLASS="li-indexenv"><TT>stream_position/2</TT>, <B><A HREF="#htoc125">8.10.12</A></B>, <A HREF="#htoc126">8.10.13</A>
</LI><LI CLASS="li-indexenv"><TT>stream_property/2</TT>, <B><A HREF="#htoc123">8.10.10</A></B>, <A HREF="#htoc124">8.10.11</A>, <A HREF="#htoc125">8.10.12</A>, <A HREF="#htoc126">8.10.13</A>, <A HREF="#htoc134">8.10.21</A>, <A HREF="#htoc137">8.10.24</A>
</LI><LI CLASS="li-indexenv"><TT>strict_iso </TT>(flag), <A HREF="#htoc33">6.2</A>, <A HREF="#htoc107">8.8.1</A>, <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>string </TT>(token), <B><A HREF="#htoc161">8.14.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>sub_atom/5</TT>, <B><A HREF="#htoc198">8.19.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>sublist/2</TT>, <B><A HREF="#htoc215">8.20.7</A></B>
</LI><LI CLASS="li-indexenv"><TT>subsumes_term/2</TT>, <B><A HREF="#htoc86">8.4.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>succ/2</TT>, <B><A HREF="#htoc98">8.6.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>suffix/2</TT>, <B><A HREF="#htoc214">8.20.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>sum_list/2</TT>, <B><A HREF="#htoc219">8.20.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>suspicious_warning </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>, <A HREF="#htoc235">8.22.5</A>
</LI><LI CLASS="li-indexenv"><TT>syntax_error </TT>(flag), <A HREF="#htoc159">8.14.1</A>, <B><A HREF="#htoc231">8.22.1</A></B>, <A HREF="#htoc385">10.5.11</A>
</LI><LI CLASS="li-indexenv"><TT>syntax_error </TT>(option), <B><A HREF="#htoc159">8.14.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>syntax_error_info/4</TT>, <B><A HREF="#htoc162">8.14.4</A></B>, <A HREF="#htoc385">10.5.11</A>
</LI><LI CLASS="li-indexenv"><TT>system/1</TT>, <B><A HREF="#htoc271">8.27.19</A></B>
</LI><LI CLASS="li-indexenv"><TT>system/2</TT>, <B><A HREF="#htoc271">8.27.19</A></B>
</LI><LI CLASS="li-indexenv"><TT>system_time/1</TT>, <B><A HREF="#htoc242">8.24.2</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>tab/1</TT>, <B><A HREF="#htoc185">8.16.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>tell/1</TT>, <B><A HREF="#htoc181">8.16.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>telling/1</TT>, <B><A HREF="#htoc182">8.16.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>temporary_file/3</TT>, <B><A HREF="#htoc265">8.27.13</A></B>
</LI><LI CLASS="li-indexenv"><TT>temporary_name/2</TT>, <B><A HREF="#htoc264">8.27.12</A></B>
</LI><LI CLASS="li-indexenv"><TT>term_ref/2</TT>, <B><A HREF="#htoc93">8.5.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>term_variables/2</TT>, <B><A HREF="#htoc85">8.4.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>term_variables/3</TT>, <B><A HREF="#htoc85">8.4.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>text </TT>(option), <B><A HREF="#htoc119">8.10.6</A></B>, <A HREF="#htoc138">8.10.25</A>
</LI><LI CLASS="li-indexenv"><TT>throw/1</TT>, <A HREF="#htoc23">5.2</A>, <A HREF="#htoc35">6.3.1</A>, <B><A HREF="#htoc68">7.2.4</A></B>, <A HREF="#htoc388">10.6.1</A>
</LI><LI CLASS="li-indexenv"><TT>tight </TT>(debug), <B><A HREF="#htoc26">5.3.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>told/0</TT>, <B><A HREF="#htoc183">8.16.4</A></B>
</LI><LI CLASS="li-indexenv">top-level, <B><A HREF="#htoc7">4.2.1</A></B>, <A HREF="#htoc12">4.2.6</A>, <A HREF="#htoc17">4.4.3</A>, <A HREF="#htoc18">4.4.4</A>, <A HREF="#htoc19">4.4.5</A>, <A HREF="#htoc191">8.18.1</A>, <A HREF="#htoc191">8.18.1</A>, <A HREF="#htoc191">8.18.1</A>, <A HREF="#htoc191">8.18.1</A>, <A HREF="#htoc292">8.29.1</A>, <A HREF="#htoc293">8.29.2</A>, <A HREF="#htoc391">10.7</A>
</LI><LI CLASS="li-indexenv"><TT>top_level/0</TT>, <A HREF="#htoc7">4.2.1</A>, <B><A HREF="#htoc191">8.18.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>trace/0 </TT>(debug), <A HREF="#htoc9">4.2.3</A>, <A HREF="#htoc11">4.2.5</A>, <B><A HREF="#htoc25">5.3.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>true/0</TT>, <B><A HREF="#htoc65">7.2.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>type </TT>(option), <B><A HREF="#htoc119">8.10.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>type </TT>(property), <B><A HREF="#htoc123">8.10.10</A></B>, <B><A HREF="#htoc263">8.27.11</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>unget_byte/1</TT>, <B><A HREF="#htoc156">8.13.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>unget_byte/2</TT>, <B><A HREF="#htoc156">8.13.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>unget_char/1</TT>, <B><A HREF="#htoc151">8.12.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>unget_char/2</TT>, <B><A HREF="#htoc151">8.12.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>unget_code/1</TT>, <B><A HREF="#htoc151">8.12.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>unget_code/2</TT>, <B><A HREF="#htoc151">8.12.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>unify_with_occurs_check/2</TT>, <B><A HREF="#htoc74">8.2.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>unix </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>unknown </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>unknown </TT>(permission), <B><A HREF="#htoc263">8.27.11</A></B>
</LI><LI CLASS="li-indexenv"><TT>unlink/1</TT>, <B><A HREF="#htoc261">8.27.9</A></B>
</LI><LI CLASS="li-indexenv"><TT>user </TT>(property), <B><A HREF="#htoc108">8.8.2</A></B>
</LI><LI CLASS="li-indexenv"><TT>user</TT>, <B><A HREF="#htoc180">8.16.1</A></B>, <A HREF="#htoc182">8.16.3</A>, <A HREF="#htoc182">8.16.3</A>, <A HREF="#htoc237">8.23.1</A>, <A HREF="#htoc249">8.26.1</A>, <A HREF="#htoc251">8.26.3</A>
</LI><LI CLASS="li-indexenv"><TT>user_error</TT>, <B><A HREF="#htoc114">8.10.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>user_input</TT>, <B><A HREF="#htoc114">8.10.1</A></B>, <A HREF="#htoc120">8.10.7</A>, <A HREF="#htoc180">8.16.1</A>, <A HREF="#htoc180">8.16.1</A>, <A HREF="#htoc182">8.16.3</A>, <A HREF="#htoc183">8.16.4</A>
</LI><LI CLASS="li-indexenv"><TT>user_output</TT>, <B><A HREF="#htoc114">8.10.1</A></B>, <A HREF="#htoc120">8.10.7</A>, <A HREF="#htoc180">8.16.1</A>, <A HREF="#htoc180">8.16.1</A>, <A HREF="#htoc182">8.16.3</A>, <A HREF="#htoc183">8.16.4</A>
</LI><LI CLASS="li-indexenv"><TT>user_time/1</TT>, <B><A HREF="#htoc242">8.24.2</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv"><TT>value_method </TT>(FD option), <B><A HREF="#htoc347">9.9.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>var </TT>(token), <B><A HREF="#htoc161">8.14.3</A></B>
</LI><LI CLASS="li-indexenv"><TT>var/1</TT>, <B><A HREF="#htoc71">8.1.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>variable_method </TT>(FD option), <B><A HREF="#htoc347">9.9.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>variable_names </TT>(option), <A HREF="#htoc91">8.5.2</A>, <A HREF="#htoc92">8.5.3</A>, <B><A HREF="#htoc159">8.14.1</A></B>, <B><A HREF="#htoc164">8.14.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>variables </TT>(option), <B><A HREF="#htoc159">8.14.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>vector_max </TT>(FD), <B><A HREF="#htoc317">9.1.1</A></B>, <A HREF="#htoc320">9.2.2</A>, <A HREF="#htoc321">9.2.3</A>, <A HREF="#htoc334">9.6.4</A>
</LI><LI CLASS="li-indexenv"><TT>version </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>version_data </TT>(flag), <B><A HREF="#htoc231">8.22.1</A></B>
<BR>
<BR>
</LI><LI CLASS="li-indexenv">WAM, <B><A HREF="#htoc3">3</A></B>, <A HREF="#htoc16">4.4.2</A>, <A HREF="#htoc16">4.4.2</A>, <A HREF="#htoc30">5.6</A>
</LI><LI CLASS="li-indexenv">Warren Abstract Machine, see <I>WAM</I>
</LI><LI CLASS="li-indexenv"><TT>wait/2</TT>, <B><A HREF="#htoc277">8.27.25</A></B>
</LI><LI CLASS="li-indexenv"><TT>wam_debug/0 </TT>(debug), <B><A HREF="#htoc25">5.3.1</A></B>, <A HREF="#htoc30">5.6</A>
</LI><LI CLASS="li-indexenv"><TT>warning </TT>(option), <B><A HREF="#htoc159">8.14.1</A></B>
</LI><LI CLASS="li-indexenv"><TT>working_directory/1</TT>, <B><A HREF="#htoc258">8.27.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>write </TT>(mode), <B><A HREF="#htoc119">8.10.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>write </TT>(permission), <B><A HREF="#htoc262">8.27.10</A></B>
</LI><LI CLASS="li-indexenv"><TT>write/1</TT>, <B><A HREF="#htoc164">8.14.6</A></B>, <A HREF="#htoc165">8.14.7</A>
</LI><LI CLASS="li-indexenv"><TT>write/2</TT>, <B><A HREF="#htoc164">8.14.6</A></B>, <A HREF="#htoc176">8.15.4</A>, <A HREF="#htoc177">8.15.5</A>, <A HREF="#htoc178">8.15.6</A>
</LI><LI CLASS="li-indexenv"><TT>write_canonical/1</TT>, <B><A HREF="#htoc164">8.14.6</A></B>, <A HREF="#htoc165">8.14.7</A>
</LI><LI CLASS="li-indexenv"><TT>write_canonical/2</TT>, <B><A HREF="#htoc164">8.14.6</A></B>, <A HREF="#htoc176">8.15.4</A>, <A HREF="#htoc177">8.15.5</A>, <A HREF="#htoc178">8.15.6</A>
</LI><LI CLASS="li-indexenv"><TT>write_canonical_to_atom/2</TT>, <B><A HREF="#htoc176">8.15.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>write_canonical_to_chars/2</TT>, <B><A HREF="#htoc177">8.15.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>write_canonical_to_codes/2</TT>, <B><A HREF="#htoc178">8.15.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>write_pl_state_file/1</TT>, <A HREF="#htoc17">4.4.3</A>, <B><A HREF="#htoc235">8.22.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>write_term/2</TT>, <B><A HREF="#htoc164">8.14.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>write_term/3</TT>, <A HREF="#htoc8">4.2.2</A>, <A HREF="#htoc28">5.4</A>, <B><A HREF="#htoc164">8.14.6</A></B>, <A HREF="#htoc176">8.15.4</A>, <A HREF="#htoc177">8.15.5</A>, <A HREF="#htoc178">8.15.6</A>
</LI><LI CLASS="li-indexenv"><TT>write_term_to_atom/3</TT>, <B><A HREF="#htoc176">8.15.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>write_term_to_chars/3</TT>, <B><A HREF="#htoc177">8.15.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>write_term_to_codes/3</TT>, <B><A HREF="#htoc178">8.15.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>write_to_atom/2</TT>, <B><A HREF="#htoc176">8.15.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>write_to_chars/2</TT>, <B><A HREF="#htoc177">8.15.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>write_to_codes/2</TT>, <B><A HREF="#htoc178">8.15.6</A></B>
</LI><LI CLASS="li-indexenv"><TT>writeq/1</TT>, <B><A HREF="#htoc164">8.14.6</A></B>, <A HREF="#htoc165">8.14.7</A>
</LI><LI CLASS="li-indexenv"><TT>writeq/2</TT>, <B><A HREF="#htoc164">8.14.6</A></B>, <A HREF="#htoc176">8.15.4</A>, <A HREF="#htoc177">8.15.5</A>, <A HREF="#htoc178">8.15.6</A>, <A HREF="#htoc366">10.4.2</A>
</LI><LI CLASS="li-indexenv"><TT>writeq_to_atom/2</TT>, <B><A HREF="#htoc176">8.15.4</A></B>
</LI><LI CLASS="li-indexenv"><TT>writeq_to_chars/2</TT>, <B><A HREF="#htoc177">8.15.5</A></B>
</LI><LI CLASS="li-indexenv"><TT>writeq_to_codes/2</TT>, <B><A HREF="#htoc178">8.15.6</A></B>
</LI></UL></TD></TR>
</TABLE><!--CUT END -->
<!--HTMLFOOT-->

<HR SIZE=2>
Copyright (C) 1999-2012 Daniel Diaz
Verbatim copying and distribution of this entire article is permitted in any
medium, provided this notice is preserved. <A HREF="index.html#copyright">More about the copyright</A>
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
<A HREF="http://hevea.inria.fr/index.html">H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</A>.</EM></BLOCKQUOTE></BODY>
</HTML>
